<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title> 4 语义概念的严格刻画 | Baby Logic</title>
  <meta name="description" content=" 4 语义概念的严格刻画 | Baby Logic Textbooks" />
  <meta name="generator" content="bookdown 0.21.4 and GitBook 2.6.7" />

  <meta property="og:title" content=" 4 语义概念的严格刻画 | Baby Logic" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://duoyu.ren/" />
  <meta property="og:image" content="https://duoyu.ren//img/cover.png" />
  <meta property="og:description" content=" 4 语义概念的严格刻画 | Baby Logic Textbooks" />
  <meta name="github-repo" content="superfluous-man/baby-logic" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content=" 4 语义概念的严格刻画 | Baby Logic" />
  
  <meta name="twitter:description" content=" 4 语义概念的严格刻画 | Baby Logic Textbooks" />
  <meta name="twitter:image" content="https://duoyu.ren//img/cover.png" />

<meta name="author" content="Lǐ Èrgǒu" />


<meta name="date" content="2021-03-04" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="chap-truth-table.html"/>
<link rel="next" href="references.html"/>
<script src="libs/header-attrs-2.6/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
<link rel="manifest" href="/img/site.webmanifest">
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

<script type="text/javascript">

// open external links in new tabs  Xi Hui

(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();



</script>




<link rel="stylesheet" href="zlogic.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="https://duoyu.ren">Baby Logic</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a></li>
<li class="chapter" data-level="1" data-path="bookintro.html"><a href="bookintro.html"><i class="fa fa-check"></i><b>1</b> 全书绪论</a>
<ul>
<li class="chapter" data-level="1.1" data-path="bookintro.html"><a href="bookintro.html#论说"><i class="fa fa-check"></i><b>1.1</b> 论说</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="bookintro.html"><a href="bookintro.html#论说的好坏"><i class="fa fa-check"></i><b>1.1.1</b> 论说的好坏</a></li>
<li class="chapter" data-level="1.1.2" data-path="bookintro.html"><a href="bookintro.html#论说形式的好坏"><i class="fa fa-check"></i><b>1.1.2</b> 论说形式的好坏</a></li>
<li class="chapter" data-level="1.1.3" data-path="bookintro.html"><a href="bookintro.html#论说好坏取决于形式的好坏"><i class="fa fa-check"></i><b>1.1.3</b> 论说好坏取决于形式的好坏</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="bookintro.html"><a href="bookintro.html#演绎"><i class="fa fa-check"></i><b>1.2</b> 演绎</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="bookintro.html"><a href="bookintro.html#演绎的例子一"><i class="fa fa-check"></i><b>1.2.1</b> 演绎的例子一</a></li>
<li class="chapter" data-level="1.2.2" data-path="bookintro.html"><a href="bookintro.html#演绎的例子二"><i class="fa fa-check"></i><b>1.2.2</b> 演绎的例子二</a></li>
<li class="chapter" data-level="1.2.3" data-path="bookintro.html"><a href="bookintro.html#可演绎性可证性和独立性"><i class="fa fa-check"></i><b>1.2.3</b> 可演绎性、可证性和独立性</a></li>
<li class="chapter" data-level="1.2.4" data-path="bookintro.html"><a href="bookintro.html#可演绎性与论说"><i class="fa fa-check"></i><b>1.2.4</b> 可演绎性与论说</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="bookintro.html"><a href="bookintro.html#一致性"><i class="fa fa-check"></i><b>1.3</b> 一致性</a>
<ul>
<li class="chapter" data-level="1.3.1" data-path="bookintro.html"><a href="bookintro.html#关于一致性的基本想法"><i class="fa fa-check"></i><b>1.3.1</b> 关于一致性的基本想法</a></li>
<li class="chapter" data-level="1.3.2" data-path="bookintro.html"><a href="bookintro.html#不一致命题集的例子"><i class="fa fa-check"></i><b>1.3.2</b> 不一致命题集的例子</a></li>
<li class="chapter" data-level="1.3.3" data-path="bookintro.html"><a href="bookintro.html#一致性逻辑蕴涵与可演绎性"><i class="fa fa-check"></i><b>1.3.3</b> 一致性、逻辑蕴涵与可演绎性</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="bookintro.html"><a href="bookintro.html#逻辑或逻辑的若干问题"><i class="fa fa-check"></i><b>1.4</b> 逻辑或「逻辑」的若干问题</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path="bookintro.html"><a href="bookintro.html#逻辑是什么不是逻辑问题"><i class="fa fa-check"></i><b>1.4.1</b> 「逻辑是什么」不是逻辑问题</a></li>
<li class="chapter" data-level="1.4.2" data-path="bookintro.html"><a href="bookintro.html#逻辑与逻辑的用法"><i class="fa fa-check"></i><b>1.4.2</b> 逻辑与「逻辑」的用法</a></li>
<li class="chapter" data-level="1.4.3" data-path="bookintro.html"><a href="bookintro.html#逻辑与习惯的说理方式"><i class="fa fa-check"></i><b>1.4.3</b> 逻辑与「习惯的说理方式」</a></li>
<li class="chapter" data-level="1.4.4" data-path="bookintro.html"><a href="bookintro.html#当代逻辑传统逻辑和普通人需要的逻辑"><i class="fa fa-check"></i><b>1.4.4</b> 当代逻辑、传统逻辑和「普通人需要的逻辑」</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="prechap.html"><a href="prechap.html"><i class="fa fa-check"></i><b>2</b> 预备章节</a>
<ul>
<li class="chapter" data-level="2.1" data-path="prechap.html"><a href="prechap.html#集合属性元素外延"><i class="fa fa-check"></i><b>2.1</b> 集合：属性、元素、外延</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="prechap.html"><a href="prechap.html#extensionality"><i class="fa fa-check"></i><b>2.1.1</b> Extensionality</a></li>
<li class="chapter" data-level="2.1.2" data-path="prechap.html"><a href="prechap.html#subsets-and-power-sets"><i class="fa fa-check"></i><b>2.1.2</b> Subsets and Power Sets</a></li>
<li class="chapter" data-level="2.1.3" data-path="prechap.html"><a href="prechap.html#SomeImpSet"><i class="fa fa-check"></i><b>2.1.3</b> Some Important Sets</a></li>
<li class="chapter" data-level="2.1.4" data-path="prechap.html"><a href="prechap.html#unions-and-intersections"><i class="fa fa-check"></i><b>2.1.4</b> Unions and Intersections</a></li>
<li class="chapter" data-level="2.1.5" data-path="prechap.html"><a href="prechap.html#CartesianP"><i class="fa fa-check"></i><b>2.1.5</b> Pairs, Tuples, Cartesian Products</a></li>
<li class="chapter" data-level="2.1.6" data-path="prechap.html"><a href="prechap.html#russells-paradox"><i class="fa fa-check"></i><b>2.1.6</b> Russell’s Paradox</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="prechap.html"><a href="prechap.html#关系集合上的结构"><i class="fa fa-check"></i><b>2.2</b> 关系：集合上的结构</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="prechap.html"><a href="prechap.html#RelationSet"><i class="fa fa-check"></i><b>2.2.1</b> Relations as Sets</a></li>
<li class="chapter" data-level="2.2.2" data-path="prechap.html"><a href="prechap.html#philosophical-reflections"><i class="fa fa-check"></i><b>2.2.2</b> Philosophical Reflections</a></li>
<li class="chapter" data-level="2.2.3" data-path="prechap.html"><a href="prechap.html#special-properties-of-relations"><i class="fa fa-check"></i><b>2.2.3</b> Special Properties of Relations</a></li>
<li class="chapter" data-level="2.2.4" data-path="prechap.html"><a href="prechap.html#equivalence-relations"><i class="fa fa-check"></i><b>2.2.4</b> Equivalence Relations</a></li>
<li class="chapter" data-level="2.2.5" data-path="prechap.html"><a href="prechap.html#orders"><i class="fa fa-check"></i><b>2.2.5</b> Orders</a></li>
<li class="chapter" data-level="2.2.6" data-path="prechap.html"><a href="prechap.html#graphs"><i class="fa fa-check"></i><b>2.2.6</b> Graphs</a></li>
<li class="chapter" data-level="2.2.7" data-path="prechap.html"><a href="prechap.html#operations-on-relations"><i class="fa fa-check"></i><b>2.2.7</b> Operations on Relations</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="prechap.html"><a href="prechap.html#函数关系之特例"><i class="fa fa-check"></i><b>2.3</b> 函数：关系之特例</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="prechap.html"><a href="prechap.html#basics"><i class="fa fa-check"></i><b>2.3.1</b> Basics</a></li>
<li class="chapter" data-level="2.3.2" data-path="prechap.html"><a href="prechap.html#kinds-of-functions"><i class="fa fa-check"></i><b>2.3.2</b> Kinds of Functions</a></li>
<li class="chapter" data-level="2.3.3" data-path="prechap.html"><a href="prechap.html#functions-as-relations"><i class="fa fa-check"></i><b>2.3.3</b> Functions as Relations</a></li>
<li class="chapter" data-level="2.3.4" data-path="prechap.html"><a href="prechap.html#inverses-of-functions"><i class="fa fa-check"></i><b>2.3.4</b> Inverses of Functions</a></li>
<li class="chapter" data-level="2.3.5" data-path="prechap.html"><a href="prechap.html#composition-of-functions"><i class="fa fa-check"></i><b>2.3.5</b> Composition of Functions</a></li>
<li class="chapter" data-level="2.3.6" data-path="prechap.html"><a href="prechap.html#partial-functions"><i class="fa fa-check"></i><b>2.3.6</b> Partial Functions</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="prechap.html"><a href="prechap.html#基数集合大小的度量"><i class="fa fa-check"></i><b>2.4</b> 基数：集合大小的度量</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="prechap.html"><a href="prechap.html#introduction"><i class="fa fa-check"></i><b>2.4.1</b> Introduction</a></li>
<li class="chapter" data-level="2.4.2" data-path="prechap.html"><a href="prechap.html#enumerations-and-enumerable-sets"><i class="fa fa-check"></i><b>2.4.2</b> Enumerations and enumerable Sets</a></li>
<li class="chapter" data-level="2.4.3" data-path="prechap.html"><a href="prechap.html#cantors-zig-zag-method"><i class="fa fa-check"></i><b>2.4.3</b> Cantor’s Zig-Zag Method</a></li>
<li class="chapter" data-level="2.4.4" data-path="prechap.html"><a href="prechap.html#pairing-functions-and-codes"><i class="fa fa-check"></i><b>2.4.4</b> Pairing Functions and Codes</a></li>
<li class="chapter" data-level="2.4.5" data-path="prechap.html"><a href="prechap.html#an-alternative-pairing-function"><i class="fa fa-check"></i><b>2.4.5</b> An Alternative Pairing Function</a></li>
<li class="chapter" data-level="2.4.6" data-path="prechap.html"><a href="prechap.html#nonenumerable-sets"><i class="fa fa-check"></i><b>2.4.6</b> Nonenumerable Sets</a></li>
<li class="chapter" data-level="2.4.7" data-path="prechap.html"><a href="prechap.html#reduction"><i class="fa fa-check"></i><b>2.4.7</b> Reduction</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>I 卷 命题逻辑</b></span></li>
<li class="chapter" data-level="3" data-path="chap-truth-table.html"><a href="chap-truth-table.html"><i class="fa fa-check"></i><b>3</b> 联结词与真值表</a>
<ul>
<li class="chapter" data-level="3.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#联结词与复合句"><i class="fa fa-check"></i><b>3.1</b> 联结词与复合句</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#联结词"><i class="fa fa-check"></i><b>3.1.1</b> 联结词</a></li>
<li class="chapter" data-level="3.1.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#复合句和简单句"><i class="fa fa-check"></i><b>3.1.2</b> 复合句和简单句</a></li>
<li class="chapter" data-level="3.1.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#复合句的子句"><i class="fa fa-check"></i><b>3.1.3</b> 复合句的子句</a></li>
<li class="chapter" data-level="3.1.4" data-path="chap-truth-table.html"><a href="chap-truth-table.html#主联结词和直接子句"><i class="fa fa-check"></i><b>3.1.4</b> 主联结词和直接子句</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#真值非真值函数联结词"><i class="fa fa-check"></i><b>3.2</b> 真值、非真值函数联结词</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#真值函数联结词"><i class="fa fa-check"></i><b>3.2.1</b> 真值函数联结词</a></li>
<li class="chapter" data-level="3.2.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#非真值函数联结词"><i class="fa fa-check"></i><b>3.2.2</b> 非真值函数联结词</a></li>
<li class="chapter" data-level="3.2.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#常用的真值函数联结词符号"><i class="fa fa-check"></i><b>3.2.3</b> 常用的真值函数联结词符号</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#符号化"><i class="fa fa-check"></i><b>3.3</b> 符号化</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#联结词对应符号"><i class="fa fa-check"></i><b>3.3.1</b> 联结词对应符号</a></li>
<li class="chapter" data-level="3.3.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#符号化的基本操作过程"><i class="fa fa-check"></i><b>3.3.2</b> 符号化的基本操作过程</a></li>
<li class="chapter" data-level="3.3.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#几种特殊情况"><i class="fa fa-check"></i><b>3.3.3</b> 几种特殊情况</a></li>
<li class="chapter" data-level="3.3.4" data-path="chap-truth-table.html"><a href="chap-truth-table.html#论说的符号化"><i class="fa fa-check"></i><b>3.3.4</b> 论说的符号化</a></li>
<li class="chapter" data-level="3.3.5" data-path="chap-truth-table.html"><a href="chap-truth-table.html#形式"><i class="fa fa-check"></i><b>3.3.5</b> 形式</a></li>
<li class="chapter" data-level="3.3.6" data-path="chap-truth-table.html"><a href="chap-truth-table.html#形式化的波兰学派记法"><i class="fa fa-check"></i><b>3.3.6</b> 形式化的波兰学派记法</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="chap-truth-table.html"><a href="chap-truth-table.html#命题逻辑的基本语法"><i class="fa fa-check"></i><b>3.4</b> 命题逻辑的基本语法</a>
<ul>
<li class="chapter" data-level="3.4.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#形式语言-mathscrl_0"><i class="fa fa-check"></i><b>3.4.1</b> 形式语言 <span class="math inline">\(\mathscr{L_0}\)</span></a></li>
<li class="chapter" data-level="3.4.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#对象语言和元语言"><i class="fa fa-check"></i><b>3.4.2</b> 对象语言和元语言</a></li>
<li class="chapter" data-level="3.4.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#子公式和主联结词"><i class="fa fa-check"></i><b>3.4.3</b> 子公式和主联结词</a></li>
<li class="chapter" data-level="3.4.4" data-path="chap-truth-table.html"><a href="chap-truth-table.html#括号的省略"><i class="fa fa-check"></i><b>3.4.4</b> 括号的省略</a></li>
<li class="chapter" data-level="3.4.5" data-path="chap-truth-table.html"><a href="chap-truth-table.html#语法和语义"><i class="fa fa-check"></i><b>3.4.5</b> 语法和语义</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="chap-truth-table.html"><a href="chap-truth-table.html#基本真值表和真值的计算"><i class="fa fa-check"></i><b>3.5</b> 基本真值表和真值的计算</a>
<ul>
<li class="chapter" data-level="3.5.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#联结词的语义解释"><i class="fa fa-check"></i><b>3.5.1</b> 联结词的语义解释</a></li>
<li class="chapter" data-level="3.5.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#公式真值的计算"><i class="fa fa-check"></i><b>3.5.2</b> 公式真值的计算</a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="chap-truth-table.html"><a href="chap-truth-table.html#sec-semantics-ttable"><i class="fa fa-check"></i><b>3.6</b> 若干基本语义概念的真值表刻画</a>
<ul>
<li class="chapter" data-level="3.6.1" data-path="chap-truth-table.html"><a href="chap-truth-table.html#论说形式的有效性"><i class="fa fa-check"></i><b>3.6.1</b> 论说形式的有效性</a></li>
<li class="chapter" data-level="3.6.2" data-path="chap-truth-table.html"><a href="chap-truth-table.html#重言蕴涵"><i class="fa fa-check"></i><b>3.6.2</b> 重言蕴涵</a></li>
<li class="chapter" data-level="3.6.3" data-path="chap-truth-table.html"><a href="chap-truth-table.html#重言等值"><i class="fa fa-check"></i><b>3.6.3</b> 重言等值</a></li>
<li class="chapter" data-level="3.6.4" data-path="chap-truth-table.html"><a href="chap-truth-table.html#可满足性"><i class="fa fa-check"></i><b>3.6.4</b> 可满足性</a></li>
<li class="chapter" data-level="3.6.5" data-path="chap-truth-table.html"><a href="chap-truth-table.html#重言式矛盾式与或然式"><i class="fa fa-check"></i><b>3.6.5</b> 重言式、矛盾式与或然式</a></li>
<li class="chapter" data-level="3.6.6" data-path="chap-truth-table.html"><a href="chap-truth-table.html#简化真值表方法"><i class="fa fa-check"></i><b>3.6.6</b> 简化真值表方法</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="chap-truth-table.html"><a href="chap-truth-table.html#本章习题"><i class="fa fa-check"></i><b>3.7</b> 本章习题</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="plsematics.html"><a href="plsematics.html"><i class="fa fa-check"></i><b>4</b> 语义概念的严格刻画</a>
<ul>
<li class="chapter" data-level="4.1" data-path="plsematics.html"><a href="plsematics.html#真值指派和公式的真值"><i class="fa fa-check"></i><b>4.1</b> 真值指派和公式的真值</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="plsematics.html"><a href="plsematics.html#对象语言里的符号和公式"><i class="fa fa-check"></i><b>4.1.1</b> 对象语言里的符号和公式</a></li>
<li class="chapter" data-level="4.1.2" data-path="plsematics.html"><a href="plsematics.html#赋值真满足关系"><i class="fa fa-check"></i><b>4.1.2</b> 赋值、真、满足关系</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="plsematics.html"><a href="plsematics.html#重言蕴涵重言等值与可满足性"><i class="fa fa-check"></i><b>4.2</b> 重言蕴涵、重言等值与可满足性</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="plsematics.html"><a href="plsematics.html#重言蕴涵-1"><i class="fa fa-check"></i><b>4.2.1</b> 重言蕴涵</a></li>
<li class="chapter" data-level="4.2.2" data-path="plsematics.html"><a href="plsematics.html#重言等值-1"><i class="fa fa-check"></i><b>4.2.2</b> 重言等值</a></li>
<li class="chapter" data-level="4.2.3" data-path="plsematics.html"><a href="plsematics.html#可满足性-1"><i class="fa fa-check"></i><b>4.2.3</b> 可满足性</a></li>
<li class="chapter" data-level="4.2.4" data-path="plsematics.html"><a href="plsematics.html#重言式矛盾式与或然式-1"><i class="fa fa-check"></i><b>4.2.4</b> 重言式、矛盾式与或然式</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="plsematics.html"><a href="plsematics.html#代入"><i class="fa fa-check"></i><b>4.3</b> 代入</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="plsematics.html"><a href="plsematics.html#关于代入的直观说明"><i class="fa fa-check"></i><b>4.3.1</b> 关于代入的直观说明</a></li>
<li class="chapter" data-level="4.3.2" data-path="plsematics.html"><a href="plsematics.html#代入的定义"><i class="fa fa-check"></i><b>4.3.2</b> 代入的定义</a></li>
<li class="chapter" data-level="4.3.3" data-path="plsematics.html"><a href="plsematics.html#代入的复合"><i class="fa fa-check"></i><b>4.3.3</b> 代入的复合</a></li>
<li class="chapter" data-level="4.3.4" data-path="plsematics.html"><a href="plsematics.html#代入的语义性质"><i class="fa fa-check"></i><b>4.3.4</b> 代入的语义性质</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="plsematics.html"><a href="plsematics.html#真值指派与真值表"><i class="fa fa-check"></i><b>4.4</b> 真值指派与真值表</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="plsematics.html"><a href="plsematics.html#真值函数"><i class="fa fa-check"></i><b>4.4.1</b> 真值函数</a></li>
<li class="chapter" data-level="4.4.2" data-path="plsematics.html"><a href="plsematics.html#对部分命题变号的赋值"><i class="fa fa-check"></i><b>4.4.2</b> 对部分命题变号的赋值</a></li>
<li class="chapter" data-level="4.4.3" data-path="plsematics.html"><a href="plsematics.html#两种描述方式的等价性"><i class="fa fa-check"></i><b>4.4.3</b> 两种描述方式的等价性</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="plsematics.html"><a href="plsematics.html#范式"><i class="fa fa-check"></i><b>4.5</b> 范式</a>
<ul>
<li class="chapter" data-level="4.5.1" data-path="plsematics.html"><a href="plsematics.html#合取范式"><i class="fa fa-check"></i><b>4.5.1</b> 合取范式</a></li>
<li class="chapter" data-level="4.5.2" data-path="plsematics.html"><a href="plsematics.html#析取范式"><i class="fa fa-check"></i><b>4.5.2</b> 析取范式</a></li>
<li class="chapter" data-level="4.5.3" data-path="plsematics.html"><a href="plsematics.html#范式定理"><i class="fa fa-check"></i><b>4.5.3</b> 范式定理</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="plsematics.html"><a href="plsematics.html#函数完全性"><i class="fa fa-check"></i><b>4.6</b> 函数完全性</a>
<ul>
<li class="chapter" data-level="4.6.1" data-path="plsematics.html"><a href="plsematics.html#真值函数在形式语言中的表达"><i class="fa fa-check"></i><b>4.6.1</b> 真值函数在形式语言中的表达</a></li>
<li class="chapter" data-level="4.6.2" data-path="plsematics.html"><a href="plsematics.html#具有函数完全性的几组真值函数联结词"><i class="fa fa-check"></i><b>4.6.2</b> 具有函数完全性的几组真值函数联结词</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="plsematics.html"><a href="plsematics.html#本章习题-1"><i class="fa fa-check"></i><b>4.7</b> 本章习题</a></li>
</ul></li>
<li class="part"><span><b>II 卷 附錄</b></span></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://duoyu.ren" target="_blank">Published by Duōyú Rén</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Baby Logic</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="plsematics" class="section level1" number="4">
<h1><span class="header-section-number"> 4</span> 语义概念的严格刻画</h1>
<p><enq>… in mathematics a mere moral conviction, supported by a mass of
successful applications, is not good enough.<cite>Gottlob Frege, The
Foundations of Arithmetic, 1884. Trans. by J. I. Austin</cite></enq></p>
<p>在这一章里，我们对命题逻辑的基本概念给出严格的表述，并对这些概念做进一步的讨论和说明。</p>
<p><tt>离开了证明就没有当代逻辑</tt>。读者从这一章起开始学习写证明。无论读者原来对证明是否陌生，也无论读者是否认为证明全不足道，若要想真懂点逻辑而不只是侃点逻辑，那就不能绕过一个个定理及其证明。</p>
<div id="真值指派和公式的真值" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> 真值指派和公式的真值</h2>
<div id="对象语言里的符号和公式" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> 对象语言里的符号和公式</h3>
<p>逻辑学家们常喜欢不把对象语言明明白白地写下来，而只是用我们熟悉的语言来描述它们。在§2.3.0（P.79）中介绍
<span class="math inline">\(\mathscr{L}_0\)</span>-符号时，我们说 <span class="math inline">\(\mathscr{L}_0\)</span>-符号有命题变号
<span class="math inline">\(p_0, p_1,\cdots\)</span> 和联结词
<span class="math inline">\(\neg, \land, \lor, \rightarrow, \leftrightarrow\)</span>
等。这并不等于说，对象语言里的命题变号看上去都是某种字体的<z>英</z>文字母表中第
16
个字母的小写形式，而且还有自然数下标。对象语言的命题变号到底什么样不是我们关心的问题，而这个语言中是否有表达自然数的符号更不是我们关心的问题——我们只是用<bb>我们的</bb>语言符号来<tt>表示</tt>那些命题变号，只是在<bb>我们的</bb>语言中把它们排成这样一个序列。类似地，对象语言中的否定号、蕴涵号是什么样子之类的问题都不是我们关心的问题。我们只是用
<span class="math inline">\(\neg\)</span> 和 <span class="math inline">\(\rightarrow\)</span> 等分别<tt>表示</tt>它们。</p>
<p>虽然我们熟悉的语言都有文字符号，但毕竟不是所有的语言都一定要有文字符号。我们至少可以想像：在某个遥远的与世隔绝的地方，生活着一个非常原始的部落，这个部落的人们还没有发明文字语言，他们之间的交流只是通过口头语言、动作和表情等进行。如果我们要学习、谈论或研究他们的语言，那么我们就是把他们的语言当作对象语言，因而自然地不能强求对象语言必须有文字符号。明白了这一点，即使我们使用的所有符号都是元语言符号也没有什么难以理解的。</p>
<p>我们把 <span class="math inline">\(\mathscr{L}_0\)</span> 的所有命题变号的集合记作
<span class="math inline">\(\mathbf{Pr}\)</span>，并把命题变号依下标排出的序 <span class="math inline">\(p_0, p_1, p_2,\cdots\)</span> 称为
<span class="math inline">\(\mathbf{Pr}\)</span> 上的（或命题变号的）「字典顺序」或「字母表」。</p>
</div>
<div id="赋值真满足关系" class="section level3" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> 赋值、真、满足关系</h3>
<p>语言 <span class="math inline">\(\mathscr{L}_{0}\)</span> 的解释叫做「真值指派」（truth valuation, truth
assignment）。</p>
<p>（<span class="math inline">\(\mathbf{Pr}\)</span> 中 <span class="math inline">\(n\)</span> 个命题的真值指派组合类型共
<span class="math inline">\({\prod_{i=1}^{n}} (C_{2}^{1})_i = 2^{n}\)</span> 种。）</p>

<div class="definition">
<span id="def:defvassign" class="definition"><strong>定义 4.1  (赋值)  </strong></span><tt>一个</tt>赋值（或<bb>真值指派</bb>）是从 <span class="math inline">\(\mathbf{Pr}\)</span> 到 <span class="math inline">\(\lbrace 0, 1\rbrace\)</span> 的函数 <span class="math inline">\(\sigma\)</span>，它对<tt>每个</tt>命题变号 <span class="math inline">\(p\)</span> 指派一个真值 <span class="math inline">\(\sigma(p).\)</span>
</div>

<div class="definition">
<p><span id="def:deftruthassign" class="definition"><strong>定义 4.2  (真)  </strong></span>对所有的 <span class="math inline">\(\mathscr{L}_0\)</span>-公式 <span class="math inline">\(\varphi\)</span>，我们用 <span class="math inline">\(\varphi^\sigma\)</span> 表示 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(\sigma\)</span> 下的值。<span class="math inline">\(\varphi^\sigma\)</span> 递归地定义如下（我们用「iff」表示「当且仅当」）：</p>
<blockquote>
<span class="math display">\[
\begin{array}{rcl}
p_{n}^{\sigma}=1 &amp; \text{iff} &amp;  \sigma(p_{n})= 1 ~(n \geqslant 0)\\
(\neg \psi)^{\sigma}=1   &amp; \text{iff} &amp; \psi^{\sigma} \neq 1 ~(\text {即}~ \psi^{\sigma}=0 ) \\
(\psi \vee \chi)^{\sigma}=1  &amp; \text{iff}  &amp; \text {或者 }~  \psi^{\sigma}=1  \text { 或者 }~ \chi^{\sigma}=1 \\
(\psi \wedge \chi)^{\sigma}=1  &amp; \text{iff}   &amp; \psi^{\sigma}=1  \text{ 并且 }~  \chi^{\sigma}=1 \\
(\psi \rightarrow \chi)^{\sigma}=1  &amp; \text{iff} &amp; \text {或者 }~ \psi^{\sigma} \neq 1  \text{ 或者 }~  \chi^{\sigma}=1 \\
(\psi \leftrightarrow \chi)^{\sigma}=1  &amp; \text{iff} &amp; \psi^{\sigma}=\chi^{\sigma} 
\end{array}
\]</span>
</div>
</blockquote>
<p>确定公式真值的这类定义通常被称作「真之定义（真理定义）」（truth
definition）。对上述真理定义，我们有几点说明：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>关于 <span class="math inline">\(\varphi^\sigma\)</span> 的另一种等价的说法是把真值指派 <span class="math inline">\(\sigma\)</span>
<tt>扩充</tt>成一个满足上述条件的从 <span class="math inline">\(\mathscr{L}_0\)</span>-公式集到
<span class="math inline">\(\lbrace 0, 1\rbrace\)</span> 的函数。</li>
<li>因真值指派就像是被指派为真的命题变号集合的特征函数（<bb>注：</bb>对任意集合
<span class="math inline">\(X\)</span> 及其任意子集 <span class="math inline">\(Y\)</span>，从 <span class="math inline">\(X\)</span> 到 <span class="math inline">\(\lbrace 0, 1\rbrace\)</span> 的函数 <span class="math inline">\(f\)</span>
是 <span class="math inline">\(Y\)</span> 的<bb>特征函数</bb>当且仅当对每个 <span class="math inline">\(x \in X\)</span>，如果 <span class="math inline">\(x \in Y\)</span>
则 <span class="math inline">\(f(x) = 1\)</span>，并且如果 <span class="math inline">\(x \notin Y\)</span> 则 <span class="math inline">\(f(x) = 0.\)</span>
在这种情况下，真值指派就成了<bb>真命题变号集合的</bb>特征函数。），人们常常把真值指派
<span class="math inline">\(\sigma\)</span> 直接定义为 <span class="math inline">\(\mathbf{Pr}\)</span> 的一个子集，亦即
<span class="math inline">\(\sigma \subseteq \mathbf{Pr}\)</span> （或者
<span class="math inline">\(\sigma \in \mathscr{P}(\mathbf{Pr})\)</span>）（<bb>注：</bb>对任意集合
<span class="math inline">\(X\)</span>，<span class="math inline">\(\mathscr{P}(X)\)</span> 表示 <span class="math inline">\(X\)</span> 的<bb>幂集</bb>，即包含 <span class="math inline">\(X\)</span>
的所有子集的集合 <span class="math inline">\(\lbrace Y: Y \subseteq X\rbrace\)</span>。），而把
<span class="math inline">\(\varphi^\sigma\)</span>
递归定义的第一行也相应改为「<span class="math inline">\(p_{n}^{\sigma}=1~\text{iff}~p_{n} \in \sigma (n \geqslant 0)\)</span>」。</li>
<li>很多作者喜欢用「如果 <span class="math inline">\(\psi^{\sigma} = 1\)</span> 那么
<span class="math inline">\(\chi^{\sigma} = 1\)</span>」来替代上述递归定义第五行中的「或者
<span class="math inline">\(\psi^{\sigma} \neq 1\)</span> 或者 <span class="math inline">\(\chi^{\sigma} = 1\)</span>」。</li>
</ol>
</blockquote>
<p>对照基本真值表 2.1 和定义 3.1
中第二至第六行，易见两者在真值计算方面表达的内容是一样的。定义 3.1
确定了<tt>一个</tt>真值指派下各个公式的值，而下述「满足」定义说的是一个真值指派满足一个公式集当且仅当它使该集合中所有公式的值为
1.</p>

<div class="definition">
<span id="def:defsatis" class="definition"><strong>定义 4.3  (满足)  </strong></span>令 <span class="math inline">\(\Gamma\)</span> 为任意 <span class="math inline">\(\mathscr{L}_0\)</span>-公式集（可以是无穷集），并令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。 <span class="math inline">\(\sigma\)</span> <tt>满足</tt> <span class="math inline">\(~\Gamma\)</span>（符号表示：<span class="math inline">\(\sigma \vDash \Gamma\)</span>）当且仅当对每个 <span class="math inline">\(\varphi \in \Gamma\)</span>，<span class="math inline">\(\varphi^\sigma = 1.\)</span> 我们用 <span class="math inline">\(\sigma \vDash \varphi\)</span> 表示 <span class="math inline">\(\sigma \vDash \lbrace \varphi\rbrace\)</span>，并用 <span class="math inline">\(\sigma \nvDash \Gamma\)</span> 和 <span class="math inline">\(\sigma \nvDash \varphi\)</span> 分别表示 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 和 <span class="math inline">\(\sigma \vDash \varphi\)</span> 不成立。
</div>
<p>由上述定义可知下列等值式成立：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\sigma \vDash \varphi\)</span> 当且仅当 <span class="math inline">\(\varphi^\sigma = 1;\)</span>
（「<span class="math inline">\(\vDash\)</span>」读作 “double-turnstile.”）</li>
<li><span class="math inline">\(\sigma \nvDash \varphi\)</span> 当且仅当 <span class="math inline">\(\varphi^\sigma = 0;\)</span></li>
<li><span class="math inline">\(\sigma \vDash \Gamma\)</span> 当且仅当对所有
<span class="math inline">\(\varphi \in \Gamma, \sigma \vDash \varphi;\)</span></li>
<li><span class="math inline">\(\sigma \nvDash \Gamma\)</span> 当且仅当对某些
<span class="math inline">\(\varphi \in \Gamma, \sigma \nvDash \varphi.\)</span></li>
</ol>
</blockquote>
<p>当 <span class="math inline">\(\Gamma = \varnothing\)</span>（空集）时，<span class="math inline">\(\Gamma\)</span>
是否被一真值指派满足是一种「极限」情况。事实上，对每个真值指派 <span class="math inline">\(\sigma\)</span>
都有 <span class="math inline">\(\sigma \vDash \varnothing.\)</span> 这是因为，既然 <span class="math inline">\(\varnothing\)</span>
是空集，那么就不存在 <span class="math inline">\(\varnothing\)</span> 中的公式 <span class="math inline">\(\varphi\)</span> 使得
<span class="math inline">\(\sigma \nvDash \varphi,\)</span> 也就是说对每一个
<span class="math inline">\(\varphi \in \Gamma, \sigma \vDash \varphi.\)</span></p>
<p><a href="chap-truth-table.html#sec-semantics-ttable">3.6</a>
中引入的一些基本语义概念，都是用真值表刻画的。真值表刻画在某种程度上依赖于读者对图形的直观。下面我们不借助这种直观，仅仅运用真值指派和满足关系这些概念，对
<a href="chap-truth-table.html#sec-semantics-ttable">3.6</a> 中引入的基本语义概念进行严格的定义。</p>
</div>
</div>
<div id="重言蕴涵重言等值与可满足性" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> 重言蕴涵、重言等值与可满足性</h2>
<p>「逻辑蕴涵」是逻辑学的核心观念之一，我们将在后续章节中讨论它，这里先讨论它在命题逻辑中的简单形式——「重言蕴涵」。在不产生歧义时，我们将省略前缀
「<span class="math inline">\(\mathscr{L}_0\)</span>-」。</p>
<div id="重言蕴涵-1" class="section level3" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> 重言蕴涵</h3>
<p>在 <a href="chap-truth-table.html#sec-semantics-ttable">3.6</a>
中，<span class="math inline">\(\lbrace \varphi_0,\cdots,\varphi_n \rbrace\)</span>
<bb>重言蕴涵</bb>（tautologically implies） <span class="math inline">\(\psi\)</span> 当且仅当在
<span class="math inline">\(\varphi_0,\cdots,\varphi_n\)</span> 与 <span class="math inline">\(\psi\)</span> 的联合真值表中，没有一行是
<span class="math inline">\(\varphi_0,\cdots,\varphi_n\)</span> <tt>都真</tt>而 <span class="math inline">\(\psi\)</span>
假。这是其联合真值表角度的定义。下面我们从赋值与满足出发，重新严格刻画重言蕴涵。</p>

<div class="definition">
<span id="def:defvassigntaut" class="definition"><strong>定义 4.4  (重言蕴涵)  </strong></span>令 <span class="math inline">\(\Gamma\)</span> 为任意公式集（可以是无穷的），并且 <span class="math inline">\(\varphi\)</span> 为任意公式。 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span>（ <span class="math inline">\(\Gamma\)</span> 重言蕴涵 <span class="math inline">\(\varphi\)</span>）当且仅当<bb>对每一个</bb>真值指派 <span class="math inline">\(\sigma\)</span>，如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 则 <span class="math inline">\(\sigma \vDash \varphi.\)</span> <span class="math inline">\(\varphi\)</span> 是 <span class="math inline">\(\Gamma\)</span> 的<bb>重言后承</bb>当且仅当 <span class="math inline">\(\Gamma \vDash_{0} \varphi.\)</span> （皆指 <span class="math inline">\(\mathscr{L}_{0}\)</span> 中）
</div>
<p>当 <span class="math inline">\(\Delta=\lbrace \varphi_0,\cdots,\varphi_n\rbrace\)</span> 时，用
<span class="math inline">\(\varphi_0,\cdots,\varphi_n \vDash_{0} \varphi\)</span> 表示
<span class="math inline">\(\Delta \vDash_{0} \varphi\)</span>，用
<span class="math inline">\(\Gamma, \varphi_0,\cdots,\varphi_n \vDash_{0} \varphi\)</span> 表示
<span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \varphi\)</span>。当 <span class="math inline">\(\Delta=\varnothing\)</span>
时，我们用 <span class="math inline">\(\vDash_{0} \varphi\)</span> 表 示 <span class="math inline">\(\Delta \vDash_{0} \varphi.\)</span></p>

<div class="remark">
<p> <span class="remark"><em>Remark: </em></span> 定义 <a href="plsematics.html#def:defvassigntaut">4.4</a> 和 <a href="chap-truth-table.html#sec-semantics-ttable">3.6</a> 中重言蕴涵的真值表刻画有所不同。不同之处有以下两点：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\Gamma\)</span> 在这里可以是无穷集合，而在重言蕴涵等概念的真值表刻画中，<span class="math inline">\(\Gamma\)</span> 被限定为有穷集合。</li>
<li>真值指派要对所有命题变号给出真值，并且在定义重言蕴涵等语义概念时，定义涉及的真值指派显然有无穷多个；而用真值表刻画这些基本语义概念时，只需考虑给定公式中出现的有穷多个命题变号的真假，而且这些命题变号的可能取值组合也只有有穷多个。
</div></li>
</ol>
<p>从现在起，读者要学习证明。我们先证明一些简单的命题，且给出的证明也尽量详细。读者应对照定义来阅读以下的例子、命题及其证明，同时不要忽略本章后面的证明练习。</p>

<div class="example">
<span id="exm:exmvassigntaut01" class="example"><strong>例 4.1  </strong></span>对所有公式 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi \vee \psi, \neg \varphi \vDash_{0} \psi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。假设 <span class="math inline">\(\sigma \vDash \varphi \lor \psi\)</span> 且 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span>（以下证明 <span class="math inline">\(\sigma \vDash \psi\)</span>）根据真之定义，由假设 <span class="math inline">\(\sigma \vDash \varphi \lor \psi\)</span> 得知或者 $$或者 <span class="math inline">\(\sigma \vDash \psi\)</span>，再由假设 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span> 得知 <span class="math inline">\(\sigma \nvDash \varphi\)</span>，从而有 <span class="math inline">\(\sigma \vDash \psi\)</span> 所以，对每个真值指派 <span class="math inline">\(\sigma\)</span>，如果 <span class="math inline">\(\sigma \vDash \varphi \lor \psi\)</span> 且 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span>，那么 <span class="math inline">\(\sigma \vDash \psi.\)</span> 根据重言蕴涵的<tt>定义</tt>，<span class="math inline">\(\varphi \vee \psi, \neg \varphi \vDash_{0} \psi.\)</span>
</div>

<div class="example">
<span id="exm:exmvassigntaut02" class="example"><strong>例 4.2  </strong></span>对所有公式 <span class="math inline">\(\varphi, \psi\)</span> 和 <span class="math inline">\(\chi\)</span>，<span class="math inline">\(\varphi \rightarrow \psi, \psi \rightarrow \chi \vDash_{0} \varphi \rightarrow \chi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。假设（i）<span class="math inline">\(\sigma \vDash \varphi \rightarrow \psi\)</span> 且（ii）<span class="math inline">\(\sigma \vDash \psi \rightarrow \chi\)</span>（以下证明 <span class="math inline">\(\varphi \rightarrow \chi\)</span>）如果 <span class="math inline">\(\sigma \nvDash \varphi\)</span>，则 <span class="math inline">\(\varphi^\sigma \ne 1\)</span>，那么根据真理定义，<span class="math inline">\(\sigma \vDash \varphi \rightarrow \chi.\)</span> 所以，假设（ii）<span class="math inline">\(\sigma \vDash \varphi.\)</span> 根据真理定义和（iii），由（i）得到 <span class="math inline">\(\sigma \vDash \psi\)</span>，再由（ii）得到 <span class="math inline">\(\sigma \vDash \chi\)</span>，从而有 <span class="math inline">\(\sigma \vDash \varphi \rightarrow \chi.\)</span>由此可知，对每个 <span class="math inline">\(\sigma\)</span>，如果 <span class="math inline">\(\sigma \vDash \varphi \rightarrow \psi\)</span> 且 <span class="math inline">\(\sigma \vDash \psi \rightarrow \chi\)</span>，那么 <span class="math inline">\(\sigma \vDash \varphi \rightarrow \chi.\)</span> 根据重言蕴涵的<tt>定义</tt>，<span class="math inline">\(\varphi \rightarrow \psi, \psi \rightarrow \chi \vDash_{0} \varphi \rightarrow \chi.\)</span>
</div>

<div class="proposition">
<span id="prp:prpvassigntaut01" class="proposition"><strong>命题 4.1  </strong></span>对所有公式集 <span class="math inline">\(\Gamma\)</span> 和所有公式 <span class="math inline">\(\varphi\)</span>，如果 <span class="math inline">\(\varphi \in \Gamma\)</span> 则 <span class="math inline">\(\Gamma \vDash_{0} \varphi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 对每个真值指派 <span class="math inline">\(\sigma\)</span>，如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span>，那么根据定义 3.2，<span class="math inline">\(\sigma\)</span> 满足 <span class="math inline">\(\Gamma\)</span> 中所有公式，由 <span class="math inline">\(\varphi \in \Gamma\)</span> 得到 <span class="math inline">\(\sigma \vDash \varphi.\)</span> 所以，根据重言蕴涵的<tt>定义</tt>，<span class="math inline">\(\Gamma \vDash_{0} \varphi.\)</span>
</div>

<div class="proposition">
<span id="prp:prpvassigntaut02" class="proposition"><strong>命题 4.2  </strong></span>对所有公式集 <span class="math inline">\(\Gamma\)</span> 和所有公式 <span class="math inline">\(\varphi, \psi\)</span>，<span class="math inline">\(\Gamma, \varphi \vDash_{0} \psi\)</span> 当且仅当 <span class="math inline">\(\Gamma \vDash_{0} \varphi \rightarrow \psi.\)</span>
</div>

<div class="proof">
<p> <span class="proof"><em>Proof: </em></span> </p>
<ol style="list-style-type: decimal">
<li>假设 <span class="math inline">\(\Gamma \nvDash_{0} \varphi \rightarrow \psi.\)</span> 根据重言蕴涵的定义，存在真值指派 <span class="math inline">\(\sigma\)</span> 使得 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 并且 <span class="math inline">\(\sigma \nvDash \varphi \rightarrow \psi\)</span>，亦即 <span class="math inline">\(\sigma \vDash \varphi\)</span> 且 <span class="math inline">\(\sigma \nvDash \psi\)</span>，从而得到 <span class="math inline">\(\sigma \vDash \Gamma \cup \lbrace \varphi\rbrace\)</span> 且 <span class="math inline">\(\sigma \nvDash_{0} \psi.\)</span> 再根据重言蕴涵的定义得知 <span class="math inline">\(\Gamma, \varphi \nvDash_{0} \psi.\)</span></li>
<li>假设 <span class="math inline">\(\Gamma \vDash_{0} \varphi \rightarrow \psi.\)</span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。如果 <span class="math inline">\(\sigma \vDash \Gamma \cup\lbrace \varphi\rbrace\)</span>，则 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 且 <span class="math inline">\(\sigma \vDash \varphi\)</span>，于是由假设和重言蕴涵的定义得知 <span class="math inline">\(\sigma \vDash \varphi \rightarrow \psi\)</span> 且 <span class="math inline">\(\sigma \vDash \varphi\)</span>，进而再由真理定义得到 <span class="math inline">\(\sigma \vDash \psi.\)</span> 所以，根据重言蕴涵的定义，<span class="math inline">\(\Gamma, \varphi \vDash_{0} \psi.\)</span>（「当且仅当」证法之例）
</div></li>
</ol>

<div class="proposition">
<span id="prp:prpvassigntaut03" class="proposition"><strong>命题 4.3  </strong></span>对所有公式集 <span class="math inline">\(\Gamma, \varphi_0,\cdots,\varphi_n \vDash_{0} \psi\)</span> 并且对所有 <span class="math inline">\(i \leqslant n\)</span>，<span class="math inline">\(\Delta \vDash_{0} \varphi_i.\)</span> 我们有 <span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \psi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派，并设 <span class="math inline">\(\sigma \vDash \Gamma \cup \Delta.\)</span> 根据满足的定义，对所有的 <span class="math inline">\(\varphi \in \Gamma \cup \Delta\)</span> 都有 <span class="math inline">\(\sigma \vDash \varphi\)</span>，因而对所有的 <span class="math inline">\(\varphi \in \Gamma\)</span> 都有 <span class="math inline">\(\sigma \vDash \varphi\)</span>，并且对所有的 <span class="math inline">\(\varphi \in \Delta\)</span> 都有 <span class="math inline">\(\sigma \vDash \varphi.\)</span> 所以（i）<span class="math inline">\(\sigma \vDash \Gamma\)</span>，（ii）<span class="math inline">\(\sigma \vDash \Delta.\)</span> 令 <span class="math inline">\(i \leqslant n.\)</span> 根据题设，<span class="math inline">\(\Delta \vDash_{0} \varphi_i;\)</span> 再根据（ii）和重言蕴涵的定义， <span class="math inline">\(\sigma \vDash \varphi_i.\)</span> 因为这对 <span class="math inline">\(i = 0,\cdots,n\)</span> 都成立，所以由（i）和满足定义得到 <span class="math inline">\(\sigma \vDash \Gamma \cup \lbrace \varphi_0,\cdots,\varphi_n\rbrace\)</span>，再运用题设和重言蕴涵的定义，我们得到 <span class="math inline">\(\sigma \vDash \psi.\)</span> 所以，由重言蕴涵的定义得知 <span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \psi.\)</span>
</div>
</div>
<div id="重言等值-1" class="section level3" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> 重言等值</h3>
<p>在 §2.5.2（P.87）中，任意公式 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
<bb>重言等值</bb>（tautologically equivalent） 当且仅当在 <span class="math inline">\(\varphi\)</span> 与
<span class="math inline">\(\psi\)</span> 联合真值表的<tt>任意一行</tt>中，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
有同样的真值。其赋值视角的定义如下：</p>

<div class="definition">
<span id="def:defvassignequiv" class="definition"><strong>定义 4.5  (重言等值)  </strong></span><span class="math inline">\(\mathscr{L}_{0}\)</span>-公式
<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值当且仅当对每个真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\varphi^\sigma = \psi^\sigma.\)</span>
</div>
<p>易见：如果 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值，那么对每个真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\sigma \vDash \varphi\)</span> 当且仅当 <span class="math inline">\(\sigma \vDash \psi;\)</span>
反之亦然。</p>

<div class="example">
<span id="exm:exmvassignequiv01" class="example"><strong>例 4.3  </strong></span>对任意公式 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi \rightarrow \psi\)</span> 与 <span class="math inline">\(\neg\varphi \lor \psi\)</span> 重言等值。
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。根据真理定义，<span class="math inline">\(\sigma \vDash \varphi \rightarrow \psi\)</span> 当且仅当 <span class="math inline">\(\sigma \nvDash \varphi\)</span> 或者 <span class="math inline">\(\sigma \vDash \psi\)</span>，当且仅当 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span> 或者 <span class="math inline">\(\sigma \vDash \psi\)</span>，当且仅当 <span class="math inline">\(\sigma \vDash \neg \varphi \lor \sigma \psi\)</span>。根据重言等值定义，<span class="math inline">\(\varphi \rightarrow \psi\)</span> 与<span class="math inline">\(\neg\varphi \lor \psi\)</span> 重言等值。
</div>

<div class="example">
<span id="exm:exmvassignequiv02" class="example"><strong>例 4.4  </strong></span>对任意公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 与
<span class="math inline">\((\varphi \land \psi) \lor (\neg\varphi \land \neg\psi)\)</span> 重言等值。
</div>

<div class="proof">
<p> <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span>
为任意真值指派。根据真理定义，<span class="math inline">\(\sigma \vDash \varphi \leftrightarrow \psi\)</span>
当且仅当：或者 <span class="math inline">\(\varphi^\sigma = \psi^\sigma = 1\)</span>，或者
<span class="math inline">\(\varphi^\sigma = \psi^\sigma = 0;\)</span> 当且仅当 <span class="math inline">\(\sigma \vDash \varphi\)</span> 且
<span class="math inline">\(\sigma \vDash \psi\)</span>，或者 <span class="math inline">\(\sigma \nvDash \varphi\)</span> 且
<span class="math inline">\(\sigma \nvDash \psi.\)</span> 于是由真理定义得到</p>
<p><span class="math display">\[
\begin{array}{rcl}
    \sigma \vDash \varphi \leftrightarrow \psi  &amp; \text{iff} &amp;  \text{或者}~ \sigma \vDash \varphi \land \psi ~\text{或者}~ \sigma \vDash \neg\varphi \land \neg\psi \\
    &amp; \text{iff} &amp;  \sigma \vDash (\varphi \land \psi) \lor (\neg\varphi \land \neg\psi)
\end{array}
\]</span></p>
所以由重言等值的定义，<span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 与
<span class="math inline">\((\varphi \land \psi) \lor (\neg\varphi \land \neg\psi)\)</span> 重言等值。
</div>

<div class="example">
<span id="exm:exmvassignequiv03" class="example"><strong>例 4.5  </strong></span>对所有公式集 <span class="math inline">\(\Gamma\)</span> 以及所有公式
<span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>，如果 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span> 并且 <span class="math inline">\(\varphi\)</span> 与
<span class="math inline">\(\psi\)</span> 重言等值，那么 <span class="math inline">\(\Gamma \vDash_{0} \psi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 设 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span> 并且 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值。令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span>，那么由 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span> 和重言蕴涵的定义得知 <span class="math inline">\(\sigma \vDash \varphi\)</span>，再由重言等值的定义得到 <span class="math inline">\(\sigma \vDash \psi.\)</span> 所以，再根据重言蕴涵定义，<span class="math inline">\(\Gamma \vDash_{0} \psi.\)</span>
</div>

<div class="proposition">
<span id="prp:prpvassignequiv01" class="proposition"><strong>命题 4.4  </strong></span>对所有所有公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值当且仅当 <span class="math inline">\(\varphi \vDash_{0} \psi\)</span>
并且 <span class="math inline">\(\psi \vDash_{0} \varphi.\)</span>
</div>

<div class="proof">
<p> <span class="proof"><em>Proof: </em></span> 设 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
重言等值。对每一个真值指派 <span class="math inline">\(\sigma\)</span>，如果
<span class="math inline">\(\sigma \vDash \varphi\)</span>，那么由于 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值，可知
<span class="math inline">\(\sigma \vDash \psi.\)</span> 这就是说，<span class="math inline">\(\varphi \vDash_{0} \psi.\)</span> 同理可证
<span class="math inline">\(\psi \vDash_{0} \varphi.\)</span></p>
<p>设 <span class="math inline">\(\varphi \vDash_{0} \psi\)</span> 且 <span class="math inline">\(\psi \vDash_{0} \varphi.\)</span>
根据此假设和重言蕴涵的定义，</p>
<ol style="list-style-type: decimal">
<li><p>对每个真值指派 <span class="math inline">\(\sigma_1\)</span>，如果 <span class="math inline">\(\sigma_1 \vDash \varphi\)</span> 则
<span class="math inline">\(\sigma_1 \vDash \psi.\)</span></p></li>
<li><p>对每个真值指派 <span class="math inline">\(\sigma_2\)</span>，如果 <span class="math inline">\(\sigma_2 \vDash \psi\)</span> 则
<span class="math inline">\(\sigma_2 \vDash \varphi.\)</span></p></li>
</ol>
令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。由（i）知：如果如果 <span class="math inline">\(\sigma \vDash \varphi\)</span>
则 <span class="math inline">\(\sigma \vDash \psi;\)</span> 由（ii）知：如果 <span class="math inline">\(\sigma \vDash \psi\)</span> 则
<span class="math inline">\(\sigma \vDash \varphi.\)</span> 从而 <span class="math inline">\(\sigma \vDash \varphi\)</span> 当且仅当
<span class="math inline">\(\sigma \vDash \psi.\)</span> 根据重言等值的定义，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
重言等值。
</div>
</div>
<div id="可满足性-1" class="section level3" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> 可满足性</h3>
<p>在 §2.5.3（P.88）中，从联合真值表角度看，任意有穷公式集 <span class="math inline">\(\Gamma\)</span>
<bb>可满足</bb>（satisfiable）当且仅当 <span class="math inline">\(\Gamma\)</span>
中公式的联合真值表中<tt>存在某一行</tt>，在该行里 <span class="math inline">\(\Gamma\)</span>
中的公式的真值都是 1. 下面我们从赋值与满足出发，重新严格刻画重言蕴涵。</p>

<div class="definition">
<span id="def:defvassignsatis" class="definition"><strong>定义 4.6  (可满足)  </strong></span>令 <span class="math inline">\(\Gamma\)</span>
为任意公式集（可以是无穷集），<span class="math inline">\(\varphi\)</span> 为任意
<span class="math inline">\(\mathscr{L}_{0}\)</span>-公式。<span class="math inline">\(\Gamma\)</span>
是可满足的当且仅当<tt>存在一个</tt>真值指派 <span class="math inline">\(\sigma\)</span> 使得
<span class="math inline">\(\sigma \vDash \Gamma;\)</span> <span class="math inline">\(\varphi\)</span> 是可满足的当且仅当
<span class="math inline">\(\lbrace \varphi\rbrace\)</span> 是可满足的。<span class="math inline">\(\Gamma\)</span>（或
<span class="math inline">\(\varphi\)</span>）是不可满足的当且仅当它不是可满足的。
</div>

<div class="remark">
<p> <span class="remark"><em>Remark: </em></span> 定义 <a href="plsematics.html#def:defvassigntaut">4.4</a> 和 <a href="chap-truth-table.html#sec-semantics-ttable">3.6</a> 中重言蕴涵的真值表刻画有所不同。不同之处有以下两点：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\Gamma\)</span> 在这里可以是无穷集合，而在重言蕴涵等概念的真值表刻画中，<span class="math inline">\(\Gamma\)</span> 被限定为有穷集合。</li>
<li>真值指派要对所有命题变号给出真值，并且在定义重言蕴涵等语义概念时，定义涉及的真值指派显然有无穷多个；而用真值表刻画这些基本语义概念时，只需考虑给定公式中出现的有穷多个命题变号的真假，而且这些命题变号的可能取值组合也只有有穷多个。
</div></li>
</ol>

<div class="example">
<span id="exm:exmvassignsatis01" class="example"><strong>例 4.6  </strong></span>设
<span class="math inline">\(\Gamma=\left\lbrace p \vee q, r \wedge s, p \rightarrow r \wedge r^{\prime}, s^{\prime} \leftrightarrow(\neg q \rightarrow \neg s)\right\rbrace.\)</span>
我们有： <span class="math inline">\(\Gamma\)</span> 可满足。
</div>

<div class="proof">
<p> <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为如下定义的真值指派：</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(\sigma(p)=\sigma(r)=\sigma(s)=\sigma(r^{\prime})=1\)</span></p></li>
<li><p><span class="math inline">\(\sigma(q)=\sigma(s^{\prime})=0\)</span></p></li>
<li><p>对所有与 <span class="math inline">\(p, q, r, s, r^{\prime}\)</span>， <span class="math inline">\(s^{\prime}\)</span> 不同的命题变号
<span class="math inline">\(p^{\prime}\)</span>， <span class="math inline">\(\sigma(p^{\prime})=0.\)</span></p></li>
</ol>
<p>由真理定义和（i）知，<span class="math inline">\(\sigma \vDash p \vee q\)</span> 且
<span class="math inline">\(\sigma \vDash r \wedge s.\)</span> 类似地， <span class="math inline">\(\sigma \vDash r \wedge r^{\prime}\)</span>
进而 <span class="math inline">\(\sigma \vDash p \rightarrow r \wedge r^{\prime}.\)</span>
由真理定义和（i）知 <span class="math inline">\(\sigma \not=\neg s\)</span>， 并由（ii）知
<span class="math inline">\(\sigma \vDash \neg q\)</span>，进而 <span class="math inline">\(\sigma \nvDash \neg q \rightarrow \neg s;\)</span>
再由（ii）知 <span class="math inline">\(\sigma \nvDash s^{\prime}.\)</span> 所以 $
s^{} (q s).$</p>
综上所述， <span class="math inline">\(\sigma \vDash \Gamma.\)</span>
</div>

<div class="example">
<span id="exm:exmvassignsatis02" class="example"><strong>例 4.7  </strong></span>设 <span class="math inline">\(q_{0}, q_{1},\cdots\)</span> 为任意命题变号，满足对所有
<span class="math inline">\(i, j \geqslant 0\)</span>，如果 <span class="math inline">\(i \neq j\)</span> 则 <span class="math inline">\(q_{i} \neq q_{j};\)</span> 并设
<span class="math inline">\(\Gamma=\left\lbrace q_{2k} \rightarrow \neg q_{2k+1}: k \geqslant 0\right\rbrace\)</span>
且
<span class="math inline">\(\Delta=\left\lbrace \neg q_{2k+1} \rightarrow q_{2k+2}: k \geqslant 0\right\rbrace\)</span>。我们有：<span class="math inline">\(\left\lbrace q_{0}\right\rbrace \cup \Gamma \cup \Delta\)</span>
可满足。
</div>

<div class="proof">
<p> <span class="proof"><em>Proof: </em></span> 令 <span class="math inline">\(\sigma\)</span> 为下列真值指派：对每个命题变号 <span class="math inline">\(p\)</span>，</p>
<p><span class="math display">\[
    \sigma(p)=
    \left\lbrace 
    \begin{array}{ll}
    1 &amp; \text{如果存在}~ k \geqslant 0 ~\text{使得}~ p=q_{2 k} \\
    0 &amp; \text{否则}
    \end{array}
    \right.
    \]</span></p>
显然，<span class="math inline">\(\sigma \vDash q_{0}.\)</span> 对任意 <span class="math inline">\(k \geqslant 0\)</span>，由上述定义知
<span class="math inline">\(\sigma \nvDash q_{2k+1}\)</span> 且
<span class="math inline">\(\sigma \vDash q_{2k+2}\)</span>，从而根据真理定义，<span class="math inline">\(\sigma \vDash \neg q_{2k+1}\)</span>
进而 <span class="math inline">\(\sigma \vDash q_{2k} \rightarrow \neg q_{2k+1}\)</span> 且
<span class="math inline">\(\sigma \vDash \neg q_{2k+1} \rightarrow q_{2k+2}.\)</span>
所以，<span class="math inline">\(\sigma \vDash\left\lbrace q_{0}\right\rbrace \cup \Gamma \cup \Delta.\)</span>
</div>

<div class="proposition">
<span id="prp:prpvassignsatis01" class="proposition"><strong>命题 4.5  </strong></span>对所有公式集 <span class="math inline">\(\Gamma\)</span>，如果 <span class="math inline">\(\Gamma\)</span>
不可满足，那么对每个公式 <span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\Gamma \vDash_{0} \varphi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 假设 <span class="math inline">\(\Gamma\)</span> 不可满足且令 <span class="math inline">\(\varphi\)</span> 为任意公式。假如 <span class="math inline">\(\Gamma \nvDash_{0} \varphi\)</span>，那么就存在真值指派 <span class="math inline">\(\sigma\)</span> 使得 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 且 <span class="math inline">\(\sigma \nvDash \varphi\)</span>，但这是不可能的，因为 <span class="math inline">\(\Gamma\)</span> 不可满足。
</div>

<div class="proposition">
<span id="prp:prpvassignsatis02" class="proposition"><strong>命题 4.6  </strong></span>对所有公式集 <span class="math inline">\(\Gamma\)</span> 和所有公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\Gamma \cup \lbrace \varphi\rbrace\)</span> 不可满足当且仅当
<span class="math inline">\(\Gamma \vDash_{0} \neg \varphi\)</span>，并且
<span class="math inline">\(\Gamma \cup \lbrace \neg \varphi\rbrace\)</span> 不可满足当且仅当
<span class="math inline">\(\Gamma \vDash_{0} \varphi.\)</span>
</div>

<div class="proof">
 <span class="proof"><em>Proof: </em></span> 只证第一部分。设 <span class="math inline">\(\Gamma \cup \lbrace \varphi\rbrace\)</span> 不可满足并令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。因为 <span class="math inline">\(\sigma \nvDash \Gamma \cup \lbrace \varphi\rbrace\)</span> ，所以，如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 则 <span class="math inline">\(\sigma \nvDash \varphi\)</span>，由真理定义得知，如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 则 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span>，进而由重言蕴涵定义得知 <span class="math inline">\(\Gamma \vDash_{0} \neg \varphi.\)</span> 设 <span class="math inline">\(\Gamma \vDash_{0} \neg \varphi\)</span>，令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。易见，如果 <span class="math inline">\(\sigma \vDash \Gamma\)</span>，则由重言蕴涵的定义知 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span>，从而 <span class="math inline">\(\sigma \nvDash \varphi\)</span>，这就是说，<span class="math inline">\(\sigma \nvDash \Gamma \cup \lbrace \varphi\rbrace.\)</span> 即 <span class="math inline">\(\Gamma \cup \lbrace \varphi\rbrace\)</span> 不可满足。
</div>
</div>
<div id="重言式矛盾式与或然式-1" class="section level3" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> 重言式、矛盾式与或然式</h3>
<p>在§2.5.4（P.88）中，重言式、矛盾式与或然式曾被以真值表的方式刻画，下面从赋值角度严格刻画这组概念。</p>
<p>{{% dtpc title=“☯定义 3.6【重言式】” %}} 对任意 <span class="math inline">\(\mathscr{L}_{0}\)</span>-公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi\)</span> 是重言式当且仅当对每一个真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\sigma \vDash \varphi.\)</span> {{% /dtpc %}}</p>
<p>{{% dtpc title=“☯定义 3.7【矛盾式】” %}} 对任意 <span class="math inline">\(\mathscr{L}_{0}\)</span>-公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi\)</span> 矛盾式（或不可满足式）当且仅当对每一个真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\sigma \nvDash \varphi.\)</span> {{% /dtpc %}}</p>
<p>{{% dtpc title=“☯定义 3.8【或然式】” %}} 对任意 <span class="math inline">\(\mathscr{L}_{0}\)</span>-公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi\)</span> 或然式当且仅当对每一个真值指派 <span class="math inline">\(\sigma\)</span> 使得
<span class="math inline">\(\sigma \vDash \varphi\)</span>，<span class="math inline">\(\sigma \nvDash \varphi\)</span>，并且存在一个真值指派
<span class="math inline">\(\sigma^\prime\)</span>，使得 <span class="math inline">\(\sigma^\prime \nvDash \varphi.\)</span> {{% /dtpc %}}</p>
<blockquote>
<p><bb>Note 3.2</bb> 与重言蕴涵、重言等值和可满足性等概念的情况类似，定义
3.6-3.8
有别于§2.5.4（P.88）中对重言式等概念的真值表刻画：真值指派要对所有命题变号给出真值，并且重言式等的定义涉及的真值指派显然有无穷多个；这些概念的真值表刻画却不同，它们只考虑公式中出现的有穷多个命题变号的真假，而这些命题变号的可能取值组合也只有有穷多个。</p>
</blockquote>
<p><bb>例 3.6</bb> 对任意公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi \lor \varphi \rightarrow \varphi\)</span> 是重言式。
<bb>证明：</bb>令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。如果
<span class="math inline">\(\sigma \vDash \varphi \lor \varphi\)</span>，那么根据真理定义，<span class="math inline">\(\sigma \vDash \varphi\)</span>，进而
<span class="math inline">\(\sigma \vDash \varphi \lor \varphi \rightarrow \varphi.\)</span>
由重言式的定义知，<span class="math inline">\(\varphi \lor \varphi \rightarrow \varphi\)</span> 是重言式。▗</p>
<p><bb>例 3.7</bb> 对任意公式
<span class="math inline">\(\varphi, \psi\)</span>，<span class="math inline">\(\neg(\varphi \rightarrow \psi) \rightarrow \varphi \land \neg \psi\)</span>
是重言式。 <bb>证明：</bb>令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。假设
<span class="math inline">\(\sigma \vDash \neg(\varphi \rightarrow \psi).\)</span>
根据真理定义，<span class="math inline">\(\sigma \nvDash \varphi \rightarrow \psi\)</span>，从而有
<span class="math inline">\(\sigma \vDash \varphi\)</span> 且 <span class="math inline">\(\sigma \nvDash \psi.\)</span>
于是，<span class="math inline">\(\sigma \vDash \varphi\)</span> 且 <span class="math inline">\(\sigma \vDash \neg\psi\)</span>，进而
<span class="math inline">\(\sigma \vDash \varphi \land \neg \psi.\)</span> 由此得知，对任意真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\sigma \vDash \neg(\varphi \rightarrow \psi) \rightarrow \varphi \land \neg \psi.\)</span>
根据重言式的定义，<span class="math inline">\(\neg(\varphi \rightarrow \psi) \rightarrow \varphi \land \neg \psi\)</span>
是重言式。▗</p>
<p><bb>例 3.8</bb> 对任意公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi \land \neg (\varphi \lor \psi)\)</span> 是矛盾式。
<bb>证明：</bb>令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。根据真理定义，如果
<span class="math inline">\(\sigma \vDash \varphi \land \neg (\varphi \lor \psi)\)</span>，那么
<span class="math inline">\(\sigma \vDash \varphi\)</span> 且
<span class="math inline">\(\sigma \vDash \neg (\varphi \lor \psi)\)</span>，从而 <span class="math inline">\(\sigma \vDash \varphi\)</span>
且
<span class="math inline">\(\sigma \nvDash \varphi\)</span>，但这是不可能的。所以，<span class="math inline">\(\sigma \nvDash \varphi \land \neg (\varphi \lor \psi).\)</span>
根据矛盾式的定义，<span class="math inline">\(\varphi \land \neg (\varphi \lor \psi)\)</span> 是矛盾式。▗</p>
<p><bb>例 3.9</bb> 对任意公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\neg(\varphi \rightarrow \neg (\varphi \rightarrow \neg\varphi))\)</span>
是矛盾式。 <bb>证明：</bb>令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。假设
<span class="math inline">\(\sigma \vDash \neg(\varphi \rightarrow \neg (\varphi \rightarrow \neg\varphi)).\)</span>
根据真理定义，我们有
<span class="math inline">\(\sigma \nvDash \varphi \rightarrow \neg (\varphi \rightarrow \neg\varphi)\)</span>，从而
<span class="math inline">\(\sigma \vDash \varphi\)</span> 且
<span class="math inline">\(\sigma \nvDash \neg (\varphi \rightarrow \neg\varphi)\)</span>，进而
<span class="math inline">\(\sigma \vDash \varphi \rightarrow \neg\varphi.\)</span> 易见
<span class="math inline">\(\sigma \vDash \varphi\)</span> 并且 <span class="math inline">\(\sigma \vDash \neg \varphi\)</span>，亦即
<span class="math inline">\(\sigma \vDash \varphi\)</span> 并且
<span class="math inline">\(\sigma \nvDash \varphi\)</span>，但这是不可能的。所以，<span class="math inline">\(\sigma \nvDash \neg(\varphi \rightarrow \neg (\varphi \rightarrow \neg\varphi)).\)</span>
根据矛盾式的定义，<span class="math inline">\(\neg(\varphi \rightarrow \neg (\varphi \rightarrow \neg\varphi))\)</span>
是矛盾式。▗</p>
<p><bb>例 3.10</bb> 对所有不同的命题变号 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，<span class="math inline">\(p \land \neg q\)</span>
是或然式。 <bb>证明：</bb>令 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 为不同的命题变号。并且令
<span class="math inline">\(\sigma\)</span> 为任意真值指派，满足 <span class="math inline">\(\sigma(p)=1\)</span> 且 <span class="math inline">\(\sigma(q)=0.\)</span>
根据真理定义，<span class="math inline">\(\sigma \vDash p \land \neg q.\)</span> 令 <span class="math inline">\(\sigma^{\prime}\)</span>
为任意真值指派，满足 <span class="math inline">\(\sigma^{\prime}(p)=0.\)</span> 由于
<span class="math inline">\(\sigma^{\prime} \nvDash p\)</span>，所以根据真理定义，<span class="math inline">\(\sigma^{\prime} \nvDash p \land \neg q.\)</span>
由或然式定义得知，<span class="math inline">\(p \land \neg q\)</span> 是或然式。 ▗</p>
<p><bb>例 3.11</bb> 对所有不同的命题变号 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，<span class="math inline">\(p \rightarrow \neg q\)</span>
是或然式。 <bb>证明：</bb>令 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 为不同的命题变号。并且令
<span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\sigma^{\prime}\)</span> 为任意真值指派，满足 <span class="math inline">\(\sigma(p)=0\)</span> 且
<span class="math inline">\(\sigma^{\prime}(p)=\sigma^{\prime}(q)=1.\)</span> 根据真理定义，易见
<span class="math inline">\(\sigma \vDash p \rightarrow \neg q\)</span> 并且
<span class="math inline">\(\sigma^{\prime} \nvDash p \rightarrow \neg q.\)</span>
由或然式定义得知，<span class="math inline">\(p \rightarrow \neg q\)</span> 是或然式。 ▗</p>
<p>下列命题是对上述概念的简单运用。以下仅列出部分命题的证明，剩余的命题证明留作习题。</p>
<p>{{% dtpc title=“☯命题 3.7” %}} 令 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\varphi\)</span>
为任意公式。我们有： 1. <span class="math inline">\(\varphi \land \psi\)</span> 是重言式当且仅当 <span class="math inline">\(\varphi\)</span>
是重言式并且 <span class="math inline">\(\varphi\)</span> 是重言式。 <bb>证明</bb>：设 <span class="math inline">\(\varphi \land \psi\)</span>
是重言式。对每个真值指派 <span class="math inline">\(\sigma\)</span>，由假设和重言式的定义得知
<span class="math inline">\(\sigma \vDash \varphi \land \psi\)</span>，进而根据真理定义，<span class="math inline">\(\sigma \vDash \varphi.\)</span>
所以 <span class="math inline">\(\varphi\)</span> 是重言式。同理可证 <span class="math inline">\(\psi\)</span> 是重言式。另一方面，设
<span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 都是重言式。对每个真值指派
<span class="math inline">\(\sigma\)</span>，由假设和重言式定义知 <span class="math inline">\(\sigma \vDash \varphi\)</span> 且
<span class="math inline">\(\sigma \vDash \psi\)</span>，再由真理定义知 <span class="math inline">\(\sigma \vDash \varphi \land \psi.\)</span>
所以 <span class="math inline">\(\varphi \land \psi\)</span> 是重言式。▗<br />
1. 如果 <span class="math inline">\(\varphi\)</span> 或 <span class="math inline">\(\psi\)</span> 是重言式，那么 <span class="math inline">\(\varphi \lor \psi\)</span>
是重言式；但逆命题不成立。 <bb>证明</bb>： 设 <span class="math inline">\(\varphi\)</span> 或 <span class="math inline">\(\psi\)</span>
是重言式。第一种情况：<span class="math inline">\(\varphi\)</span> 是重言式。对每个真值指派 <span class="math inline">\(\sigma\)</span>，既然
<span class="math inline">\(\varphi\)</span> 是重言式，我们有 <span class="math inline">\(\sigma \vDash \varphi\)</span>，再由真理定义知
<span class="math inline">\(\sigma \vDash \varphi \lor \psi.\)</span> 所以 <span class="math inline">\(\varphi \lor \psi\)</span>
是重言式。第二种情况类似。逆命题不成立：当 <span class="math inline">\(\varphi = p\)</span> 且
<span class="math inline">\(\psi = \neg p\)</span> 时，<span class="math inline">\(\varphi \lor \psi\)</span> 是重言式，但 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
都不是重言式。▗<br />
1. 如果 <span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式，那么，或者 <span class="math inline">\(\varphi\)</span>
不是重言式或者 <span class="math inline">\(\psi\)</span> 是重言式；但逆命题不成立。 <bb>证明</bb>：设
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式。如果 <span class="math inline">\(\varphi\)</span>
是重言式，那么，对每个真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\sigma \vDash \varphi \rightarrow \psi\)</span> 并且
<span class="math inline">\(\sigma \vDash \varphi\)</span>，从而由真理定义知
<span class="math inline">\(\sigma \vDash \psi\)</span>。所以，或者 <span class="math inline">\(\varphi\)</span> 不是重言式或者 <span class="math inline">\(\psi\)</span>
是重言式。逆命题不成立：令 <span class="math inline">\(\varphi = p\)</span> 且 <span class="math inline">\(\psi = \neg p\)</span>
。显然，<span class="math inline">\(\varphi\)</span> 不是重言式，所以或者 <span class="math inline">\(\varphi\)</span> 不是重言式或者 <span class="math inline">\(\psi\)</span>
是重言式，但 <span class="math inline">\(\varphi \rightarrow \psi\)</span> 却不是重言式。▗<br />
1. 如果 <span class="math inline">\(\varphi\)</span> 是矛盾式或者 <span class="math inline">\(\psi\)</span> 是重言式，那么
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式；但逆命题不成立。
<bb>证明</bb>：由真理定义易见，如果 <span class="math inline">\(\varphi\)</span> 是矛盾式则
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式，并且如果 <span class="math inline">\(\psi\)</span> 是重言式则
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 也是重言式。所以，如果 <span class="math inline">\(\varphi\)</span> 是矛盾式或者
<span class="math inline">\(\psi\)</span> 是重言式，那么 <span class="math inline">\(\varphi \rightarrow \psi\)</span>
是重言式。逆命题不成立：令 <span class="math inline">\(\varphi=\psi=p.\)</span>
显然，<span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式，但 <span class="math inline">\(\varphi\)</span> 不是矛盾式，
<span class="math inline">\(\psi\)</span> 也不是重言式。▗ 1. <span class="math inline">\(\varphi \leftrightarrow \psi\)</span>
是重言式当且仅当 <span class="math inline">\(\varphi \rightarrow \psi\)</span> 和
<span class="math inline">\(\psi \rightarrow \varphi\)</span> 都是重言式。 <bb>证明</bb>：设
<span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式。对每个真值指派 <span class="math inline">\(\sigma\)</span>，如果
<span class="math inline">\(\sigma \vDash \varphi\)</span>，那么根据假设和真理定义， <span class="math inline">\(\sigma \vDash \psi.\)</span>
所以，<span class="math inline">\(\varphi \rightarrow \psi\)</span>
是重言式。同理可证，<span class="math inline">\(\psi \rightarrow \varphi\)</span> 也是重言式。另一方面，设
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 和 <span class="math inline">\(\psi \rightarrow \varphi\)</span> 都是重言式。令
<span class="math inline">\(\sigma\)</span> 为任意真值指派。根据假设和真理定义，如果
<span class="math inline">\(\sigma \vDash \varphi\)</span> 则 <span class="math inline">\(\sigma \vDash \psi\)</span>，并且如果
<span class="math inline">\(\sigma \nvDash \varphi\)</span> 则 <span class="math inline">\(\sigma \nvDash \psi;\)</span> 于是有
<span class="math inline">\(\varphi^\sigma = \psi^\sigma\)</span>，再由真理定义得到
<span class="math inline">\(\varphi \leftrightarrow \psi.\)</span> 所以，<span class="math inline">\(\varphi \leftrightarrow \psi\)</span>
是重言式。 ▗<br />
1. 如果 <span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式，那么，<span class="math inline">\(\varphi\)</span>
是重言式当且仅当 <span class="math inline">\(\psi\)</span> 是重言式；但逆命题不成立。 1.
<span class="math inline">\(\varphi \lor \psi\)</span> 是矛盾式当且仅当 <span class="math inline">\(\varphi\)</span> 是矛盾式并且 <span class="math inline">\(\psi\)</span>
都是矛盾式。 1. 如果 <span class="math inline">\(\varphi\)</span> 或 <span class="math inline">\(\psi\)</span> 是矛盾式，那么
<span class="math inline">\(\varphi \land \psi\)</span> 是矛盾式；但逆命题不成立。 1.
<span class="math inline">\(\varphi \rightarrow \psi\)</span> 是矛盾式当且仅当 <span class="math inline">\(\varphi\)</span> 是重言式并且
<span class="math inline">\(\psi\)</span> 是矛盾式。 1. 如果 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
中一个是重言式另一个是矛盾式，那么 <span class="math inline">\(\varphi \leftrightarrow \psi\)</span>
是矛盾式；但逆命题不成立。 {{% /dtpc %}}</p>
<p>{{% dtpc title=“☯命题 3.8” %}} 令 <span class="math inline">\(\varphi, \psi\)</span> 和
<span class="math inline">\(\varphi_0,\cdots,\varphi_n\)</span> 为任意公式。我们有： 1. <span class="math inline">\(\varphi\)</span>
是重言式当且仅当 <span class="math inline">\(\nvDash_{0} \varphi\)</span>（即
<span class="math inline">\(\varnothing \nvDash_{0} \varphi\)</span>）。 <bb>证明</bb>：设 <span class="math inline">\(\varphi\)</span>
是重言式。因为对所有真值指派 <span class="math inline">\(\sigma\)</span> 都有
<span class="math inline">\(\sigma \vDash \varphi\)</span>，所以根据重言蕴涵的定义，<span class="math inline">\(\nvDash_{0} \varphi.\)</span>
设 <span class="math inline">\(\nvDash_{0} \varphi.\)</span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。我们知道
<span class="math inline">\(\sigma \nvDash_{0} \varnothing\)</span>（见定义 3.2 之解说），因而由假设
<span class="math inline">\(\varnothing \nvDash_{0} \varphi\)</span> 和重言蕴涵定义得知
<span class="math inline">\(\sigma \vDash \varphi.\)</span> 所以 <span class="math inline">\(\varphi\)</span> 是重言式。▗ 1.
<span class="math inline">\(\varphi \nvDash_{0} \psi\)</span> 当且仅当 <span class="math inline">\(\varphi \rightarrow \psi\)</span>
是重言式。 <bb>证明</bb>：由命题 
可知，<span class="math inline">\(\varphi \vDash_{0} \psi\)</span> 当且仅当
<span class="math inline">\(\vDash_{0} \varphi \rightarrow \psi\)</span>，再运用上一条结论得知，<span class="math inline">\(\varphi \vDash_{0} \psi\)</span>
当且仅当 <span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式。▗ 1.
<span class="math inline">\(\varphi_0,\cdots,\varphi_n \nvDash_{0} \psi\)</span> 当且仅当
<span class="math inline">\(\nvDash_{0} \varphi_0 \rightarrow (\cdots\rightarrow(\varphi_n \rightarrow \psi)\cdots).\)</span>
<bb>证明</bb>：施归纳于 <span class="math inline">\(n.\)</span> 当 <span class="math inline">\(n=0\)</span> 时，由上条结论知本命题成立。假设当
<span class="math inline">\(n=k\)</span> 时本条命题成立。由命题 3.1
知，<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k}, \varphi_{k+1} \vDash_{0} \psi\)</span>
当且仅当
<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k} \vDash_{0} \varphi_{k+1} \rightarrow \psi\)</span>，再根据归纳假设，<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k} \vDash_{0} \varphi_{k+1} \rightarrow \psi\)</span>
当且仅当
<span class="math inline">\(\vDash_{0} \varphi_{0} \rightarrow(\cdots \rightarrow(\varphi_{k} \rightarrow(\varphi_{k+1} \rightarrow \psi)) \cdots).\)</span>
所以，<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k}, \varphi_{k+1} \vDash_{0} \psi\)</span>
当且仅当
<span class="math inline">\(\vDash_{0} \varphi_{0} \rightarrow(\cdots \rightarrow(\varphi_{k} \rightarrow(\varphi_{k+1} \rightarrow \psi)) \cdots).\)</span>▗
1. <span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式当且仅当 <span class="math inline">\(\varphi\)</span> 重言等值于
<span class="math inline">\(\psi.\)</span> <bb>证明</bb>：根据命题 3.4，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
重言等值当且仅当 <span class="math inline">\(\varphi \vDash_{0} \psi\)</span> 并且
<span class="math inline">\(\psi \vDash_{0} \varphi\)</span>，再根据上述第一条，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>
重言等值当且仅当 <span class="math inline">\(\varphi \rightarrow \psi\)</span> 和
<span class="math inline">\(\psi \rightarrow \varphi\)</span> 都是重言式。最后，根据命题 3.7
第四条，<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值当且仅当
<span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式。▗ {{% /dtpc %}}</p>
<p>命题 3.8 第二条的归纳证明中，归纳假设是：</p>
<blockquote>
<p>对<tt>所有</tt>的 <span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k}\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k} \vDash_{0} \psi\)</span> 当且仅当
<span class="math inline">\(\vDash_{0} \varphi_{0} \rightarrow(\cdots \rightarrow(\varphi_{k} \rightarrow \psi) \cdots).\)</span></p>
</blockquote>
<p>其中「对所有的…」来自命题 3.8 的题设「令…
为任意公式」。既然归纳假设中的 <span class="math inline">\(\psi\)</span>
可以是任意公式（如果愿意，可以把上述 <span class="math inline">\(\psi\)</span> 都改写成
<span class="math inline">\(\chi\)</span>），所以也可以是 <span class="math inline">\(\varphi_{k+1} \rightarrow \psi\)</span>
这样的公式。于是我们由归纳假设得到
<span class="math inline">\(\varphi_{0}, \cdots, \varphi_{k} \vDash_{0} \varphi_{k+1} \rightarrow \psi\)</span>
当且仅当
<span class="math inline">\(\vDash_{0} \varphi_{0} \rightarrow(\cdots \rightarrow(\varphi_{k} \rightarrow(\varphi_{k+1} \rightarrow \psi)) \cdots).\)</span></p>
<p>基本语义概念的简单应用就讲这些，希望读者完成本章后面的证明练习。做证明可帮助读者准确地理解和掌握上述基本语义概念，更可以帮助培养准确表达思想和仔细推敲论据的习惯。</p>
</div>
</div>
<div id="代入" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> 代入</h2>
<p>代入（substitution）是对公式做变形处理的一种方式。在本书的命题逻辑范围内，「代入」总是指对命题变号的代入。</p>
<div id="关于代入的直观说明" class="section level3" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> 关于代入的直观说明</h3>
<p>令 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 为任意公式，<span class="math inline">\(p\)</span> 为任意命题变项。所谓用 <span class="math inline">\(\psi\)</span>
<tt>代入</tt> <span class="math inline">\(\varphi\)</span> 中的 <span class="math inline">\(p\)</span>，是指用 <span class="math inline">\(\psi\)</span> 替换 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(\varphi\)</span>
中的<tt>每一处出现</tt>，其结果记为
<span class="math inline">\(\varphi(\psi/p).\)</span></p>
<blockquote>
<p><bb>例 3.12</bb> 令 $=q* r, =p
r $ 且 <span class="math inline">\(\varphi_{2}=p \rightarrow \neg p \vee q.\)</span> 则有： 1.
<span class="math inline">\(\varphi_{0}(q / p)=q \rightarrow r\)</span> 1. <span class="math inline">\(\varphi_{1}(q / p)=q \vee r\)</span>
1. <span class="math inline">\(\varphi_{2}(q / p)=q \rightarrow \neg q \vee q\)</span> 1.
<span class="math inline">\(\varphi_{2}(\neg p / p)=\neg p \rightarrow \neg \neg p \vee q\)</span> 1.
<span class="math inline">\(\varphi_{2}(p \vee q / p)=p \vee q \rightarrow \neg(p \vee q) \vee q\)</span></p>
</blockquote>
<p>如果我们同时用 <span class="math inline">\(\psi_0,\cdots,\psi_n\)</span> 分别代入 <span class="math inline">\(\varphi\)</span> 中的
<span class="math inline">\(p_0,\cdots,p_n\)</span>，其结果就记为 <span class="math inline">\(\varphi(\psi_0/p_0,\cdots,\psi_n/p_n).\)</span></p>
<blockquote>
<p><bb>例 3.13</bb> 令 <span class="math inline">\(\varphi\)</span> 为 <span class="math inline">\(p \rightarrow \neg p \land q.\)</span>
则有： 1. <span class="math inline">\(\varphi(q / p, p / q)=q \rightarrow \neg q \wedge p\)</span> 1.
<span class="math inline">\(\varphi(p \wedge q / p, p / q)=p \wedge q \rightarrow \neg(p \wedge q) \wedge p\)</span>
1.
<span class="math inline">\(\varphi(p \wedge q / p)(p / q)=(p \wedge q \rightarrow \neg(p \wedge q) \wedge q)(p / q)=p \wedge p \rightarrow \neg(p \wedge p) \wedge p\)</span></p>
</blockquote>
<p>注意例 3.13 公式二和公式一的差别。公式二是<tt>先</tt>用 <span class="math inline">\(p \wedge q\)</span>
代入 <span class="math inline">\(\varphi\)</span> 中的 <span class="math inline">\(p\)</span> 而得到 <span class="math inline">\(\varphi(p \wedge q / p)\)</span>，再用 <span class="math inline">\(p\)</span> 代入
<span class="math inline">\(\varphi(p \wedge q / p)\)</span> 中的 <span class="math inline">\(q\)</span> 而得到的；而公式一是用 <span class="math inline">\(p \wedge q\)</span>
代入 <span class="math inline">\(\varphi\)</span> 中的 <span class="math inline">\(p\)</span>，<tt>同时</tt>用 <span class="math inline">\(p\)</span> 代入 <span class="math inline">\(\varphi\)</span> 中的
<span class="math inline">\(q\)</span>（不是 <span class="math inline">\(\varphi(p \wedge q / p)\)</span> 中的
<span class="math inline">\(q\)</span>）而得到的。可见，同时代入的结果和先后代入的结果是不同的。</p>
</div>
<div id="代入的定义" class="section level3" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> 代入的定义</h3>
<p>如果我们只考虑具体的代入操作，那么关于代入的上述说明差不多已经够了，但这个说明显然不够严格。我们约定：在无特别说明时，我们用不同的符号表示不同的命题变号。代入的严格定义如下：</p>
<p>{{% dtpc title=“☯定义 3.9【代入】” %}}
是从命题变号集到公式集的<tt>函数</tt>。我们用
<span class="math inline">\(\mathfrak{s}, \mathfrak{s}^{\prime}\)</span> 等表示代入。设 <span class="math inline">\(\mathfrak{s}\)</span>
是一个代入。对所有公式 <span class="math inline">\(\chi\)</span>，公式 <span class="math inline">\(\chi(\mathfrak{s})\)</span>（「对 <span class="math inline">\(\chi\)</span>
做代入 <span class="math inline">\(\mathfrak{s}\)</span> 的结果」）递归地定义如下： &gt; 1. 所有命题变号
<span class="math inline">\(p\)</span>，<span class="math inline">\(p(\mathfrak{s})=\mathfrak{s}(p);\)</span> &gt; 1. 对所有公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\((\neg \varphi)(\mathfrak{s})=\neg(\varphi(\mathfrak{s}));\)</span>
&gt; 1. 对所有公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\((\varphi \odot \psi)(\mathfrak{s})=\varphi(\mathfrak{s}) \odot \psi(\mathfrak{s})\)</span>，其中
<span class="math inline">\(\odot \in\lbrace \wedge, \vee, \rightarrow, \leftrightarrow\rbrace.\)</span>
{{% /dtpc %}}</p>
<p>为简化敍述，定义 3.9
引入「<span class="math inline">\(\color{red}\odot\)</span>」符号。它指的是：对所有公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\((\varphi \wedge \psi)(\mathfrak{s})=\varphi(\mathfrak{s}) \wedge \psi(\mathfrak{s})\)</span>，<span class="math inline">\((\varphi \vee \psi)(\mathfrak{s})= \varphi(\mathfrak{s}) \vee \psi(\mathfrak{s})\)</span>，<span class="math inline">\((\varphi \rightarrow \psi)(\mathfrak{s})=\varphi(\mathfrak{s}) \rightarrow \psi(\mathfrak{s})\)</span>
并且
<span class="math inline">\((\varphi \leftrightarrow \psi)(\mathfrak{s})=\varphi(\mathfrak{s}) \leftrightarrow \psi(\mathfrak{s}).\)</span></p>
<p>{{% dtpc title=“☯定义 3.10【有穷代入】” %}} 设代入 <span class="math inline">\(\mathfrak{s}\)</span> 满足
<span class="math inline">\(\mathfrak{s}(q_{0})=\psi_{0}, \cdots, \mathfrak{s}(q_{n})=\psi_{n}\)</span>，并且
<span class="math inline">\(\mathfrak{s}(r)=r\)</span> 对所有不是 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span> 的命题变号 <span class="math inline">\(r\)</span>
都成立。我们用 <span class="math inline">\(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n}\)</span> 表示这个
<span class="math inline">\(\mathfrak{s}\)</span>，用 <span class="math inline">\(\varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n})\)</span>
来表示 <span class="math inline">\(\varphi(\mathfrak{s})\)</span>，并且称 <span class="math inline">\(\mathfrak{s}\)</span>
为<tt>有穷代入</tt>。 {{% /dtpc %}}</p>
<p>如果换个方式来讲定义 3.9 的内容，那就是：每个代入 <span class="math inline">\(\mathfrak{s}\)</span>
都可以唯一地扩充为一个满足下列（对应于定义 3.9 中）条件的公式集上的函数
<span class="math inline">\(\mathfrak{s}^{+}\)</span>：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>所有命题变号 <span class="math inline">\(p\)</span>，<span class="math inline">\(\mathfrak{s}^{+}(p)=\mathfrak{s}(p);\)</span></li>
<li>对所有公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\mathfrak{s}^{+}(\neg \varphi)=\neg\mathfrak{s}^{+}(\varphi);\)</span></li>
<li>对所有公式 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span>，<span class="math inline">\(\mathfrak{s}^{+}(\varphi \odot \psi)=\mathfrak{s}^{+}(\varphi) \odot \mathfrak{s}^{+}(\psi)\)</span>，<span class="math inline">\(\odot \in\lbrace \wedge, \vee, \rightarrow, \leftrightarrow\rbrace.\)</span></li>
</ol>
</blockquote>
<p>我们之所以采用「<span class="math inline">\(\varphi(\mathfrak{s})\)</span>」式的记法而非「<span class="math inline">\(\mathfrak{s}^{+}(\varphi)\)</span>」式的记法，是因为前者通过定义
3.10 可以和代入的直观说明在记法上保持一致。</p>
<p>为了帮助读者理解定义
3.9-3.10，我们在下面两个例子中（大体上）一步步地计算代入结果。注意：我们将尽量省略括号。<span class="math inline">\(\theta \vee \lambda / p, \theta \wedge \neg \lambda / q\)</span>
等就是 <span class="math inline">\((\theta \vee \lambda) / p,(\theta \wedge \neg \lambda) / q\)</span> 等。</p>
<p><bb>例 3.14</bb> 令
<span class="math inline">\(\varphi_{0}=q \rightarrow r, \varphi_{1}=p \vee r\)</span>，且
<span class="math inline">\(\varphi_{2}=p \rightarrow \neg p \vee q;\)</span> 并令 <span class="math inline">\(\mathfrak{s}_{0}\)</span> 为
<span class="math inline">\(q / p\)</span>，<span class="math inline">\(\mathfrak{s}_{1}\)</span> 为 <span class="math inline">\(p / p\)</span> 且 <span class="math inline">\(\mathfrak{s}_{2}\)</span> 为
<span class="math inline">\(p \vee q / p.\)</span> 我们有：</p>
<p>
<p><span class="math display">\[\begin{align*}
    \checkmark \varphi_{0}\left(\mathfrak{s}_{0}\right) &amp;=(q \rightarrow r)\left(\mathfrak{s}_{0}\right)=q\left(\mathfrak{s}_{0}\right) \rightarrow r\left(\mathfrak{s}_{0}\right)=q(q / p) \rightarrow r(q / p)=q \rightarrow r \\
    \checkmark \varphi_{1}\left(\mathfrak{s}_{0}\right) &amp;=(p \vee r)\left(\mathfrak{s}_{0}\right)=p\left(\mathfrak{s}_{0}\right) \vee r\left(\mathfrak{s}_{0}\right)=p(q / p) \vee r(q / p)=q \vee r \\
    \checkmark \varphi_{2}\left(\mathfrak{s}_{0}\right) &amp;=(p \rightarrow \neg p \vee q)\left(\mathfrak{s}_{0}\right)=p\left(\mathfrak{s}_{0}\right) \rightarrow(\neg p \vee q)\left(\mathfrak{s}_{0}\right) \\
    &amp;=p\left(\mathfrak{s}_{0}\right) \rightarrow(\neg p)\left(\mathfrak{s}_{0}\right) \vee q\left(\mathfrak{s}_{0}\right)=p\left(\mathfrak{s}_{0}\right) \rightarrow \neg p\left(\mathfrak{s}_{0}\right) \vee q\left(\mathfrak{s}_{0}\right) \\
    &amp;=p(q / p) \rightarrow \neg p(q / p) \vee q(q / p)=q \rightarrow \neg q \vee q \\
    \checkmark \varphi_{2}\left(\mathfrak{s}_{1}\right) &amp;=(p \rightarrow \neg p \vee q)\left(\mathfrak{s}_{1}\right)=p\left(\mathfrak{s}_{1}\right) \rightarrow \neg p\left(\mathfrak{s}_{1}\right) \vee q\left(\mathfrak{s}_{1}\right) \\
    &amp;=p(\neg p / p) \rightarrow \neg p(\neg p / p) \vee q(\neg p / p)=\neg p \rightarrow \neg \neg p \vee q \\
    \checkmark \varphi_{2}\left(\mathfrak{s}_{2}\right) &amp;=(p \rightarrow \neg p \vee q)\left(\mathfrak{s}_{2}\right)=p\left(\mathfrak{s}_{2}\right) \rightarrow \neg p\left(\mathfrak{s}_{2}\right) \vee q\left(\mathfrak{s}_{2}\right) \\
    &amp;=p(p \vee q / p) \rightarrow \neg p(p \vee q / p) \vee q(p \vee q / p)\\
    &amp;=p \vee q \rightarrow \neg (p \vee q) \vee q
    \end{align*}\]</span></p>
</p>
<p>根据定义 3.9，例 3.14 得到的 $(<em>),
(</em>), (<em>),
(</em>) $ 和
<span class="math inline">\(\varphi_{2}(\mathfrak{s}_{2})\)</span>，与例 3.12 根据代入的直观说明得到的
<span class="math inline">\(\varphi_{0}(q / p), \varphi_{1}(q / p), \varphi_{2}(q / p), \varphi_{2}(\neg p / p)\)</span>
和 <span class="math inline">\(\varphi_{2}(p \vee q / p)\)</span>，是完全相同的。</p>
<blockquote>
<p><bb>例 3.15</bb> 令 <span class="math inline">\(\varphi\)</span> 为 <span class="math inline">\(p \rightarrow \neg p \wedge q\)</span>，并令
<span class="math inline">\(\mathfrak{s}_{3}\)</span> 为 <span class="math inline">\(q/p, p/q\)</span>，</p>
</blockquote>
<blockquote>
<p><span class="math inline">\(\mathfrak{s}_{4}\)</span> 为 <span class="math inline">\(p \wedge q/ p, p/q\)</span>，</p>
</blockquote>
<blockquote>
<p><span class="math inline">\(\mathfrak{s}_{5}\)</span> 为 <span class="math inline">\(p \wedge q/p\)</span> 且</p>
</blockquote>
<blockquote>
<p><span class="math inline">\(\mathfrak{s}_{6}\)</span> 为 <span class="math inline">\(p/q.\)</span> 我们有：</p>
</blockquote>
<p>
<p><span class="math display">\[\begin{align*}
    \checkmark \varphi(\mathfrak{s}_{3}) &amp;=(p \rightarrow \neg p \wedge q)(\mathfrak{s}_{3})=p(\mathfrak{s}_{3}) \rightarrow(\neg p \wedge q)(\mathfrak{s}_{3}) \\
    &amp;=p(\mathfrak{s}_{3}) \rightarrow \neg p(\mathfrak{s}_{3}) \wedge q(\mathfrak{s}_{3}) \\
    &amp;=p(q / p, p / q) \rightarrow \neg p(q / p, p / q) \wedge q(q / p, p / q) \\
    &amp;=q \rightarrow \neg q \wedge p \\
    \checkmark \varphi(\mathfrak{s}_{4}) &amp;=(p \rightarrow \neg p \wedge q)(\mathfrak{s}_{4})=p(\mathfrak{s}_{4}) \rightarrow \neg p(\mathfrak{s}_{4}) \wedge q(\mathfrak{s}_{4}) \\
    &amp;=p(p \wedge q / p, p / q) \rightarrow \neg p(p \wedge q / p, p / q) \wedge q(p \wedge q / p, p / q) \\
    &amp;=p \wedge q \rightarrow \neg(p \wedge q) \wedge p\\
    \checkmark \varphi(\mathfrak{s}_{5})(\mathfrak{s}_{6}) &amp;=(p \rightarrow \neg p \wedge q)(\mathfrak{s}_{5})(\mathfrak{s}_{6})=\left[p(\mathfrak{s}_{5}) \rightarrow \neg p(\mathfrak{s}_{5}) \wedge q(\mathfrak{s}_{5})\right](\mathfrak{s}_{6}) \\
    &amp;=[p(p \wedge q / p) \rightarrow \neg p(p \wedge q / p) \wedge q(p \wedge q / p)](\mathfrak{s}_{6}) \\
    &amp;=(p \wedge q \rightarrow \neg(p \wedge q) \wedge q)(\mathfrak{s}_{6}) \\
    &amp;=(p \wedge q)(\mathfrak{s}_{6}) \rightarrow(\neg(p \wedge q) \wedge q)(\mathfrak{s}_{6}) \\
    &amp;=p(\mathfrak{s}_{6}) \wedge q(\mathfrak{s}_{6}) \rightarrow \neg(p(\mathfrak{s}_{6}) \wedge q(\mathfrak{s}_{6})) \wedge q(\mathfrak{s}_{6}) \\
    &amp;=p(p / q) \wedge q(p / q) \rightarrow \neg(p(p / q) \wedge q(p / q)) \wedge q(p / q) \\
    &amp;=p \wedge p \rightarrow \neg(p \wedge p) \wedge p
    \end{align*}\]</span></p>
</p>
<p>注意：对所有公式 <span class="math inline">\(\varphi\)</span>，以及所有代入 <span class="math inline">\(\mathfrak{s}\)</span> 和
<span class="math inline">\(\mathfrak{s}^{\prime}\)</span>，因为 <span class="math inline">\(\varphi(\mathrm{s})\)</span> 是对 <span class="math inline">\(\varphi\)</span>
做代入 <span class="math inline">\(\mathfrak{s}\)</span> 的结果，所以
<span class="math inline">\(\varphi(\mathfrak{s})(\mathfrak{s}^{\prime})\)</span> 就是
<span class="math inline">\((\varphi(\mathfrak{s}))(\mathfrak{s}^{\prime}).\)</span>
这可推广至更一般的情况。</p>
<p>易见，根据定义 3.9，例 3.15 得到的部分结果，与根据代入的直观说明在例
3.13 中得到的 <span class="math inline">\(\varphi(q / p, p / q), \varphi(p \wedge q / p, p / q)\)</span> 和
<span class="math inline">\(\varphi(p \wedge q / p)(p / q)\)</span>，是完全相同的。</p>
<p>如果 <span class="math inline">\(q\)</span> 不在 <span class="math inline">\(\varphi\)</span> 中出现，那么对任何代入 <span class="math inline">\(\mathfrak{s}\)</span>，无论
<span class="math inline">\(\mathfrak{s}(q)\)</span> 是什么公式，似乎都应与 <span class="math inline">\(\varphi(\mathfrak{s})\)</span>
无关。一般地，下述说法也似乎应该是对的：</p>
<blockquote>
<p>对一个公式 <span class="math inline">\(\varphi\)</span> 做代入 <span class="math inline">\(\mathfrak{s}\)</span>，其结
<span class="math inline">\(\varphi(\mathfrak{s})\)</span> 应只与 <span class="math inline">\(\mathfrak{s}\)</span> 指派给 <span class="math inline">\(\varphi\)</span>
中出现的命题变号的值有关，或者说，与 <span class="math inline">\(\mathfrak{s}\)</span>
指派给其他命题变号的值无关。</p>
</blockquote>
<p>命题 3.9 正是对这种直观说法的一个准确表述。</p>
<p>{{% dtpc title=“☯命题 3.9” %}} 令 <span class="math inline">\(\varphi\)</span> 为任意公式，并令
<span class="math inline">\(\mathfrak{s}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 为任意代入。设 <span class="math inline">\(\varphi\)</span>
中出现的命题变号是在 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span> 之中，并且
<span class="math inline">\(\mathfrak{s}(q_{0})=\mathfrak{s}^{\prime}(q_{0}), \cdots, \mathfrak{s}(q_{n})=\mathfrak{s}^{\prime}(q_{n}).\)</span>
我们 有：<span class="math inline">\(\varphi(\mathfrak{s})=\varphi(\mathfrak{s}^{\prime}).\)</span>
{{% /dtpc %}}</p>
<p><bb>命题 3.9 之证明：</bb>
施归纳于公式的复杂度，我们证明：对每个只含命题变号
<span class="math inline">\(q_{0}, \cdots, q_{n}\)</span>的公式<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi(\mathfrak{s})=\varphi(\mathfrak{s}^{\prime}).\)</span>
归纳基始：<span class="math inline">\(\varphi=q_{i}(i \leqslant n).\)</span> 由题设知
<span class="math inline">\(\mathfrak{s}(q_{i})=\mathfrak{s}^{\prime}(q_{i})\)</span>，即
<span class="math inline">\(\varphi(\mathfrak{s})=\varphi(\mathfrak{s}^{\prime}).\)</span> 归纳步骤：设
<span class="math inline">\(\varphi=\neg \psi.\)</span>
根据归纳假设，<span class="math inline">\(\psi(\mathfrak{s})=\psi(\mathfrak{s}^{\prime})\)</span>，再由定义
3.9 得到
<span class="math inline">\((\neg \psi)(\mathfrak{s})=\neg(\psi(\mathfrak{s}))=\neg(\psi(\mathfrak{s}^{\prime}))=(\neg \psi)(\mathfrak{s}^{\prime}).\)</span>
设 <span class="math inline">\(\varphi=\psi \odot \chi\)</span>，其中
<span class="math inline">\(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace.\)</span>
由归纳假设，<span class="math inline">\(\psi(\mathfrak{s})=\psi(\mathfrak{s}^{\prime})\)</span> 且
<span class="math inline">\(\chi(\mathfrak{s})=\chi(\mathfrak{s}^{\prime})\)</span>，因而有
<span class="math inline">\(\psi(\mathfrak{s}) \odot \chi(\mathfrak{s})=\psi(\mathfrak{s}^{\prime}) \odot \chi(\mathfrak{s}^{\prime})\)</span>，再由定义
3.9 得到
<span class="math inline">\((\psi \odot \chi)(\mathfrak{s})=(\psi \odot \chi)(\mathfrak{s}^{\prime}).\)</span>（命题
3.9
是如何把「有关」和「无关」这种模糊说法改进为准确的说法的？注意这类问题一定有好处。）▗</p>
<p>上述证明中用到了基于公式复杂度的归纳证明方法。</p>
<p>要想说明上面那个直观想法的正确性，前提是对「有关」「无关」等做出清楚而准确的刻画。很多学生善于联想和发挥，却不善于清楚和准确。清楚和准确往往不易做到，有时甚至不必要。但如果想把能讲好的道理讲好，首先要有把想法讲清楚讲准确的本领。倘若一个理论中的每个命题都「本身就是说不清的」，那它也就没什么道理好讲。当然，清楚和准确只是做好理论工作的必要条件，不是充分条件。</p>
</div>
<div id="代入的复合" class="section level3" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> 代入的复合</h3>
<p>{{% dtpc title=“☯定义 3.11【代入的复合】” %}} 设 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span>
和 <span class="math inline">\(\mathfrak{s}^{\prime\prime}\)</span> 为任意代入，我们用
<span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime}\)</span>
来表示它们的复合，即满足下列条件的代入 <span class="math inline">\(\mathfrak{s}\)</span>： 1.
对任意命题变号
<span class="math inline">\(p\)</span>，<span class="math inline">\(\mathfrak{s}(p)=p(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})\)</span>，即
<span class="math inline">\(\mathfrak{s}(p)=(\mathfrak{s}^{\prime}(p))(\mathfrak{s}^{\prime \prime}).\)</span>
1. 并且我们用
<span class="math inline">\(\varphi(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime})\)</span> 来表示
<span class="math inline">\(\varphi(\mathfrak{s}).\)</span> {{% /dtpc %}}</p>
<p>这里的名称和记法（稍有改动）来自 Chagrov, Zakharyaschev［1997］。虽然
<span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime\prime}\)</span>
都是函数，而且我们也用「代入的复合」来称呼
<span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime}\)</span>，但
<span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime}\)</span>
与通常数学中讨论的关系或函数的复合（composition）有所不同。<span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime}\)</span>
既不是通常数学中的
<span class="math inline">\(\mathfrak{s}^{\prime}\circ \mathfrak{s}^{\prime\prime}\)</span> 也不是
<span class="math inline">\(\mathfrak{s}^{\prime\prime}\circ \mathfrak{s}^{\prime}.\)</span>
这是因为：<span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime\prime}\)</span>
的定义域都是命题变号集且其值域都是比命题变号集更大的公式集，而在数学中，要使
<span class="math inline">\(\mathfrak{s}^{\prime} \circ \mathfrak{s}^{\prime\prime}\)</span> 或
<span class="math inline">\(\mathfrak{s}^{\prime\prime} \circ \mathfrak{s}^{\prime}\)</span>
成为函数的复合，<span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 或 <span class="math inline">\(\mathfrak{s}^{\prime\prime}\)</span>
的值域须是对方定义域的子集。</p>
<p>易见，如果 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime\prime}\)</span>
都是有穷代入，那么 <span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime\prime}\)</span>
也是有穷代入（见习题 3.10）。</p>
<p>根据各种各样的例子，人们自然地会猜想：</p>
<blockquote>
<p>如果对一个公式 <span class="math inline">\(\varphi\)</span> 做代入得到 <span class="math inline">\(\psi\)</span>，再对 <span class="math inline">\(\psi\)</span> 做代入得到
<span class="math inline">\(\chi\)</span>，那么对 <span class="math inline">\(\varphi\)</span> 做一次代入就可以得到
<span class="math inline">\(\chi\)</span>，而这个代入正是前两个代入的复合。</p>
</blockquote>
<p>这个猜想的确是真的。</p>
<p>{{% dtpc title=“☯命题 3.10” %}} 对任意代入 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 和
<span class="math inline">\(\mathfrak{s}^{\prime \prime}\)</span>，对任意公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi\left(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}\right)=\varphi\left(\mathfrak{s}^{\prime}\right)\left(\mathfrak{s}^{\prime \prime}\right).\)</span></p>
<p><bb>证明：</bb>施归纳于公式 <span class="math inline">\(\varphi\)</span> 的复杂度。 <bb>归纳基始</bb>：设
<span class="math inline">\(\varphi\)</span> 是命题变项 <span class="math inline">\(p.\)</span> 根据定义 3.9 和定义 3.11,
<span class="math inline">\(\varphi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=p(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})(p)=p(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})=\varphi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}).\)</span>
<bb>归纳步聚</bb> 1：设 <span class="math inline">\(\varphi\)</span> 是 <span class="math inline">\(\neg \psi.\)</span> 根据定义
3.9，<span class="math inline">\((\neg \psi)(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\neg(\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}))\)</span>。由归纳假设知，<span class="math inline">\(\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\psi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})\)</span>，进而
<span class="math inline">\(\neg(\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}))=\neg(\psi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}))\)</span>，再由定义
3.9 得到
<span class="math inline">\(\neg(\psi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}))=(\neg(\psi(\mathfrak{s}^{\prime}))(\mathfrak{s}^{\prime \prime}))=(\neg \psi)(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}).\)</span>
所以，<span class="math inline">\((\neg \psi)(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})= (\neg \psi)(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}).\)</span>
<bb>归纳步骤</bb> 2-5: 设 <span class="math inline">\(\varphi\)</span> 为 <span class="math inline">\(\psi \odot \chi\)</span>, 其中
<span class="math inline">\(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace.\)</span>
按定义
3.9，<span class="math inline">\((\psi \odot \chi)(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}) \odot \chi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}).\)</span>
根据归纳假设，<span class="math inline">\(\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\psi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})\)</span>
并且
<span class="math inline">\(\chi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\chi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})\)</span>，从而
<span class="math inline">\(\psi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime}) \odot \chi(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=\psi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}) \odot \chi(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime})\)</span>，再由定义
3.9 得到</p>
<p>
<p><span class="math display">\[\begin{align}
\psi\left(\mathfrak{s}^{\prime}\right)\left(\mathfrak{s}^{\prime \prime}\right) \odot \chi\left(\mathfrak{s}^{\prime}\right)\left(\mathfrak{s}^{\prime \prime}\right)
&amp;= \left(\psi\left(\mathfrak{s}^{\prime}\right) \odot \chi\left(\mathfrak{s}^{\prime}\right)\right)\left(\mathfrak{s}^{\prime \prime}\right)\\
&amp;= (\psi \odot \chi)\left(\mathfrak{s}^{\prime}\right)\left(\mathfrak{s}^{\prime \prime}\right)
\end{align}\]</span></p>
</p>
<p>所以，<span class="math inline">\((\psi \odot \chi)(\mathfrak{s}^{\prime} \mathfrak{s}^{\prime \prime})=(\psi \odot \chi)(\mathfrak{s}^{\prime})(\mathfrak{s}^{\prime \prime}).\)</span>
▗ {{% /dtpc %}}</p>
<p>读过「关于代入的直观说明」（§3.2.0（P.107）），一般人就明白如何做代入，即「会做」了。为什么还要谈代入的严格定义甚至代入的复合呢？千万不要因为这些是「末节」或「小技」就不屑一顾。正是这种「末节」和「小技」的积累，使人们能超越「会做」而进入对深层问题的讨论。试想：假如对代入的理解仅停留在「会做」的水平，那么我们如何证明「多次代入的结果都可通过一次代入得到」这个猜想呢？现在用「末节」和「小技」得到的这个结论，以后可以用于解决更深更难的问题。</p>
</div>
<div id="代入的语义性质" class="section level3" number="4.3.4">
<h3><span class="header-section-number">4.3.4</span> 代入的语义性质</h3>
<p>这里我们讨论公式的不同代入结果在真值指派下的值，比如说，<span class="math inline">\(\varphi(\psi / p)\)</span>
和 <span class="math inline">\(\varphi(\chi/p)\)</span> 在 <span class="math inline">\(\sigma\)</span> 下的值。不难猜测：如果
<span class="math inline">\(\psi^{\sigma}=p^{\sigma}\)</span> 则
<span class="math inline">\(\varphi^{\sigma}=(\varphi(\psi / p))^{\sigma}\)</span>，亦即在 <span class="math inline">\(\sigma\)</span>
下，如果 <span class="math inline">\(\psi\)</span> 和 <span class="math inline">\(p\)</span> 的值相同，那么无论对 <span class="math inline">\(\varphi\)</span>
是否做代入<span class="math inline">\(\psi / p\)</span>, 其结果的值应该是一样的。一般地，公式
<span class="math inline">\(\varphi(\psi / p)\)</span> 在 <span class="math inline">\(\sigma\)</span> 下的值与 <span class="math inline">\(\psi\)</span> 在 <span class="math inline">\(\sigma\)</span>
下的值有关，但与 <span class="math inline">\(\psi\)</span> 具体是哪个公式无关，也就是说，只要 <span class="math inline">\(\psi\)</span> 和
<span class="math inline">\(\chi\)</span> 在 <span class="math inline">\(\sigma\)</span> 下的值相同, 那么无论是对 <span class="math inline">\(\varphi\)</span> 做代入 <span class="math inline">\(\psi / p\)</span>
还是做代入 <span class="math inline">\(\chi / p\)</span>，其结果在 <span class="math inline">\(\sigma\)</span> 下的值都是一样的 (见推论
3.2)。下面几个命题说的正是这类事，不过比这更一般。</p>
<p>{{% dtpc title=“☯定理 3.0” %}} 设 <span class="math inline">\(\varphi\)</span>
为任意公式，其中出现的命题变号只有 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span>，并设 <span class="math inline">\(\sigma\)</span>
和 <span class="math inline">\(\sigma^{\prime}\)</span> 为任意真值指派，满足
<span class="math inline">\(\psi_{0}^{\sigma}=\chi_{0}^{\sigma^{\prime}}, \cdots, \psi_{n}^{\sigma}=\chi_{n}^{\sigma^{\prime}}.\)</span>
我们有：<span class="math inline">\(\sigma \vDash \varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n})\)</span>
当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \varphi(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}).\)</span>
{{% /dtpc %}}</p>
<p><bb>证明：</bb>令 <span class="math inline">\(\mathfrak{s}\)</span> 为
<span class="math inline">\(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n}\)</span> 且 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span>
为 <span class="math inline">\(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}.\)</span> 施归纳于公式的复杂度。
<bb>归纳基始</bb>：<span class="math inline">\(\varphi=q_{i}(i \leqslant n).\)</span> 显然有
<span class="math inline">\(\varphi(\mathfrak{s})=\psi_{i}\)</span> 且
$(^{})=_{i} $，而根据题设
<span class="math inline">\(\psi_{i}^{\sigma}=\chi_{i}^{\sigma^{\prime}}\)</span>，我们有
<span class="math inline">\(\sigma \vDash \psi_{i}\)</span> 当且仅当 <span class="math inline">\(\sigma^{\prime} \vDash \chi_{i}.\)</span>
<bb>归纳步骤</bb>：设 <span class="math inline">\(\varphi=\neg \theta_{\circ}\)</span>
根据归纳假设，<span class="math inline">\(\sigma \vDash \theta(\mathrm{s})\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \theta(\mathrm{s}^{\prime})\)</span>，因而根据真理定义，<span class="math inline">\(\sigma \vDash \neg \theta(\mathfrak{s})\)</span>
当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \neg \theta(\mathfrak{s}^{\prime})\)</span>，再由定义
3.9 知，<span class="math inline">\(\sigma \vDash(\neg \theta)(\mathfrak{s})\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash(\neg \theta)(\mathfrak{s}^{\prime}).\)</span> 设
<span class="math inline">\(\varphi=\theta \odot \lambda\)</span>，其中
<span class="math inline">\(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace.\)</span>
由归纳假设，<span class="math inline">\(\sigma \vDash \theta(\mathfrak{s})\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \theta(\mathfrak{s}^{\prime})\)</span>，并且$
()$ 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \lambda(\mathfrak{s}^{\prime});\)</span>
所以根据真理定义，<span class="math inline">\(\sigma \vDash \theta(\mathfrak{s}) \odot \lambda(\mathfrak{s})\)</span>
当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \theta(\mathfrak{s}^{\prime}) \odot \lambda(\mathfrak{s}^{\prime})\)</span>，再由定义
3.9 知，<span class="math inline">\(\sigma \vDash(\theta \odot \lambda)(\mathfrak{s})\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash(\theta \odot \lambda)(\mathfrak{s}^{\prime}).\)</span> ▗</p>
<p>{{% dtpc title=“☯定理 3.1” %}} 令 <span class="math inline">\(\varphi\)</span>
为任意公式，其中出现的命题变号都在 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span> 之中。设
<span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\sigma^{\prime}\)</span> 为任意真值指派，满足
<span class="math inline">\(\sigma^{\prime}\left(q_{0}\right) = \psi_{0}^{\sigma}, \cdots, \sigma^{\prime}\left(q_{n}\right) = \psi_{n}^{\sigma}.\)</span>
我们有：对任意代入 <span class="math inline">\(\mathfrak{s}\)</span>，如果
<span class="math inline">\(\mathfrak{s}\left(q_{0}\right) = \psi_{0}, \cdots, \mathfrak{s}\left(q_{n}\right) = \psi_{n}\)</span>，那么
<span class="math inline">\(\sigma \vDash \varphi(\mathfrak{s})\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \varphi.\)</span> {{% /dtpc %}}</p>
<p><bb>证明：</bb>设 <span class="math inline">\(\mathfrak{s}\)</span> 为任意代入，满足
<span class="math inline">\(\mathfrak{s}\left(q_{0}\right) = \psi_{0}, \cdots, \mathfrak{s}\left(q_{n}\right) = \psi_{n};\)</span>
并令 <span class="math inline">\(\mathfrak{s}^{*}\)</span> 为代入
<span class="math inline">\(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n}.\)</span> 根据定理
3.0，<span class="math inline">\(\sigma \vDash \varphi\left(\mathfrak{s}^{*}\right)\)</span> 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \varphi\)</span>，再由命题 3.9 得知
<span class="math inline">\(\varphi(\mathfrak{s}) = \varphi\left(\mathfrak{s}^{*}\right).\)</span>
所以，$() $ 当且仅当
<span class="math inline">\(\sigma^{\prime} \vDash \varphi.\)</span> ▗</p>
<p>定理 3.1 的一个推论是：对每个公式 <span class="math inline">\(\varphi\)</span> 和每个代入
<span class="math inline">\(\mathfrak{s}\)</span>，如果 <span class="math inline">\(\varphi\)</span> 是重言式，那么 <span class="math inline">\(\varphi(\mathfrak{s})\)</span>
一定也是重言式。（见习题 3.17）</p>
<p>注意：定理 3.0 和定理 3.1 都要求 <span class="math inline">\(\varphi\)</span> 中岀现的命题变号在
<span class="math inline">\(q_{0}, \cdots, q_{n}\)</span> 之中，但下面的推论 3.2 并不这样要求。之所以推论
3.2 允许 <span class="math inline">\(\varphi\)</span> 中出现不同于 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span>
的命题变号，是因为它涉及的真值指派只有一个。</p>
<p>{{% dtpc title=“☯推论 3.2” %}} 设 <span class="math inline">\(\sigma\)</span> 为任意真值指派，且对每个
<span class="math inline">\(i=0, \cdots, n\)</span> 都有 <span class="math inline">\(\psi_{i}^{\sigma}=\chi_{i}^{\sigma}.\)</span>
我们有：对所有公式 <span class="math inline">\(\varphi\)</span> 和所有命题变号
<span class="math inline">\(q_{0}, \cdots, q_{n}, \sigma \vDash \varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n})\)</span>
当且仅当
<span class="math inline">\(\sigma \vDash \varphi(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}).\)</span>
{{% /dtpc %}}</p>
<p><bb>证明：</bb>设 <span class="math inline">\(\varphi\)</span> 为任意公式，<span class="math inline">\(q_{0}, \cdots, q_{n}\)</span>
为任意命题变号，并设 $r_{1}, , r_{m}(m ) $ 为
<span class="math inline">\(\varphi\)</span> 中出现的所有与 <span class="math inline">\(q_{0}, \cdots, q_{n}\)</span>
不同的命题变号。根据题设和定理 3.0</p>
<p>
<p><span class="math display">\[
\begin{array}{rl}
&amp; \sigma \vDash \varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n}, r_{1} / r_{1}, \cdots, r_{m} / r_{m}) \\
\text{iff}  &amp; \sigma \vDash \varphi(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}, r_{1} / r_{1}, \cdots, r_{m} / r_{m})
\end{array}
\]</span></p>
</p>
<p>同时易见
<span class="math inline">\(\varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n}, r_{1} / r_{1}, \cdots, r_{m} / r_{m})\)</span>
就是 <span class="math inline">\(\varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n})\)</span> 而
$( / q<em>{0}, ,  / q</em>{n}, r_{1} / r_{1},
, r_{m} / r_{m}) $ 就是
<span class="math inline">\(\varphi(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}).\)</span> 所以
<span class="math inline">\(\sigma \vDash \varphi(\psi_{0} / q_{0}, \cdots, \psi_{n} / q_{n})\)</span>
当且仅当
<span class="math inline">\(\sigma \vDash \varphi(\chi_{0} / q_{0}, \cdots, \chi_{n} / q_{n}).\)</span> ▗</p>
<p>最后，我们来看关于「<tt>置换</tt>」的语义定理。</p>
<p>{{% dtpc title=“☯推论 3.3” %}} 设
<span class="math inline">\(\Gamma \vDash_{0} \psi \leftrightarrow \chi.\)</span> 我们有：对每个公式
<span class="math inline">\(\varphi\)</span> 和每个命题变号
<span class="math inline">\(p\)</span>，<span class="math inline">\(\Gamma \vDash_{0} \varphi(\psi / p) \leftrightarrow \varphi(\chi / p).\)</span>
{{% /dtpc %}}</p>
<p><bb>证明：</bb>设 <span class="math inline">\(\varphi\)</span> 为任意公式，<span class="math inline">\(p\)</span> 为任意命题变号。令 <span class="math inline">\(\sigma\)</span>
为任意真值指派，满足 <span class="math inline">\(\sigma \vDash \Gamma.\)</span> 由题设和重言蕴涵的定义知
<span class="math inline">\(\sigma \vDash \psi \leftrightarrow \chi.\)</span> 从而有
<span class="math inline">\(\psi^{\sigma}=\chi^{\sigma}.\)</span> 根据推论
3.2，<span class="math inline">\(\sigma \vDash \varphi(\psi / p)\)</span> 当且仅当
<span class="math inline">\(\sigma \vDash \varphi(\chi / p)\)</span>，进而
<span class="math inline">\(\sigma \vDash \varphi(\psi / p) \leftrightarrow \varphi(\chi / p).\)</span>
由此
可知，<span class="math inline">\(\Gamma \vDash_{0} \varphi(\psi / p) \leftrightarrow \varphi(\chi / p).\)</span>
▗</p>
<p>用 <span class="math inline">\(\chi\)</span> <bb>置换</bb> <span class="math inline">\(\varphi\)</span> 中的 <span class="math inline">\(\psi\)</span>，是指用 <span class="math inline">\(\chi\)</span> 替换 <span class="math inline">\(\psi\)</span>
在 <span class="math inline">\(\varphi\)</span> 中的<tt>有穷多</tt>个出现，而这样得到的所有公式都称为
<span class="math inline">\(\varphi\)</span> 的 <bb><span class="math inline">\(\chi/\psi\)</span>-置换结果</bb>（简称置换结果）。推论 3.3
有时以下述形式出现，容易证明两者是等价的（见习题 3.16）:</p>
<p>{{% dtpc title=“☯推论 3.4” %}} 设
<span class="math inline">\(\Gamma \vDash_{0} \psi \leftrightarrow \chi.\)</span> 我们有：对 <span class="math inline">\(\varphi\)</span>
的每个 <span class="math inline">\(\chi / \psi\)</span>-置换结果
<span class="math inline">\(\varphi^{\prime}, \Gamma \vDash_{0} \varphi \leftrightarrow \varphi^{\prime}.\)</span>
{{% /dtpc %}}</p>
<p>当 <span class="math inline">\(\Gamma=\varnothing\)</span> 时，上述推论成为：</p>
<p>{{% dtpc title=“☯推论 3.5” %}} 如果 <span class="math inline">\(\psi\)</span> 与 <span class="math inline">\(\chi\)</span> 重言等值，那么
<span class="math inline">\(\varphi\)</span> 与它的所有 <span class="math inline">\(\chi / \psi\)</span>-置换结果都重言等值。 {{% /dtpc %}}</p>
<p>推论 3.5 常被称为<tt>等值置换</tt>的语义版本 (或形式)。我们来看一个例子:</p>
<p>令
<span class="math inline">\(\varphi=\neg p \vee \neg q \rightarrow r \wedge(\neg p \vee \neg q), \psi=\neg p \vee \neg q\)</span>
并且 <span class="math inline">\(\chi=\neg(p \wedge q).\)</span> 用 <span class="math inline">\(\chi\)</span> 置换 <span class="math inline">\(\varphi\)</span> 中 <span class="math inline">\(\psi\)</span>
的结果可以是下面的任何一个：</p>
<p>
<p><span class="math display">\[\begin{align}
\varphi_{0}^{\prime}&amp;=\neg(p \wedge q) \rightarrow r \wedge(\neg p \vee \neg q) \nonumber \\
\varphi_{1}^{\prime}&amp;=\neg p \vee \neg q \rightarrow r \wedge \neg(p \wedge q) \label{eq:dairu-tuilun-3.5}\\
\varphi_{2}^{\prime}&amp;=\neg(p \wedge q) \rightarrow r \wedge \neg(p \wedge q) \nonumber
\end{align}\]</span></p>
</p>
<p>因 <span class="math inline">\(\chi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值 (见习题 3.5), 所以根据推论
3.5，<span class="math inline">\(\varphi_{0}^{\prime}, \varphi_{1}^{\prime}\)</span>，<span class="math inline">\(\varphi_{2}^{\prime}\)</span>
都与 <span class="math inline">\(\varphi\)</span> 重言等值。</p>
<p>代入和置换有很大不同：从上面的例子可以看出，</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>对一个公式做代入，替换的只能是它的原子子公式（命题变号）；而对一个公式做置换，替换的可以是它的任何子公式。</li>
<li>对一个公式做代入时，如果替换其中的某命题变号，则必须替换这一命题变号在该公式中的所有出现；但在对一公式做置换时，可以只替换该子公式的某些出现，而不替换它的另一些出现。</li>
</ol>
</blockquote>
<p>代入和置换又有紧密的联系。比如，我们说过推论 3.4 等价于推论
3.3，那就是说，一个使用「置换」来表达的命题（如推论
3.4），等价于一个使用「代入」而不使用「置换」来表达的命题（如推论
3.3）。我们再用上面的例子加以说明：</p>
<p>仍令
<span class="math inline">\(\varphi=\neg p \vee \neg q \rightarrow r \wedge(\neg p \vee \neg q), \psi=\neg p \vee \neg q\)</span>
并且 <span class="math inline">\(\chi=\neg(p \wedge q).\)</span> 令 <span class="math inline">\(p^{*}\)</span> 为任意一个与 <span class="math inline">\(p, q, r\)</span>
都不同的命题变号，并且令</p>
<p>
<p><span class="math display">\[\begin{align*}
\varphi_{0}&amp;=p^{*} \rightarrow r \wedge(\neg p \vee \neg q) \\
\varphi_{1}&amp;=\neg p \vee \neg q \rightarrow r \wedge p^{*} \\
\varphi_{2}&amp;=p^{*} \rightarrow r \wedge p^{*}
\end{align*}\]</span></p>
</p>
<p>易见下列等式成立，其中 <span class="math inline">\(\varphi_{0}^{\prime}, \varphi_{1}^{\prime}\)</span> 和
<span class="math inline">\(\varphi_{2}^{\prime}\)</span> 来自式 ()</p>
<p>
<p><span class="math display">\[\begin{align}
\varphi_{0}(\psi / p^{*})=\varphi_{1}(\psi / p^{*})=\varphi_{2}(\psi / p^{*})=\varphi \nonumber\\
\varphi_{0}(\chi / p^{*})=\neg(p \wedge q) \rightarrow r \wedge(\neg p \vee \neg q)=\varphi_{0}^{\prime} \nonumber \\
\varphi_{1}(\chi / p^{*})=\neg p \vee \neg q \rightarrow r \wedge \neg(p \wedge q)=\varphi_{1}^{\prime} \label{eq:dairu-tuilun-3.7}\\
\varphi_{2}(\chi / p^{*})=\neg(p \wedge q) \rightarrow r \wedge \neg(p \wedge q)=\varphi_{2}^{\prime}
\nonumber
\end{align}\]</span></p>
</p>
<p>因为 <span class="math inline">\(\psi\)</span> 与 <span class="math inline">\(\chi\)</span> 重言等值，所以，根据推论 3.3（视 <span class="math inline">\(\Gamma\)</span>
为空集），<span class="math inline">\(\varphi_{0}(\psi / p^{*}), \varphi_{1}(\psi / p^{*})\)</span> 和
<span class="math inline">\(\varphi_{2}(\psi / p^{*})\)</span> 分别与
<span class="math inline">\(\varphi_{0}(\chi / p^{*}), \varphi_{1}(\chi / p^{*})\)</span> 和
<span class="math inline">\(\varphi_{2}(\chi / p^{*})\)</span> 重言等值。我们由式
()知道，这就是在说 <span class="math inline">\(\varphi\)</span> 与
<span class="math inline">\(\varphi_{0}^{\prime}, \varphi_{1}^{\prime}\)</span> 和 <span class="math inline">\(\varphi_{2}^{\prime}\)</span>
都重言等值，与前面由推论 3.5 得出的结论完全一样。</p>
<p>注意，推论 3.5 是「等值置换」语义形式的常见说法，而推论 3.3-3.4
在应用方面比推论 3.5 更方便。</p>
</div>
</div>
<div id="真值指派与真值表" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> 真值指派与真值表</h2>
<p>我们对重言蕴涵和重言式等概念曾给出两个不同的说明：一个是§2.5（P.85）
中的真值表刻画，另一个是在§3.1（P.101）中用真值指派给出的定义。为避免混淆，我们用这些概念的「严格定义」来指§3.1（P.101）中的定义，用这些概念的「真值表刻画」指§2.5（P.85）中的说明。这一节我们讨论的主要内容是这些概念的严格定义和真值表刻画的等价性。</p>
<p>从这一节起，我们将较多地使用真值函数这个概念。</p>
<div id="真值函数" class="section level3" number="4.4.1">
<h3><span class="header-section-number">4.4.1</span> 真值函数</h3>
<p>前面说过，真值函数是从真值集到真值集的函数，而且真值函数联结词就是以真值函数为其解释的联结词。第一点很容易理解，但第二点也许不太明显，我们先对它做一点说明。</p>
<p>显然，下列函数都是真值函数（其中 <span class="math inline">\(x, y \in \lbrace 1,0\rbrace\)</span>）：</p>
<p>{{% freebox title=“真值函数联结词” %}}</p>
<p>
<p><span class="math display">\[\begin{align}
f_{\neg}(x) &amp;=\left\lbrace \begin{array}{ll}
1 &amp; \text { 如果 }~ x=0 \\
0 &amp; \text { 否则 }
\end{array}\right.\\
f_{\lor}(x, y) &amp;=\left\lbrace \begin{array}{ll}
1 &amp; \text { 如果 }~  x=1 \text { 或 } y=1 \\
0 &amp; \text { 否则 }
\end{array}\right.\\
f_{\land}(x, y) &amp;=\left\lbrace \begin{array}{ll}
1 &amp; \text { 如果 }~  x=y=1 \\
0 &amp; \text { 否则 }
\end{array}\right.\\
f_{\rightarrow}(x, y) &amp;=\left\lbrace \begin{array}{ll}
1 &amp; \text { 如果 }~  x=0 \text { 或 }~  y=1 \\
0 &amp; \text { 否则 }
\end{array}\right.\\
f_{\leftrightarrow}(x, y) &amp;=\left\lbrace \begin{array}{ll}
1 &amp; \text { 如果 }~  x=y \\
0 &amp; \text { 否则 }
\end{array}\right.
\end{align}\]</span></p>
</p>
<p>若用真值表来表示这些函数，它们与基本真值表 2.1 完全对应：</p>
<p>
<p><span class="math display">\[
    \begin{array}{cc|c|c|c|c|c}
    x &amp; y &amp; f_{\land}(x, y) &amp; f_{\lor}(x, y) &amp; f_{\rightarrow}(x, y) &amp; f_{\leftrightarrow}(x, y) &amp; f_{\neg}(x) \\
    \hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\
    1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp;  \\
    0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 
    \end{array}
\]</span></p>
</p>
<p>{{% /freebox %}}</p>
<p>事实上，用真值指派 <span class="math inline">\(\sigma\)</span> 对所有公式 <span class="math inline">\(\varphi\)</span> 定义其真值
<span class="math inline">\(\varphi^\sigma\)</span> 时（见定义 3.1），我们完全可以把定义写成下述形式：</p>
<p>
<p><span class="math display">\[
\begin{align*}
p_{n}^{\sigma} &amp;=\sigma(p_{n}) \quad(n \geqslant 0) \nonumber \\
(\neg \psi)^{\sigma} &amp;=f_{\neg}(\psi^{\sigma}) \\
(\psi \odot \chi)^{\sigma} &amp;=f_{\odot}(\psi^{\sigma}, \chi^{\sigma}) \quad(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace)\nonumber
\end{align*}
\]</span></p>
</p>
<p>现在应该容易看出，这些真值函数正是
<span class="math inline">\(\neg, \wedge, \vee, \rightarrow, \leftrightarrow\)</span>
这几个真值联结词的语义解释。比如，对于公式 <span class="math inline">\(p \lor q\)</span> 来说，<span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>
各自都既可以解释为 1 也可以解释为 0，但 <span class="math inline">\(\lor\)</span>
却不可以随便解释——它的解释是固定的真值函数 <span class="math inline">\(f_\lor.\)</span>
类似地，<span class="math inline">\(\neg, \land, \rightarrow, \leftrightarrow\)</span>
的解释分别是固定的真值函数 <span class="math inline">\(f_{\neg}, f_{\land}, f_{\rightarrow}\)</span> 和
<span class="math inline">\(f_{\leftrightarrow}.\)</span></p>
<p>对每个 <span class="math inline">\(n &gt; 0\)</span>，<span class="math inline">\(n\)</span> 元真值函数共有 <span class="math inline">\(2^{2^n}\)</span> 个。比如，</p>
<p><bb>例 3.18</bb> 一元的真值函数有 4 个，见下表（易见
<span class="math inline">\(f_{\neg} = g_3\)</span>）：</p>
<p>
<p><span class="math display">\[
\begin{array}{c|cccc}
        x &amp; g_{1}(x) &amp; g_{2}(x) &amp; g_{3}(x) &amp; g_{4}(x) \\
        \hline 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 1 &amp; 0
\end{array}
\]</span></p>
</p>
<p><bb>例 3.19</bb> 二元的真值函数有 16 个，见下表（<span class="math inline">\(f_k\)</span> 表示
<span class="math inline">\(f_{k}(x,y), k =1,\cdots,16\)</span> ）：</p>
<p>
<p><span class="math display">\[
    \begin{array}{cc|cccccccccccccccc}
    x &amp; y &amp; f_{1} &amp; f_{2} &amp; f_{3} &amp; f_{4} &amp; f_{5} &amp; f_{6} &amp; f_{7} &amp; f_{8} &amp; f_{9} &amp; f_{10} &amp; f_{11} &amp; f_{12} &amp; f_{13} &amp; f_{14} &amp; f_{15} &amp; f_{16} \\
    \hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0
    \end{array}
\]</span></p>
</p>
<p>易见
<span class="math inline">\(f_{\lor}=f_2, f_{\rightarrow}=f_5, f_{\leftrightarrow}=f_7, f_{\land}=f_8.\)</span>
三元和四元的真值函数等依此类推。三元真值函数有 <span class="math inline">\(2^{2^3}=256\)</span>
个，而四元真值函数有 <span class="math inline">\(2^{2^4}=65536\)</span> 个，这里自然画不下它们的真值表。</p>
</div>
<div id="对部分命题变号的赋值" class="section level3" number="4.4.2">
<h3><span class="header-section-number">4.4.2</span> 对部分命题变号的赋值</h3>
<p>为了便于讨论，我们引入另一种赋值概念。这种赋值很像是真值指派，不过它只对给定的部分命题变号指派了真值，而对其他命题变号（如果有的话）没做任何指派。</p>
<p>对每个命题变号的非空集合 <span class="math inline">\(A\)</span>
我们定义「<span class="math inline">\(A\)</span>-公式」和「<span class="math inline">\(A\)</span>-赋值」如下。（「<span class="math inline">\(A\)</span>-公式」和「<span class="math inline">\(A\)</span>-赋值」等都不是流行的术语。）</p>
<p>{{% dtpc title=“☯定义 3.12 <span class="math inline">\(A\)</span>-公式” %}} 设
<span class="math inline">\(\varnothing \ne A \subseteq \mathbf{Pr}.\)</span> <span class="math inline">\(A\)</span>-公式是其中只出现属于 <span class="math inline">\(A\)</span>
的命题变号的 <span class="math inline">\(\mathscr{L}_0\)</span>-公式，其严格定义如下： &gt; 1. <span class="math inline">\(A\)</span>
中的毎个命题变号都是 <span class="math inline">\(A\)</span>-公式； &gt; 1. 如果 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 是
<span class="math inline">\(A\)</span>-公式，那么 <span class="math inline">\(\neg \varphi\)</span> 和 <span class="math inline">\((\varphi \odot \psi)\)</span> 都是
<span class="math inline">\(A\)</span>-公式，其中
<span class="math inline">\(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace;\)</span> &gt;
1. 只有这些是 <span class="math inline">\(A\)</span>-公式。 {{% /dtpc %}}</p>
<p>{{% dtpc title=“☯定义 3.13 <span class="math inline">\(A\)</span>-赋值” %}}
设<span class="math inline">\(\varnothing \ne A \subseteq \mathbf{Pr}.\)</span> 一个 <span class="math inline">\(A\)</span>-赋值是从 <span class="math inline">\(A\)</span> 到
<span class="math inline">\(\lbrace 1,0\rbrace\)</span> 的一个函数。 {{% /dtpc %}}</p>
<p>这里对命题变号集 <span class="math inline">\(A\)</span> 的限制只是「非空」，从而 <span class="math inline">\(A\)</span>
可以是有穷集也可以是无穷集，甚至可以就是
<span class="math inline">\(\mathbf{Pr}\)</span>（由此可知，真值指派都是 <span class="math inline">\(\mathbf{Pr}\)</span>-赋值）。但是，如果
<span class="math inline">\(A \ne \mathbf{Pr}\)</span>，我们把赋值称作对部分命题变号的赋值。下面是关于这个概念的一个有用事实：如果
<span class="math inline">\(A\)</span>
是出现在某个真值表中的所有命题变号的集合，那么该表中命题变号的每一个可能取值组合就是一个
<span class="math inline">\(A\)</span>-赋值。（参见§2.4.2（P.84）关于命题变号的可能取值组合的讨论。）</p>
<p>{{% dtpc title=“☯定义 3.14 <span class="math inline">\(A\)</span>-赋值的递归定义” %}} 设
<span class="math inline">\(\varnothing \ne A \subseteq \mathbf{Pr}\)</span>，并设 <span class="math inline">\(\tau\)</span> 为任意
<span class="math inline">\(A\)</span>-赋值。对所有的 <span class="math inline">\(A\)</span>-公式 <span class="math inline">\(\varphi\)</span>，我们用 <span class="math inline">\(\varphi^\tau\)</span>
表示「<span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(\tau\)</span> 下的值」。<span class="math inline">\(\varphi^\tau\)</span> 递归地定义如下：</p>
<p>
<p><span class="math display">\[\begin{align*}
    p^{\tau} &amp;=\tau(p) \quad(p \in A) \\
    (\neg \varphi)^{\tau} &amp;=f_{\neg}\left(\varphi^{\tau}\right) \\
    (\varphi \odot \psi)^{\tau} &amp;=f_{\odot}\left(\varphi^{\tau}, \psi^{\tau}\right) \quad(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace)
    \end{align*}\]</span></p>
</p>
<p>{{% /dtpc %}}</p>
<p>对比定义 3.14 和式 3.13 后很容易看出，<span class="math inline">\(A\)</span>-赋值只给出
<span class="math inline">\(A\)</span>-公式的真值，而真值指派给出所有 <span class="math inline">\(\mathscr{L}_0\)</span>-公式的真值，但仅就
<span class="math inline">\(A\)</span>-公式来说，这两个定义确定公式真值的方法是完全一样的。</p>
</div>
<div id="两种描述方式的等价性" class="section level3" number="4.4.3">
<h3><span class="header-section-number">4.4.3</span> 两种描述方式的等价性</h3>
<p>重言蕴涵等概念的严格定义和它们的真值表刻画有明显的区别。比如说重言式，按照它的严格定义，一公式是否重言式的问题涉及无穷多真值指派，每个真值指派又涉及无穷多命题变号的真值；而按照它的真值表刻画，一公式是否重言式的问题，却只涉及某个有穷的命题变号集合
<span class="math inline">\(A\)</span> 和有穷多个
<span class="math inline">\(A\)</span>-赋值。尽管如此，「严格定义」和「真值表刻画」在下述意义上是等价的：满足「严格定义」的一定满足「真值表刻画」，而满足「真值表刻画」的也一定满足「严格定义」。下面我们提供这种等价性的证明。</p>
<p>借助直观，人们会有以下猜测：</p>
<blockquote>
<p>一个公式 <span class="math inline">\(\varphi\)</span> 在一真值指派 <span class="math inline">\(\sigma\)</span> 下的值，应只与 <span class="math inline">\(\sigma\)</span>
指派给 <span class="math inline">\(\varphi\)</span> 中出现的命题变号的值有关，或者说，与 <span class="math inline">\(\sigma\)</span>
指派给其他命题变号的值无关。</p>
</blockquote>
<p>运用 <span class="math inline">\(A\)</span>-赋值的概念，我们可以将上述猜测表述为下述命题。</p>
<p>{{% dtpc title=“☯命题 3.11” %}} 设
<span class="math inline">\(\varnothing \ne A \subseteq \mathbf{Pr}\)</span>，设 <span class="math inline">\(\sigma\)</span>
为任意真值指派，并设 <span class="math inline">\(\tau\)</span> 为任意 <span class="math inline">\(A\)</span>-赋值，满足对每个
<span class="math inline">\(p \in A, \tau(p) = \sigma(p).\)</span> 那么，对所有的 <span class="math inline">\(A\)</span>-公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi^\sigma = \varphi^\tau.\)</span> {{% /dtpc %}}</p>
<p><bb>证明：</bb>施归纳于公式的复杂度，我们证明对每个 <span class="math inline">\(A\)</span>-公式
<span class="math inline">\(\varphi, \varphi^{\sigma}=\varphi^{\tau}.\)</span></p>
<p><bb>归纳基始</bb>：<span class="math inline">\(\varphi=p \in A.\)</span> 由题设知 <span class="math inline">\(\sigma(p)=\tau(p)\)</span>，即
<span class="math inline">\(\varphi^{\sigma}=\varphi^{\tau}.\)</span></p>
<p><bb>归纳步骤</bb>：设 <span class="math inline">\(\varphi=\neg \psi.\)</span> 由归纳假设知
<span class="math inline">\(\psi^{\sigma}=\psi^{\tau}\)</span>，于是根据 式 3.13 和定义 3.14 得到
<span class="math display">\[(\neg \psi)^{\sigma}=f_{\neg}\left(\psi^{\sigma}\right)=f_{\neg}\left(\psi^{\tau}\right)=(\neg \psi)^{\tau}\]</span>
设
<span class="math inline">\(\varphi=\psi \odot \chi(\odot \in\lbrace \vee, \wedge, \rightarrow, \leftrightarrow\rbrace).\)</span>
由归纳假设知 <span class="math inline">\(\psi^{\sigma}=\psi^{\tau}\)</span> 且
<span class="math inline">\(\chi^{\sigma}=\chi^{\tau}\)</span>，再根据式 3.13 和定义 3.14，我们有
<span class="math display">\[(\psi \odot \chi)^{\sigma}=f_{\odot}\left(\psi^{\sigma}, \chi^{\sigma}\right)=f_{\odot}\left(\psi^{\tau}, \chi^{\tau}\right)=(\psi \odot \chi)^{\tau}\]</span>
由此我们证明了，对每个 <span class="math inline">\(A\)</span>-公式 <span class="math inline">\(\varphi\)</span> 都有
<span class="math inline">\(\varphi^{\sigma}=\varphi^{\tau}.\)</span> ▗</p>
<p>命题 3.11 是对前述猜测的一种表述，其中使用了
<span class="math inline">\(A\)</span>-赋值这一概念。如果不用这个概念，我们可以将前述猜测表述为下述命题。</p>
<p>{{% dtpc title=“☯命题 3.12” %}} 设
<span class="math inline">\(\varnothing \neq A \subseteq \mathbf{Pr}\)</span>，并设 <span class="math inline">\(\sigma\)</span> 和
<span class="math inline">\(\sigma^{\prime}\)</span> 为任意真值指派，满足对每个
<span class="math inline">\(p \in A, \sigma(p)=\sigma^{\prime}(p).\)</span> 那么，对所有的 <span class="math inline">\(A\)</span>-公式
<span class="math inline">\(\varphi\)</span>，<span class="math inline">\(\varphi^{\sigma} = \varphi^{\sigma^{\prime}}.\)</span> {{% /dtpc %}}</p>
<p><bb>证明：</bb>令 <span class="math inline">\(\tau\)</span> 为 <span class="math inline">\(\sigma\)</span> 限制到 <span class="math inline">\(A\)</span> 的结果。（设 <span class="math inline">\(f\)</span> 为从
<span class="math inline">\(X\)</span> 到 <span class="math inline">\(Y\)</span> 的任意函数，并设 <span class="math inline">\(Z \subseteq X.\)</span> 将 <bb><span class="math inline">\(f\)</span> 限制到 <span class="math inline">\(Z\)</span>
的结果</bb>是从 <span class="math inline">\(Z\)</span> 到 <span class="math inline">\(Y\)</span> 的函数 <span class="math inline">\(g\)</span>，满足对每一个 <span class="math inline">\(x \in Z\)</span> 都有
<span class="math inline">\(g(x) = f(x).\)</span>）对每个 <span class="math inline">\(A\)</span>-公式 <span class="math inline">\(\varphi\)</span>，由题设和命题 3.11 知
<span class="math inline">\(\varphi^{\sigma}=\varphi^{\tau}\)</span>，再次运用题设和命题 3.11 即有
<span class="math inline">\(\varphi^{\tau}=\varphi^{\sigma^{\prime}}\)</span>，所以
<span class="math inline">\(\varphi^{\sigma}=\varphi^{\sigma^{\prime}}.\)</span> ▗</p>
<p>为了证明命题 3.12（尤其是在没引入 <span class="math inline">\(A\)</span>-赋值概念的情况下），可以像证明命题
3.11
那样，施归纳于公式的复杂度，完成归纳基始和一个个归纳步骤。但是，直接应用命题
3.11 显然使命题 3.12
的证明更简单。在基本概念清楚之后，注意已证明的命题或定理，避免事事「从头做起」。</p>
<p>设 <span class="math inline">\(\tau\)</span> 为任意 <span class="math inline">\(A\)</span>-赋值，<span class="math inline">\(\Gamma\)</span> 为任意
<span class="math inline">\(A\)</span>-公式集。<span class="math inline">\(\tau \vDash \Gamma\)</span> 当且仅当对每个 <span class="math inline">\(\varphi \in \Gamma\)</span>
都有 <span class="math inline">\(\varphi^\tau = 1.\)</span> 类似地，我们用 <span class="math inline">\(\tau \vDash \varphi\)</span> 表示
<span class="math inline">\(\tau \vDash \lbrace \varphi\rbrace\)</span>，并用丁 <span class="math inline">\(\tau \nvDash \Gamma\)</span> 和
<span class="math inline">\(\tau \nvDash \varphi\)</span> 分别表示 <span class="math inline">\(\tau \vDash \Gamma\)</span> 和
<span class="math inline">\(\tau \vDash \varphi\)</span> 不成立。</p>
<p>运用命题
3.11，可以轻松地证明下述命题，其中的「重言蕴涵」和「重言式」等，都是在「严格定义」的意义上使用的。</p>
<p>{{% dtpc title=“☯命题 3.13” %}} 设
<span class="math inline">\(\varnothing \ne A \subseteq \mathbf{Pr}\)</span>，设 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
为任意的 <span class="math inline">\(A\)</span>-公式，并设 <span class="math inline">\(\Gamma\)</span> 为任意的<span class="math inline">\(A\)</span>-公式集。我们有：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span> 当且仅当对所有的 <span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span>，如果
<span class="math inline">\(\tau \vDash \Gamma\)</span> 则 <span class="math inline">\(\tau \vDash \varphi;\)</span><br />
</li>
<li><span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值当且仅当对每个 <span class="math inline">\(A\)</span>-赋值
<span class="math inline">\(\tau, \varphi^{\tau}=\psi^{\tau};\)</span></li>
<li><span class="math inline">\(\Gamma\)</span> 是可满足的当且仅当存在 <span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span> 使得
<span class="math inline">\(\tau \vDash \Gamma;\)</span></li>
<li><span class="math inline">\(\varphi\)</span> 是重言式当且仅当对每个 <span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span> 都有
<span class="math inline">\(\varphi^{\tau}=1;\)</span></li>
<li><span class="math inline">\(\varphi\)</span> 是矛盾式当且仅当对每个 <span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span> 都有
<span class="math inline">\(\varphi^{\tau}=0;\)</span></li>
<li><span class="math inline">\(\varphi\)</span> 是或然式当且仅当存在 <span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span> 和 <span class="math inline">\(\tau^{\prime}\)</span>
使得 <span class="math inline">\(\varphi^{\tau}=1\)</span> 且 <span class="math inline">\(\varphi^{\tau^{\prime}}=0.\)</span>
{{% /dtpc %}}</li>
</ol>
<p><bb>证明：</bb>我们证明：<span class="math inline">\(\Gamma \nvDash_{0} \varphi\)</span> 当且仅当存在一个
<span class="math inline">\(A\)</span>-赋值 <span class="math inline">\(\tau\)</span> 使得 <span class="math inline">\(\tau \vDash \Gamma\)</span> 且 $ .$
设 <span class="math inline">\(\Gamma \nvDash_{0} \varphi.\)</span> 根据定义 3.3，存在一个真值指派 <span class="math inline">\(\sigma\)</span>
使得 <span class="math inline">\(\sigma \vDash \Gamma\)</span> 且 <span class="math inline">\(\sigma \nvDash \varphi.\)</span> 令 <span class="math inline">\(\tau\)</span> 为
<span class="math inline">\(\sigma\)</span> 限制到 <span class="math inline">\(A\)</span> 的结果。显然 <span class="math inline">\(\tau\)</span> 是个 <span class="math inline">\(A\)</span>-赋值，而根据命题
3.11，<span class="math inline">\(\tau \vDash \Gamma\)</span> 且 <span class="math inline">\(\tau \nvDash \varphi.\)</span> 反之，设存在 <span class="math inline">\(A\)</span>
-赋值 <span class="math inline">\(\tau\)</span>，满足 <span class="math inline">\(\tau \vDash \Gamma\)</span> 且 <span class="math inline">\(\tau \nvDash \varphi.\)</span> 令
<span class="math inline">\(\sigma\)</span> 为这样一个真值指派：对每个
<span class="math inline">\(p \in A\)</span>，<span class="math inline">\(\sigma(p)=\tau(p)\)</span>，并且对每个命题变号
<span class="math inline">\(q \notin A, \sigma(q)=0.\)</span> 根据命题 3.11，<span class="math inline">\(\sigma \vDash \Gamma\)</span> 且
<span class="math inline">\(\sigma \nvDash \varphi\)</span>，所以由定义 3.3 <span class="math inline">\(\Gamma \nvDash_{0} \varphi.\)</span> ▗</p>
<p>命题 3.13 其他条目的证明都与上述证明类似，都留作练习（见习题 3.19）。</p>
<p>如果把 <span class="math inline">\(\Gamma\)</span> 限制为有穷集，并把 <span class="math inline">\(A\)</span> 限制为 <span class="math inline">\(\Gamma\)</span> 和 <span class="math inline">\(\varphi\)</span>
中（或 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 中）出现的命题变号的集合，那么命题 3.13
说的正是重言蕴涵等语义概念的严格定义等价于它们的真值表刻画。至此我们完成了对这一等价性的证明。不过，因为命题
3.11-3.13 中的 <span class="math inline">\(\Gamma\)</span> 和 <span class="math inline">\(A\)</span>
都可以是无穷集，所以这些命题比上述等价性更具一般性。</p>
<p>下述命题是命题 3.13 的一个简单应用。（注意对比命题 3.7）</p>
<p>{{% dtpc title=“☯命题 3.14” %}} 令 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
为任意不含相同命题变号的公式。我们有：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi\lor \psi\)</span> 是重言式当且仅当或者 <span class="math inline">\(\varphi\)</span> 是重言式或者
<span class="math inline">\(\psi\)</span> 是重言式。</li>
<li><span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式当且仅当或者 <span class="math inline">\(\varphi\)</span>
是矛盾式或者 <span class="math inline">\(\psi\)</span> 是重言式。</li>
<li><span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式当且仅当或者 <span class="math inline">\(\varphi\)</span> 和
<span class="math inline">\(\psi\)</span> 都是矛盾式或者 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 都是重言式。 {{% /dtpc %}}</li>
</ol>
<p><bb>证明：</bb>根据命题 3.7条目一，只需假设 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
都不是重言式，而证明 <span class="math inline">\(\varphi\lor \psi\)</span>
不是重言式。根据假设，存在真值指派 <span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\sigma^\prime\)</span>，使得
<span class="math inline">\(\sigma \nvDash \varphi\)</span> 并且 <span class="math inline">\(\sigma^\prime \nvDash \varphi\)</span>。令
<span class="math inline">\(\sigma^*\)</span> 为满足下述条件的任意真值指派：</p>
<p>
<p><span class="math display">\[
\sigma^{*}(p)=\left\lbrace \begin{array}{ll}
\sigma(p) &amp; \text{如果~} p \text{~出现在~} \varphi \text{~中} \\
\sigma^{\prime}(p) &amp; \text{如果~} p \text{~出现在~} \psi \text{~中}
\end{array}\right.
\]</span></p>
</p>
<p>由于 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>
不含相同的命题变号，易见满足上述条件的真值指派是存在的，于是根据命题
3.12，<span class="math inline">\(\sigma^* \nvDash \varphi\)</span> 并且 <span class="math inline">\(\sigma^* \nvDash \psi\)</span>，进而
<span class="math inline">\(\sigma^* \nvDash \varphi \lor \psi.\)</span> ▗</p>
<p>命题  中的另外两条留作练习（见习题 3.20）</p>
</div>
</div>
<div id="范式" class="section level2" number="4.5">
<h2><span class="header-section-number">4.5</span> 范式</h2>
<p>范式是具有某种特殊形式的公式，这种特殊形式帮助我们认识公式的一些性质和关系，而且在机器证明中也有应用。</p>
<div id="合取范式" class="section level3" number="4.5.1">
<h3><span class="header-section-number">4.5.1</span> 合取范式</h3>
<p>一个公式是<bb>合取范式</bb>（of conjunctive normal form）如果它形如
<span class="math inline">\(\varphi_0 \land \cdots \land \varphi_n\)</span> 并且对每一个
<span class="math inline">\(i \leqslant n\)</span>，<span class="math inline">\(\varphi_i\)</span> 形如
<span class="math inline">\(\psi_0 \lor \cdots \lor \psi_{m_{i}}\)</span>，其中每个
<span class="math inline">\(\psi_j (j \leqslant m_{i})\)</span>
都或是命题变号，或是命题变号的否定。粗略地说，合取范式是个合取式，而其合取支都是命题变号或其否定的析取式。（Wang［1981］中把命题变号或其否定的析取式称作「简单析取」。）对所有公式
<span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>，<span class="math inline">\(\psi\)</span> 是 <span class="math inline">\(\varphi\)</span>
的合取范式当且仅当下列条件成立：</p>
<blockquote>
<p><span class="math inline">\(\psi\)</span> 是合取范式， <span class="math inline">\(\psi\)</span> 与 <span class="math inline">\(\varphi\)</span> 重言等值。</p>
</blockquote>
<p><bb>例 3.20 下列公式都是合取范式</bb> &gt; <span class="math inline">\(p\)</span> &gt; <span class="math inline">\(\neg p \lor q\)</span> &gt;
<span class="math inline">\(p \land \neg q \land r \land \neg p\)</span> &gt; <span class="math inline">\((p \lor \neg q) \land \neg p\)</span>
&gt; <span class="math inline">\((p \lor \neg q) \land(\neg p \lor r \lor q) \land(p \lor \neg r)\)</span></p>
<p>注意：合取范式定义中的 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m_i\)</span>
等可以是任何自然数，并且它们之间可以没有任何关系。单个命题变号 <span class="math inline">\(p\)</span>
之所以是合取范式，是因为合取范式的定义允许 <span class="math inline">\(n = 0\)</span> 且 <span class="math inline">\(m_0 = 0\)</span>
的情况。<span class="math inline">\(\neg p \lor q\)</span> 是 <span class="math inline">\(n = 0\)</span> 且 <span class="math inline">\(m_0 = 1\)</span> 时的情况，而
<span class="math inline">\(p \land \neg q \land r \land \neg p\)</span> 是 <span class="math inline">\(n = 3\)</span> 且 <span class="math inline">\(m_0,\cdots,m_3 = 0\)</span>
时的情况。</p>
<p><bb>例 3.21 下列编号公式是对应无编号公式的合取范式</bb> &gt; -
<span class="math inline">\(p \rightarrow q\)</span> &gt; - <span class="math inline">\(\neg q \rightarrow \neg p\)</span> &gt; -
<span class="math inline">\(p \rightarrow q\)</span> &gt; - <span class="math inline">\(p \wedge q \rightarrow r\)</span> &gt; -
<span class="math inline">\(\neg(p \wedge r \rightarrow \neg q)\)</span> &gt; - <span class="math inline">\(p \vee q \rightarrow \neg r\)</span>
&gt; 1. <span class="math inline">\(\neg p \vee q\)</span> &gt; 1. <span class="math inline">\(\neg p \vee q\)</span> &gt; 1. <span class="math inline">\(q \vee \neg p\)</span> &gt; 1.
<span class="math inline">\(\neg p \vee \neg q \vee r\)</span> &gt; 1. <span class="math inline">\(p \wedge q \wedge r\)</span> &gt; 1.
<span class="math inline">\((\neg p \vee \neg r) \wedge(\neg q \vee \neg r)\)</span></p>
<p>易见：不同的公式可以有相同的合取范式，而同一个公式也可以有不同的合取范式。</p>
</div>
<div id="析取范式" class="section level3" number="4.5.2">
<h3><span class="header-section-number">4.5.2</span> 析取范式</h3>
<p>—个公式是<bb>析取范式</bb>（of disjunctive normal form）如果它形如
<span class="math inline">\(\varphi_0 \lor \cdots \lor \varphi_n\)</span> 并且对每一个
<span class="math inline">\(i \leqslant n\)</span>，<span class="math inline">\(\varphi_i\)</span> 形如
<span class="math inline">\(\psi_0 \land \cdots \land \psi_{m_{i}}\)</span>，其中每个
<span class="math inline">\(\psi_j (j \leqslant m_{i})\)</span>
都或是命题变号，或是命题变号的否定。粗略地说，析取范式是个析取式，而其析取支都是命题变号或其否定的合取式。对所有公式
<span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span>，<span class="math inline">\(\psi\)</span> 是 <span class="math inline">\(\varphi\)</span>
的析取范式当且仅当下列条件成立：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\psi\)</span> 是析取范式，</li>
<li><span class="math inline">\(\psi\)</span> 与 <span class="math inline">\(\varphi\)</span> 重言等值。</li>
</ol>
</blockquote>
<p><bb>例 3.22 下列公式都是析取范式</bb> &gt; 1. <span class="math inline">\(p\)</span> &gt; 1. <span class="math inline">\(\neg p \lor q\)</span> &gt;
1. <span class="math inline">\(p \land \neg q \land r \land \neg p\)</span> &gt; 1.
<span class="math inline">\((p \lor \neg q) \lor \neg p\)</span> &gt; 1.
<span class="math inline">\((p \land \neg q) \lor (\neg p \land r \land q) \land(p \land \neg r)\)</span></p>
<p>与前面的说明类似，<span class="math inline">\(p\)</span> 之所以是析取范式，是因为析取范式的定义允许 <span class="math inline">\(n = 0\)</span>
且 <span class="math inline">\(m_0 = 0\)</span> 的情况。<span class="math inline">\(\neg p \lor q\)</span> 是 <span class="math inline">\(n = 1\)</span> 且 <span class="math inline">\(m_0, m_1 = 0\)</span>
时的情况，而 <span class="math inline">\(p \land \neg q \land r \land \neg p\)</span> 是 <span class="math inline">\(n = 0\)</span> 且
<span class="math inline">\(m_0 = 3\)</span> 时的情况。</p>
<p><bb>例 3.23 下列编号公式是对应无编号公式的析取范式</bb> &gt; -
<span class="math inline">\(p \rightarrow q\)</span> &gt; - <span class="math inline">\(\neg q \rightarrow \neg p\)</span> &gt; -
<span class="math inline">\(p \rightarrow q\)</span> &gt; - <span class="math inline">\(p \wedge q \rightarrow r\)</span> &gt; -
<span class="math inline">\(\neg(p \wedge r \rightarrow \neg q)\)</span> &gt; - <span class="math inline">\(p \vee q \rightarrow \neg r\)</span>
&gt; 1. <span class="math inline">\(\neg p \vee q\)</span> &gt; 1. <span class="math inline">\(\neg p \vee q\)</span> &gt; 1. <span class="math inline">\(q \vee \neg p\)</span> &gt; 1.
<span class="math inline">\(\neg p \vee \neg q \vee r\)</span> &gt; 1. <span class="math inline">\(p \wedge q \wedge r\)</span> &gt; 1.
<span class="math inline">\((\neg p \land \neg r) \lor \neg r\)</span></p>
<p>易见：不同的公式可以有相同的析取范式，而同一个公式也可以有不同的析取范式。比较例
3.20 和例 3.22 以及例 3.21 和例
3.23，可知一个公式的析取范式与它的合取范式也可以是同一个公式。读者应对照定义，检查上述例子中的合取范式和析取范式，以求准确把握范式的概念。</p>
</div>
<div id="范式定理" class="section level3" number="4.5.3">
<h3><span class="header-section-number">4.5.3</span> 范式定理</h3>
<p>由于范式在形式方面的特点，很多时候处理范式比处理一般公式要容易。比如，要确定一个合取范式
<span class="math inline">\(\varphi_0 \land \cdots \land \varphi_n\)</span> 是否重言式，我们只需看每一个
<span class="math inline">\(\varphi_i(i \leqslant n)\)</span>
中是否都有某个命题变号及其否定。满足这一条件的就是重言式，不满足的就不是重言式。类似地，要判断一个析取范式
<span class="math inline">\(\varphi_0 \lor \cdots \lor \varphi_n\)</span> 是否矛盾式，我们只需看每一个
<span class="math inline">\(\varphi_i(i \leqslant n)\)</span>
中是否都有某个命题变号及其否定。满足这一条件的就是矛盾式，不满足的就不是矛盾式。参见命题
3.7。</p>
<p>如果每个公式都有它的合取范式和析取范式，那么很多关于公式的问题就可以归结为范式的问题，从而降低解决这些问题的难度。事实上，每一个公式都既有它的合取范式也有它的析取范式。我们先来看公式的析取范式的存在问题。</p>
<p>{{% dtpc title=“☯定理 3.2【析取范式存在定理】” %}}
任何公式都有析取范式，亦即对每个公式 <span class="math inline">\(\varphi\)</span>，存在一个公式
<span class="math inline">\(\varphi^{\prime}\)</span> 使得 <span class="math inline">\(\varphi^{\prime}\)</span> 是析取范式并与 <span class="math inline">\(\varphi\)</span>
重言等值。 {{% /dtpc %}}</p>
<p>这个命题有时被称作<tt>析取范式存在定理</tt>。我们这里不做严格的证明，只给出找到任给公式的析取范式的一个方法。对证明有兴趣的读者可以参照命题117的证明试着给出这个命题的证明。（参见习题
3.22）</p>
<p>考虑任意公式 <span class="math inline">\(\varphi.\)</span> 设 <span class="math inline">\(\varphi\)</span> 中出现的命题变号为
<span class="math inline">\(q_0,\cdots,q_{n-1}\)</span>，并令 <span class="math inline">\(A = \lbrace q_0,\cdots,q_{n-1}\rbrace.\)</span>
我们知道，<span class="math inline">\(A\)</span>-赋值（亦即 <span class="math inline">\(q_0,\cdots,q_{n-1}\)</span> 的可能取值组合）总共有
<span class="math inline">\(2^n\)</span> 个。如果 <span class="math inline">\(\varphi\)</span> 是矛盾式，我们令
<span class="math inline">\(\varphi^{\prime} = q_0 \land \neg q_0 \land q_1 \land \cdots \land q_{n-1}.\)</span>（<span class="math inline">\(\varphi^{\prime}\)</span>
的选择有多种。我们这里选择的是的 <span class="math inline">\(q_0,\cdots,q_{n-1}\)</span>
都出现的、尽可能简单的和矛盾的析取范式。）</p>
<p>易见 <span class="math inline">\(\varphi^{\prime}\)</span> 是析取范式并与 <span class="math inline">\(\varphi\)</span> 重言等值。假设
<span class="math inline">\(\varphi\)</span> 不是矛盾式，并设 <span class="math inline">\(\tau_{0}, \cdots, \tau_{k} (k&lt;2^{n})\)</span> 为使得
<span class="math inline">\(\varphi\)</span> 的值为 1 的全部 <span class="math inline">\(A\)</span>-赋值。对每个 $i k $ 和每个
<span class="math inline">\(j &lt; n\)</span>，定义 <span class="math inline">\(\theta_{j}^{i}\)</span> 如下：</p>
<p>
<p><span class="math display">\[
\theta_{j}^{i}=\left\lbrace \begin{array}{ll}
q_{j} &amp; \text { 如果 }~ \tau_{i}\left(q_{j}\right)=1 \\
\neg q_{j} &amp; \text { 如果 }~ \tau_{i}\left(q_{j}\right)=0
\end{array}\right.
\]</span></p>
</p>
<p>并且对每个 <span class="math inline">\(i \leqslant k\)</span>，定义
<span class="math inline">\(\psi_{i}=\theta_{0}^{i} \wedge \cdots \wedge \theta_{n-1}^{i}.\)</span> 最后令
<span class="math inline">\(\varphi^{\prime}=\psi_{0} \vee \cdots \vee \psi_{k}.\)</span> 易见
<span class="math inline">\(\varphi^{\prime}\)</span> 是析取范式，并且可以证明 <span class="math inline">\(\varphi^{\prime}\)</span> 与
<span class="math inline">\(\varphi\)</span> 重言等值。</p>
<p><bb>例 3.24</bb> 求公式 <span class="math inline">\((p \rightarrow q) \rightarrow q \land \neg r\)</span>
的析取范式。 <bb>解：</bb>令
<span class="math inline">\(\varphi = (p \rightarrow q) \rightarrow q \land \neg r.\)</span> <span class="math inline">\(\varphi\)</span>
的真值表如下：</p>
<p>
<p><span class="math display">\[
\begin{array}{ccc|c|l}
p &amp; q &amp; r &amp; (p \rightarrow q) \rightarrow q \wedge \neg r &amp; \text{令}\\
\hline 1 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\
1 &amp; 1 &amp; 0 &amp; ~~1 &amp; \psi_{1}=p \wedge q \wedge \neg r\\
1 &amp; 0 &amp; 1 &amp; ~~1 &amp; \psi_{2}=p \wedge \neg q \wedge r\\
1 &amp; 0 &amp; 0 &amp; ~~1 &amp; \psi_{3}=p \wedge \neg q \wedge \neg r\\
0 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\
0 &amp; 1 &amp; 0 &amp; ~~1 &amp; \psi_{4}=\neg p \wedge q \wedge \neg r\\
0 &amp; 0 &amp; 1 &amp; ~~0 &amp; \\
0 &amp; 0 &amp; 0 &amp; ~~0 &amp;
\end{array}
\]</span></p>
</p>
<p>最后令
<span class="math inline">\(\varphi^{\prime}=\psi_{1} \vee \psi_{2} \vee \psi_{3} \vee \psi_{4}\)</span>，亦即
<span class="math display">\[\varphi^{\prime}=(p \wedge q \wedge \neg r) \vee(p \wedge \neg q \wedge r) \vee(p \wedge \neg q \wedge \neg r) \vee(\neg p \wedge q \wedge \neg r).\]</span></p>
<p>可以证明，<span class="math inline">\(\varphi^{\prime}\)</span> 是 <span class="math inline">\(\varphi\)</span> 的一个析取范式。</p>
<p>下面我们来看公式的合取范式的存在问题。</p>
<p>{{% dtpc title=“☯定理 3.3【合取范式存在定理】” %}}
任何公式都有合取范式，亦即对每个公式 <span class="math inline">\(\varphi\)</span>，存在一个公式
<span class="math inline">\(\varphi^{\prime}\)</span> 使得 <span class="math inline">\(\varphi^{\prime}\)</span> 是合取范式并与 <span class="math inline">\(\varphi\)</span>
重言等值。 {{% /dtpc %}}</p>
<p>这个命题有时被称作<tt>合取范式存在定理</tt>。与上述类似，我们这里不做严格的证明，只给出找到任给公式的合取范式的一个方法。（参见习题
3.22）</p>
<p>考虑任意公式 <span class="math inline">\(\varphi.\)</span> 设 <span class="math inline">\(\varphi\)</span> 中出现的命题变号为
<span class="math inline">\(q_0,\cdots,q_{n-1}\)</span>，并令 <span class="math inline">\(A = \lbrace q_0,\cdots,q_{n-1}\rbrace.\)</span> 如果
<span class="math inline">\(\varphi\)</span> 是重言式，我们令
<span class="math inline">\(\varphi^{\prime} = q_0 \lor \neg q_0 \lor q_1 \lor \cdots \lor q_{n-1}.\)</span>（<span class="math inline">\(\varphi^{\prime}\)</span>
的选择有多种。我们这里选择的是的 <span class="math inline">\(q_0,\cdots,q_{n-1}\)</span>
都出现的、尽可能简单的和重言的合取范式。）易见 <span class="math inline">\(\varphi^{\prime}\)</span>
是合取范式并与 <span class="math inline">\(\varphi\)</span> 重言等值。假设 <span class="math inline">\(\varphi\)</span> 不是重言式，并设
<span class="math inline">\(\tau_{0}, \cdots, \tau_{k} (k&lt;2^{n})\)</span> 为使得 <span class="math inline">\(\varphi\)</span> 的值为 0 的全部
<span class="math inline">\(A\)</span>-赋值。对每个 <span class="math inline">\(i \leqslant k\)</span> 和每个 <span class="math inline">\(j &lt; n\)</span>，定义 <span class="math inline">\(\theta_{j}^{i}\)</span>
如下：</p>
<p>
<p><span class="math display">\[
    \theta_{j}^{i}=\left\lbrace \begin{array}{ll}
    q_{j} &amp; \text { 如果 }~ \tau_{i}\left(q_{j}\right)=0 \\
    \neg q_{j} &amp; \text { 如果 }~ \tau_{i}\left(q_{j}\right)=1
    \end{array}\right.
\]</span></p>
</p>
<p>并且对每个 <span class="math inline">\(i \leqslant k\)</span>，定义
<span class="math inline">\(\psi_{i}=\theta_{0}^{i} \lor \cdots \lor \theta_{n-1}^{i}.\)</span> 最后令
<span class="math inline">\(\varphi^{\prime}=\psi_{0} \land \cdots \land \psi_{k}.\)</span> 易见
<span class="math inline">\(\varphi^{\prime}\)</span> 是合取范式，并且可以证明 <span class="math inline">\(\varphi^{\prime}\)</span> 与
<span class="math inline">\(\varphi\)</span> 重言等值。</p>
<p><bb>例 3.25</bb> 求公式 <span class="math inline">\((p \rightarrow q) \rightarrow q \land \neg r\)</span>
的析取范式。 <bb>解：</bb>令
<span class="math inline">\(\varphi = (p \rightarrow q) \rightarrow q \land \neg r.\)</span> <span class="math inline">\(\varphi\)</span>
的真值表如下：</p>
<p>
<p><span class="math display">\[
        \begin{array}{ccc|c|l}
        p &amp; q &amp; r &amp; (p \rightarrow q) \rightarrow q \wedge \neg r &amp; \text{令}\\
        \hline 1 &amp; 1 &amp; 1 &amp; ~~0 &amp; \psi_{1}=\neg p \lor \neg q \lor \neg r\\
        1 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\
        1 &amp; 0 &amp; 1 &amp; ~~1 &amp; \\
        1 &amp; 0 &amp; 0 &amp; ~~1 &amp; \\
        0 &amp; 1 &amp; 1 &amp; ~~0 &amp; \psi_{2}=p \lor \neg q \lor \neg r\\
        0 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\
        0 &amp; 0 &amp; 1 &amp; ~~0 &amp; \psi_{3}=p \lor  q \lor \neg r\\
        0 &amp; 0 &amp; 0 &amp; ~~0 &amp; \psi_{4}=p \lor q \lor r
        \end{array}
\]</span></p>
</p>
<p>最后令
<span class="math inline">\(\varphi^{\prime}=\psi_{1} \land \psi_{2} \land \psi_{3} \land \psi_{4}\)</span>，亦即
<span class="math display">\[\varphi^{\prime}=(\neg p \lor \neg q \lor \neg r) \land (p \lor \neg q \lor \neg r) \land (p \lor  q \lor \neg r) \land (p \lor q \lor r).\]</span></p>
<p>可以证明，<span class="math inline">\(\varphi^{\prime}\)</span> 是 <span class="math inline">\(\varphi\)</span> 的一个析取范式。</p>
<p>在上面讲解公式的范式存在问题时，我们使用了真值表方法，即<tt>语义的方法</tt>。假如我们求公式的范式仅仅是要判断给定公式是否重言式（或矛盾式），那么用上述方法求范式无疑是事倍功半。这是因为，在写出给定公式的范式之前，我们先构造了该公式的真值表，而从这个真值表我们已经知道该公式是否重言式（或矛盾式）。不过，上面的讲解只是说明任何公式都存在合取范式和析取范式，而且只是用我们已经学会的真值表方法。事实上，求范式的方法不仅是语义的方法，而范式的存在问题也并不就是判断重言式或矛盾式的问题。</p>
</div>
</div>
<div id="函数完全性" class="section level2" number="4.6">
<h2><span class="header-section-number">4.6</span> 函数完全性</h2>
<div id="真值函数在形式语言中的表达" class="section level3" number="4.6.1">
<h3><span class="header-section-number">4.6.1</span> 真值函数在形式语言中的表达</h3>
<p>显然，真值函数可以有无穷多。在如此多的函数中，有些明显可以用其他真值函数来合成或复合（compose）。比如示例
3.19 中的 <span class="math inline">\(f_{16}\)</span> 显然可以用 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_\neg\)</span> 来合成，亦即
<span class="math inline">\(f_{16}(x,y)=f_{\neg}(f_{1}(x,y))\)</span>。那么，有没有一集真值函数（最好不要太多）可以合成<tt>所有</tt>的真值函数？如果有，哪些真值函数集可以合成所有的真值函数？简单地说，这就是「函数完全性」问题。</p>
<p>这样的问题当然是数学问题。我们寻找数学问题的解，部分地是因为它们往往有解。但我们关心函数完全性问题决不仅仅是因为它有解或很可能有解。函数完全性问题和形式语言的「表达力」有直接关系。<span class="math inline">\(\mathscr{L}_0\)</span>-公式能表达什么？让我们来看两个例子。</p>
<p>先看公式 <span class="math inline">\(p \lor q.\)</span> 当考虑公式的值时，命题变号 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是取值于
<span class="math inline">\(\lbrace 0, 1\rbrace\)</span> 的变元，而一旦它们的取值确定了，<span class="math inline">\(p \lor q\)</span>
的值（真值）也就经 <span class="math inline">\(f_\lor\)</span> 唯一地确定了。在这个意义上，我们说
<span class="math inline">\(p \lor q\)</span> 表达了真值函数
<span class="math inline">\(f_\lor.\)</span>（假如我们一开始就把所有的析取式都写成 <span class="math inline">\(\lor (\varphi, \psi)\)</span>
的样子，那么 <span class="math inline">\(\lor (p, q)\)</span> 和 <span class="math inline">\(f_{\lor}(x,y)\)</span> 即使在形式上也非常接近。）</p>
<p>再来看公式 <span class="math inline">\((p \lor q) \land \neg(p \land q)\)</span>，我们可以把它记为
<span class="math inline">\(p \veebar q.\)</span> <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 的取值（真值）一旦确定，<span class="math inline">\(p \veebar q\)</span>
的值（真值）也就经 <span class="math inline">\(f_{\lor}, f_{\land}\)</span> 和 <span class="math inline">\(f_{\neg}\)</span>
的某种复合（当然也是一个真值函数）唯一地确定了（参见式子 3.13
中第二和第三行）。在这个意义上，我们说 <span class="math inline">\(p \veebar q\)</span>
表达了一个真值函数。事实上，<span class="math inline">\(\veebar\)</span>
可以被当作一个真值函数联结词，即通常被称为「不相容析取」的联结词（the
exclusive <bb>or</bb>，XOR），它的解释是示例 3.19 中的
<span class="math inline">\(f_{10}\)</span>，而这个函数显然可由 <span class="math inline">\(f_{\lor}, f_{\land}\)</span> 和 <span class="math inline">\(f_{\neg}\)</span>
来合成：<span class="math inline">\(f_{10}(x, y)=f_{\land}(f_{\lor}(x, y), f_{\neg}(f_{\land}(x, y))).\)</span>（参见
§12.2.1（P.198）中对「不相容选言推理」的介绍。）</p>
<p>下面我们来严格地定义
<span class="math inline">\(\mathscr{L}_0\)</span>-公式对真值函数的表达。在这一节中，凡谈到命题变号
<span class="math inline">\(q_0, \cdots, q_n\)</span> 时，我们总是假定它们是不同的命题变号，并且对所有
<span class="math inline">\(i, j \leqslant n\)</span> 如果 <span class="math inline">\(i &lt; j\)</span>，那么 <span class="math inline">\(q_i\)</span> 按命题变号的字典顺序排在
<span class="math inline">\(q_j\)</span> 之前。（参见§3.0.0（P.99）中的说明。）</p>
<p>{{% dtpc title=“☯定义 3.15【真值函数的表达】” %}} 设 <span class="math inline">\(\varphi\)</span> 为含 <span class="math inline">\(n\)</span>
个命题变号 <span class="math inline">\(q_0, \cdots, q_{n-1}\)</span> 的任意 <span class="math inline">\(\mathscr{L}_0\)</span>-公式，并且设
<span class="math inline">\(f\)</span> 为任意的 <span class="math inline">\(n\)</span> 元真值函数。<span class="math inline">\(\varphi\)</span> 表达 <span class="math inline">\(f\)</span> 当且仅当对所有的真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\varphi^{\sigma}=f(q_{0}^{\sigma}, \cdots, q_{n-1}^{\sigma}).\)</span>
<span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathscr{L}_{0}\)</span> 中可表达当且仅当有某个 <span class="math inline">\(\mathscr{L}_{0}\)</span>-公式
<span class="math inline">\(\varphi\)</span> 表达 <span class="math inline">\(f.\)</span> {{% /dtpc %}}</p>
<p>注意：定义3.15 中的 <span class="math inline">\(q_0, \cdots, q_{n-1}\)</span> 是根据命题变号集
<span class="math inline">\(\mathbf{Pr}\)</span>
上固定的字典顺序排列的。这个限制的理由很简单：如果没有这条限制，含相同命题变号而又不重言等值的公式也可以「表达」同一个真值函数。</p>
<p>比如，假定我们将定义 3.15 中的这种限制去掉，那么 <span class="math inline">\(p \rightarrow q\)</span>
可以「表达」<span class="math inline">\(f_{\rightarrow}\)</span>（因为
<span class="math inline">\((p \rightarrow q)^{\sigma}= f_{\rightarrow}(p^{\sigma}, q^{\sigma})\)</span>
对所有 <span class="math inline">\(\sigma\)</span> 成立），<span class="math inline">\(q \rightarrow p\)</span> 也可以「表达」（因为
<span class="math inline">\((q \rightarrow p)^{\sigma}=f_{\rightarrow}(q^{\sigma}, p^{\sigma})\)</span>
对所有 <span class="math inline">\(\sigma\)</span>
也成立）。当然，这并不是说，「表达」只能像我们上面那样定义。我们可以放弃对命题变号序列的那些限制，但我们必须同时放弃一类要求或想法，比如「含有相同命题变号的公式表达同一真值函数当且仅当它们重言等值」等等。</p>
<p>「表达」也可以相对于其他命题逻辑语言来定义。这里说的命题逻辑语言都与
<span class="math inline">\(\mathscr{L}_0\)</span>
相似：它们有共同的命题变号（和括号），但有不同的联结词；公式形成规则相仿，真理定义也相仿（参见式子
3.13 和定义 3.14
，其中「真值指派」和「对部分命题变号的赋值」意义不变），差别就在联结词及其语义解释。请读者补充这些命题逻辑语言的严格定义，以及关于它们公式真值的真理定义。我们约定：</p>
<p>语言 <span class="math inline">\(\mathscr{L}_{\odot}\)</span> 中的真值函数联结词是</p>
<p><span class="math display">\[\odot_{1}, \cdots, \odot_{k},\]</span></p>
<p><span class="math inline">\(\mathscr{L}_{\odot}\)</span>-公式是只用命题变号和</p>
<p><span class="math display">\[\odot_{1}, \cdots, \odot_{k}\]</span></p>
<p>构造出来的合式的符号串。</p>
<p><span class="math inline">\(\mathscr{L}_{\odot}\)</span>-公式对真值函数的「表达」和「函数完全性」的定义如下：</p>
<p>{{% dtpc title=“☯定义 3.16【表达】” %}} 设 <span class="math inline">\(\varphi\)</span> 为含 <span class="math inline">\(n\)</span> 个命题变号
<span class="math inline">\(q_{0}, \cdots, q_{n-1}\)</span> 的任意
<span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span>-公式，并设 <span class="math inline">\(f\)</span> 为任意的 <span class="math inline">\(n\)</span>
元真值函数。<span class="math inline">\(\varphi\)</span>（在 <span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span>
中）表达 <span class="math inline">\(f\)</span> 当且仅当对所有真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\varphi^{\sigma}=f(q_{0}^{\sigma}, \cdots, q_{n-1}^{\sigma}).\)</span>
<span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span>
中可表达当且仅当有某个 <span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span>-公式
<span class="math inline">\(\varphi\)</span> 表达 <span class="math inline">\(f.\)</span> {{% /dtpc %}}</p>
<p>{{% dtpc title=“☯定义 3.17【函数完全】” %}} 设
<span class="math inline">\(\mathbb{C}=\lbrace \odot_{1}, \cdots, \odot_{k}\rbrace\)</span>
为真值函数联结词的集合。<span class="math inline">\(\mathbb{C}\)</span>
是函数完全的当且仅当所有的真值函数都在
<span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span> 中可表达。 {{% /dtpc %}}</p>
<p>注意：我们并没有像本节一开始谈论的那样，把可以合成所有真值函数的真值函数集定义为函数完全的。定义
3.17
中既没有谈<bb>真值函数</bb>的集合，也没有谈真值函数的合成——它谈的是<bb>真值函数联结词</bb>的集合以及真值函数在有这些联结词的语言里的表达。但这两种谈法的结果是一样的，虽然我们不做证明。</p>
<p>{{% dtpc title=“☯定义 3.18【可定义】” %}} 设 <span class="math inline">\(\odot\)</span> 为任意 <span class="math inline">\(n\)</span>
元真值函数联结词，<span class="math inline">\(f_{\odot}\)</span> 为其语义解释。<span class="math inline">\(\odot\)</span> 是
<span class="math inline">\(\lbrace \odot_{1}, \cdots, \odot_{k}\rbrace\)</span> <bb>可定义的</bb>当且仅当
<span class="math inline">\(f_{\odot}\)</span> 在 <span class="math inline">\(\mathscr{L}_{\odot_{1}, \cdots, \odot_{k}}\)</span> 中可表达。
{{% /dtpc %}}</p>
<p>如果一集真值函数联结词 <span class="math inline">\(\mathbb{C}\)</span> 有函数完全性，那么用 <span class="math inline">\(\mathbb{C}\)</span>
做初始联结词的命题逻辑语言就有了完善的表达力。在这样的语言中，任何一个真值函数联结词都可以由
<span class="math inline">\(\mathbb{C}\)</span> 中的联结词来定义，就像任何一个真值函数都可以由解释
<span class="math inline">\(\mathbb{C}\)</span> 中联结词的真值函数来定义一样。</p>
</div>
<div id="具有函数完全性的几组真值函数联结词" class="section level3" number="4.6.2">
<h3><span class="header-section-number">4.6.2</span> 具有函数完全性的几组真值函数联结词</h3>
<p>这一小节里我们讨论具有函数完全性的几个真值函数联结词的集合。</p>
<p>{{% dtpc title=“☯命题 3.15” %}} 所有真值函数都在
<span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span> 中可表达。 {{% /dtpc %}}</p>
<p><bb>命题 3.15 之证明</bb>：令 <span class="math inline">\(f\)</span> 为任意 <span class="math inline">\(n\)</span>
元真值函数（<span class="math inline">\(n &gt; 0\)</span>）。我们分两种情况讨论。</p>
<p>情况 I: 对所有的 <span class="math inline">\(a_{0}, \cdots, a_{n-1} \in \lbrace 0, 1\rbrace\)</span> 都有
<span class="math inline">\(f(a_{0}, \cdots, a_{n-1})=0.\)</span> 令
<span class="math inline">\(\varphi=p_{0} \wedge \neg p_{0} \wedge p_{1} \wedge \cdots \wedge p_{n-1}.\)</span>
易见对所有真值指派 <span class="math inline">\(\sigma\)</span> 都有 <span class="math inline">\(\varphi^{\sigma}=0\)</span>，所以在情况 I
下，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span> 中可表达。</p>
<p>情况 II: 存在 <span class="math inline">\(a_{0}, \cdots, a_{n-1} \in \lbrace 0, 1\rbrace\)</span> 使得
<span class="math inline">\(f(a_{0}, \cdots, a_{n-1})=1.\)</span> 设</p>
<span class="math display">\[\begin{equation}
b_{0}^{0}, \cdots, b_{n-1}^{0}; \quad b_{0}^{1}, \cdots, b_{n-1}^{1} ; \quad \cdots ; \quad b_{0}^{k}, \cdots, b_{n-1}^{k} 
\end{equation}\]</span>
<p><span class="math inline">\((k&lt;2^{n})\)</span> 为所有的真值序列
<span class="math inline">\(a_{0}, \cdots, a_{n-1} \in\lbrace 0, 1\rbrace\)</span> 使得
<span class="math inline">\(f(a_{0}, \cdots, a_{n-1})=1.\)</span> 对每个 <span class="math inline">\(i \leqslant k\)</span> 和 <span class="math inline">\(j &lt; n\)</span>，令</p>
<p>
<p><span class="math display">\[
\theta_{j}^{i}=\left\lbrace \begin{array}{ll}
p_{j} &amp; \text { 如果 }~ b_{j}^{i}=1 \\
\neg p_{j} &amp; \text { 如果 }~ b_{j}^{i}=0
\end{array}\right.
\]</span></p>
</p>
<p>且对每个 <span class="math inline">\(i \leqslant k\)</span>，令
<span class="math inline">\(\psi_{i}=\theta_{0}^{i} \wedge \cdots \wedge \theta_{n-1}^{i}.\)</span>
最后，令 <span class="math inline">\(\varphi=\psi_{0} \vee \cdots \vee \psi_{k}.\)</span></p>
<p>以下证明 <span class="math inline">\(\varphi\)</span> 表达 <span class="math inline">\(f.\)</span> 令 <span class="math inline">\(\sigma\)</span> 为任意真值指派。</p>
<p>设 <span class="math inline">\(f(p_{0}^{\sigma}, \cdots, p_{n-1}^{\sigma})=1.\)</span> 易见式子 (10)
中某个序列 <span class="math inline">\(b_{0}^{i}, \cdots, b_{n-1}^{i}(i \leqslant k)\)</span> 就是
<span class="math inline">\(p_{0}^{\sigma}, \cdots, p_{n-1}^{\sigma}.\)</span> 由 <span class="math inline">\(\theta_{j}^{i}\)</span>
的定义知，对每个 <span class="math inline">\(j&lt;n\)</span>，如果 <span class="math inline">\(p_{j}^{\sigma}=1\)</span> 则
<span class="math inline">\(\theta_{j}^{i}=p_{j}\)</span>，而如果 <span class="math inline">\(p_{j}^{\sigma}=0\)</span> 则
<span class="math inline">\(\theta_{j}^{i}=\neg p_{j}.\)</span> 这就是说，对每个 <span class="math inline">\(j&lt;n\)</span> 都有
<span class="math inline">\((\theta_{j}^{i})^{\sigma}=1\)</span>，所以<span class="math inline">\(\psi_{i}^{\sigma}=1\)</span>，进而
<span class="math inline">\(\varphi^{\sigma}=1.\)</span></p>
<p>设 <span class="math inline">\(\varphi^{\sigma}=1.\)</span> 根据 <span class="math inline">\(\varphi\)</span> 的定义，存在 <span class="math inline">\(i \leqslant k\)</span>
使得 <span class="math inline">\(\psi_{i}^{\sigma}=1\)</span>，从而对每个 <span class="math inline">\(j&lt;n\)</span> 都有
<span class="math inline">\((\theta_{j}^{i})^{\sigma}=1.\)</span> 根据 <span class="math inline">\(\theta_{j}^{i}\)</span> 的定义，如果
<span class="math inline">\(p_{j}^{\sigma}=1\)</span> 则 <span class="math inline">\(b_{j}^{i}=1\)</span>，并且如果 <span class="math inline">\(p_{j}^{\sigma}=0\)</span>，则
<span class="math inline">\(b_{j}^{i}=0.\)</span> 这就是说，真值序列
<span class="math inline">\(p_{0}^{\sigma}, \cdots, p_{n-1}^{\sigma}\)</span> 就是式子 (10) 中的
<span class="math inline">\(b_{0}^{i}, \cdots, b_{n-1}^{i} .\)</span> 既然
<span class="math inline">\(f(b_{0}^{i}, \cdots, b_{n-1}^{i})=1\)</span>，我们有
<span class="math inline">\(f(p_{0}^{\sigma}, \cdots, p_{n-1}^{\sigma})=1.\)</span></p>
<p>综上所述，可知 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span> 中可表达。▗</p>
<p>{{% dtpc title=“☯定理 3.4【函数完全性定理】” %}} 1. 所有真值函数都在
<span class="math inline">\(\mathscr{L}_{\neg, \lor}\)</span> 中可表达 1. 所有真值函数都在
<span class="math inline">\(\mathscr{L}_{\neg, \land}\)</span> 中可表达 1. 所有真值函数都在
<span class="math inline">\(\mathscr{L}_{\neg, \rightarrow}\)</span> 中可表达 {{% /dtpc %}}</p>
<p><bb>证明</bb>：易证对所有 <span class="math inline">\(\mathscr{L}_{0}\)</span>-公式 <span class="math inline">\(\chi\)</span> 和
<span class="math inline">\(\chi^{\prime}\)</span>，<span class="math inline">\(\chi \wedge \chi^{\prime}\)</span> 和
<span class="math inline">\(\neg(\neg \chi \vee \neg \chi^{\prime})\)</span> 重言等值（习题 3.5）。</p>
<p>因而对每个 <span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span>-公式
<span class="math inline">\(\varphi\)</span>，运用若干次推论 3.3 可以得到</p>
<p><span class="math inline">\(\mathscr{L}_{\neg, \lor}\)</span>-公式 <span class="math inline">\(\varphi^{\prime}\)</span>， 使得 <span class="math inline">\(\varphi\)</span> 与
<span class="math inline">\(\varphi^{\prime}\)</span> 重言等值并且 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\varphi^{\prime}\)</span>
含相同的命题变号（习题 3.25）。</p>
<p>令 <span class="math inline">\(f\)</span> 为任意 <span class="math inline">\(n\)</span> 元真值函数。由命题 3.15 知有
<span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span>-公式 <span class="math inline">\(\varphi\)</span> 表达 <span class="math inline">\(f\)</span>，</p>
<p>因而 <span class="math inline">\(\varphi\)</span> 含命题变号 <span class="math inline">\(q_{0}, \cdots, q_{n-1}\)</span>，且对所有真值指派
<span class="math inline">\(\sigma\)</span>，<span class="math inline">\(\varphi^{\sigma}=f(q_{0}^{\sigma}, \cdots, q_{n-1}^{\sigma}).\)</span>
由上述可知，存在 <span class="math inline">\(\mathscr{L}_{\neg, \lor}\)</span>-公式 <span class="math inline">\(\psi\)</span>，<span class="math inline">\(\psi\)</span>
含命题变号 <span class="math inline">\(q_{0}, \cdots, q_{n-1}\)</span> 并且
<span class="math inline">\(\psi^{\sigma}= f\left(q_{0}^{\sigma}, \cdots, q_{n-1}^{\sigma}\right)\)</span>,
所以 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathscr{L}_{\neg, \lor}\)</span> 中可表达。</p>
<p>因为 <span class="math inline">\(\chi \vee \chi^{\prime}\)</span> 和
<span class="math inline">\(\neg(\neg \chi \wedge \neg \chi^{\prime})\)</span>
重言等值，所以类似可证所有真值函数都在 <span class="math inline">\(\mathscr{L}_{\neg, \land}\)</span>
中可表达。</p>
<p>因为 <span class="math inline">\(\chi \vee \chi^{\prime}\)</span> 和 <span class="math inline">\(\neg \chi \rightarrow \chi^{\prime}\)</span>
以及 <span class="math inline">\(\chi \wedge \chi^{\prime}\)</span> 和
<span class="math inline">\(\neg(\chi \rightarrow \neg \chi^{\prime})\)</span>
分别重言等值，所以类似可证所有真值函数都在
<span class="math inline">\(\mathscr{L}_{\neg, \rightarrow}\)</span> 中可表达。▗</p>
<p>{{% dtpc title=“☯定理 3.5【函数完全性定理】” %}}
<span class="math inline">\(\lbrace \neg, \land\rbrace, \lbrace \neg, \land\rbrace, \lbrace \neg, \rightarrow\rbrace\)</span>
各自都是函数完全的，并且各自都可定义所有的真值函数联结词。 {{% /dtpc %}}</p>
<p><bb>证明</bb>：根据定理 3.5、定义 3.17 和定义 3.18 得证。▗</p>
<p>函数完全的真值函数联结词的集合，可以只有两个元素，比如
<span class="math inline">\(\lbrace \neg, \lor\rbrace\)</span>，也可以只有一个元素。<z>英</z>文中有两个一元联结词
“not-both”（NAND） 和 “neither-nor”（NOR），我们用 “<span class="math inline">\(\mid\)</span>” 和
“<span class="math inline">\(\mid\mid\)</span>” 来表示它们。算上 <span class="math inline">\(\veebar\)</span> 与这两个联结词，基本真值表
2.1（P.82）便成为如下扩展的真值表：</p>
<p>{{% freebox title=“扩展的基本真值表” %}}</p>
<p>
<p><span class="math display">\[
\begin{array}{cc|cccccccc}
p &amp; q &amp; p \vee q &amp; p \wedge q &amp; p \rightarrow q &amp; p \leftrightarrow q &amp; p \veebar q &amp; p \mid\mid q &amp; p \mid q &amp; \neg p\\
\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1  &amp; 1\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1
&amp;
\end{array}
\]</span></p>
</p>
<p>{{% /freebox %}}</p>
<p>可以证明，<span class="math inline">\(\lbrace \mid\rbrace, \lbrace || \rbrace\)</span>
也分别都是函数完全的。我们不给详细证明，只陈述证明中用到的最关键事实：</p>
<p><span class="math inline">\(\varphi \mid \varphi\)</span> 可用来表示
<span class="math inline">\(\neg \varphi\)</span>，<span class="math inline">\((\varphi \mid \varphi) \mid (\psi \mid \psi)\)</span>
可用来表示 <span class="math inline">\(\varphi \vee \psi\)</span> 见下表：</p>
<p>
<p><span class="math display">\[
\begin{array}{c|c|c}
\varphi &amp; \neg \varphi &amp; \varphi \mid \varphi \\
\hline 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1
\end{array}
\]</span></p>
</p>
<p>
<p><span class="math display">\[
\begin{array}{cc|c|c}
\varphi &amp; \psi &amp; \varphi \vee \psi &amp; (\varphi \mid \varphi) \mid (\psi \mid \psi) \\
\hline 1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 1 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{array}
\]</span></p>
</p>
<p><span class="math inline">\(\varphi \| \varphi\)</span> 可用来表示
<span class="math inline">\(\neg \varphi\)</span>，<span class="math inline">\((\varphi \| \varphi) \| (\psi \| \psi)\)</span> 可用来表示
<span class="math inline">\(\varphi \wedge \psi\)</span> 见下表：</p>
<p>
<p><span class="math display">\[
\begin{array}{c|c|c}
\varphi &amp; \neg \varphi &amp; \varphi \| \varphi \\
\hline 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1
\end{array}
\]</span></p>
</p>
<p>
<p><span class="math display">\[
\begin{array}{cc|c|c}
\varphi &amp; \psi &amp; \varphi \wedge \psi &amp; (\varphi \| \varphi)\|(\psi \| \psi) \\
\hline 1 &amp; 1 &amp; 1 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0
\end{array}
\]</span></p>
</p>
</div>
</div>
<div id="本章习题-1" class="section level2" number="4.7">
<h2><span class="header-section-number">4.7</span> 本章习题</h2>

<div class="exercise">
<p><span id="exr:plsemexe01" class="exercise"><strong>练习 4.1  </strong></span>证明：对所有公式集 <span class="math inline">\(\Gamma\)</span> 和 <span class="math inline">\(\Delta\)</span>，以及所有公式 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span>：</p>
<ol style="list-style-type: decimal">
<li>如果 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span>，那么 <span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \varphi\)</span>;</li>
<li>如果 <span class="math inline">\(\Gamma \vDash_{0} \varphi \vee \psi\)</span> 并且 <span class="math inline">\(\Delta \vDash_{0} \neg \varphi\)</span>，那么 <span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \psi\)</span>;</li>
<li>如果 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span>　且 <span class="math inline">\(\Delta \vDash_{0} \varphi \rightarrow \psi\)</span>，那么 <span class="math inline">\(\Gamma \cup \Delta \vDash_{0} \psi\)</span>.
</div></li>
</ol>

<div class="exercise">
<span id="exr:plsemexe02" class="exercise"><strong>练习 4.2  </strong></span>设 <span class="math inline">\(\Delta \vDash_{0} \varphi\)</span> 并且 <span class="math inline">\(\varphi \vDash_{0} \psi\)</span>. 证明：<span class="math inline">\(\Delta \vDash_{0} \psi\)</span>.
</div>

<div class="exercise">
<p><span id="exr:plsemexe03" class="exercise"><strong>练习 4.3  </strong></span>证明对所有公式 <span class="math inline">\(\varphi, \psi, \chi\)</span>，下述命题成立：：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi, \varphi \rightarrow \psi \vDash_{0} \psi\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi, \neg \psi \vDash_{0} \varphi\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi, \neg \varphi \vee \chi \vDash_{0} \psi \vee \chi\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi \vDash_{0} \chi\)</span> 当且仅当 <span class="math inline">\(\varphi \vDash_{0} \chi\)</span> 且 <span class="math inline">\(\psi \vDash_{0} \chi\)</span>.
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe04" class="exercise"><strong>练习 4.4  </strong></span>令 <span class="math inline">\(\varphi, \psi, \chi\)</span> 为任意公式。证明下列都是重言式：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi \rightarrow(\psi \rightarrow \varphi)\)</span></li>
<li><span class="math inline">\((\varphi \rightarrow(\psi \rightarrow \chi)) \rightarrow((\varphi \rightarrow \psi) \rightarrow(\varphi \rightarrow \chi))\)</span></li>
<li><span class="math inline">\(\varphi \wedge \psi \rightarrow \varphi\)</span></li>
<li><span class="math inline">\(\varphi \wedge \psi \rightarrow \psi\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow(\psi \rightarrow \varphi \wedge \psi)\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow \varphi \vee \psi\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow \psi \vee \varphi\)</span></li>
<li><span class="math inline">\((\varphi \rightarrow \chi) \rightarrow((\psi \rightarrow \chi) \rightarrow(\varphi \vee \psi \rightarrow \chi))\)</span></li>
<li><span class="math inline">\((\varphi \rightarrow \psi) \rightarrow((\varphi \rightarrow \neg \psi) \rightarrow \neg \varphi)\)</span></li>
<li><span class="math inline">\(\neg \neg \varphi \rightarrow \varphi\)</span></li>
<li><span class="math inline">\((\varphi \leftrightarrow \psi) \rightarrow(\varphi \rightarrow \psi)\)</span></li>
<li><span class="math inline">\((\varphi \leftrightarrow \psi) \rightarrow(\psi \rightarrow \varphi)\)</span></li>
<li><span class="math inline">\((\varphi \rightarrow \psi) \rightarrow((\psi \rightarrow \varphi) \rightarrow(\varphi \leftrightarrow \psi))\)</span>
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe05" class="exercise"><strong>练习 4.5  </strong></span>令 <span class="math inline">\(\varphi, \psi, \chi\)</span> 为任意公式。证明下列都是重言式：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\((\neg \varphi \rightarrow \psi) \rightarrow((\neg \varphi \rightarrow \neg \psi) \rightarrow \varphi)\)</span></li>
<li><span class="math inline">\((\neg \psi \rightarrow \neg \varphi) \rightarrow(\varphi \rightarrow \psi)\)</span></li>
<li><span class="math inline">\(((\varphi \rightarrow \psi) \rightarrow \varphi) \rightarrow \varphi\)</span></li>
<li><span class="math inline">\(\neg \varphi \rightarrow(\varphi \rightarrow \psi)\)</span></li>
<li><span class="math inline">\((\neg \varphi \rightarrow \varphi) \rightarrow \varphi\)</span></li>
<li><span class="math inline">\((\varphi \rightarrow \neg \varphi) \rightarrow \neg \varphi\)</span></li>
<li><span class="math inline">\((\varphi \leftrightarrow \psi) \leftrightarrow(\psi \leftrightarrow \varphi)\)</span></li>
<li><span class="math inline">\(((\varphi \leftrightarrow \chi) \leftrightarrow(\psi \leftrightarrow \varphi)) \leftrightarrow(\chi \leftrightarrow \psi)\)</span></li>
<li><span class="math inline">\((\varphi \leftrightarrow(\psi \leftrightarrow \chi)) \leftrightarrow((\varphi \leftrightarrow \psi) \leftrightarrow \chi)\)</span>
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe06" class="exercise"><strong>练习 4.6  </strong></span>证明对所有公式 <span class="math inline">\(\varphi, \psi, \chi\)</span>，下列各组公式都是重言等值的：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi, \varphi \vee \varphi, \varphi \wedge \varphi\)</span></li>
<li><span class="math inline">\(\varphi, \neg \neg \varphi\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi, \psi \vee \varphi\)</span></li>
<li><span class="math inline">\(\varphi \wedge \psi, \psi \wedge \varphi\)</span></li>
<li><span class="math inline">\(\varphi \vee(\psi \vee \chi),(\varphi \vee \psi) \vee \chi\)</span></li>
<li><span class="math inline">\(\varphi \wedge(\psi \wedge \chi),(\varphi \wedge \psi) \wedge \chi\)</span></li>
<li><span class="math inline">\(\neg(\varphi \vee \psi), \neg \varphi \wedge \neg \psi\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi, \neg(\neg \varphi \wedge \neg \psi)\)</span></li>
<li><span class="math inline">\(\neg(\varphi \wedge \psi), \neg \varphi \vee \neg \psi\)</span></li>
<li><span class="math inline">\(\varphi \wedge \psi, \neg(\neg \varphi \vee \neg \psi)\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow \psi, \neg \psi \rightarrow \neg \varphi\)</span></li>
<li><span class="math inline">\(\varphi \vee(\psi \wedge \chi),(\varphi \vee \psi) \wedge(\varphi \vee \chi)\)</span></li>
<li><span class="math inline">\(\varphi \wedge(\psi \vee \chi),(\varphi \wedge \psi) \vee(\varphi \wedge \chi)\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow \psi, \neg \varphi \vee \psi\)</span></li>
<li><span class="math inline">\(\neg \varphi \rightarrow \psi, \varphi \vee \psi\)</span></li>
<li><span class="math inline">\(\varphi \leftrightarrow \psi,(\varphi \wedge \psi) \vee(\neg \varphi \wedge \neg \psi)\)</span></li>
<li><span class="math inline">\(\varphi \leftrightarrow \psi,(\varphi \rightarrow \psi) \wedge(\psi \rightarrow \varphi)\)</span></li>
<li><span class="math inline">\(\neg(\varphi \leftrightarrow \psi), \varphi \leftrightarrow \neg \psi, \neg \varphi \leftrightarrow \psi,(\varphi \wedge \neg \psi) \vee(\neg \varphi \wedge \psi)\)</span></li>
<li><span class="math inline">\(\varphi \rightarrow(\psi \rightarrow \chi), \varphi \wedge \psi \rightarrow \chi, \psi \rightarrow(\varphi \rightarrow \chi)\)</span></li>
<li><span class="math inline">\(\varphi \vee \psi \rightarrow \chi,(\varphi \rightarrow \chi) \wedge(\psi \rightarrow \chi)\)</span>
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe07" class="exercise"><strong>练习 4.7  </strong></span>证明：对所有公式集 <span class="math inline">\(\Gamma\)</span> 和所有公式 <span class="math inline">\(\varphi\)</span>：</p>
<ol style="list-style-type: decimal">
<li>如果 <span class="math inline">\(\Gamma \vDash_{0} \varphi\)</span> 且 <span class="math inline">\(\varphi\)</span>不可满足，那么 <span class="math inline">\(\Gamma\)</span> 不可满足。</li>
<li>如果 <span class="math inline">\(\Gamma\)</span> 可满足，那么 <span class="math inline">\(\lbrace \psi: \Gamma \vDash_{0} \psi\rbrace\)</span> 也可满足。
</div></li>
</ol>

<div class="exercise">
<span id="exr:plsemexe08" class="exercise"><strong>练习 4.8  </strong></span>完成命题 3.7（P.105）的证明。
</div>

<div class="exercise">
<p><span id="exr:plsemexe09" class="exercise"><strong>练习 4.9  </strong></span>证明：对所有公式 <span class="math inline">\(\varphi\)</span>：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi\)</span> 是重言式当且仅当 <span class="math inline">\(\neg \varphi\)</span> 不可满足；</li>
<li><span class="math inline">\(\varphi\)</span> 是矛盾式当且仅当 <span class="math inline">\(\varphi\)</span> 不可满足；</li>
<li><span class="math inline">\(\varphi\)</span> 是或然式当且仅当 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\neg \varphi\)</span> 都可满足；</li>
<li><span class="math inline">\(\varphi\)</span> 是重言式当且仅当 <span class="math inline">\(\neg \varphi\)</span> 是矛盾式；</li>
<li><span class="math inline">\(\varphi\)</span> 是矛盾式当且仅当 <span class="math inline">\(\neg \varphi\)</span> 是重言式；</li>
<li><span class="math inline">\(\varphi\)</span> 是或然式当且仅当 <span class="math inline">\(\neg \varphi\)</span> 是或然式。
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe10" class="exercise"><strong>练习 4.10  </strong></span>证明：对所有公式 <span class="math inline">\(\varphi\)</span>：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi\)</span> 是重言式当且仅当 <span class="math inline">\(p_0 \lor \neg p_0\)</span> 重言蕴涵 <span class="math inline">\(\varphi\)</span>.</li>
<li><span class="math inline">\(\varphi\)</span> 是矛盾式当且仅当 <span class="math inline">\(\varphi\)</span> 重言蕴涵 <span class="math inline">\(p_0 \land \neg p_0\)</span>.
</div></li>
</ol>

<div class="exercise">
<span id="exr:plsemexe11" class="exercise"><strong>练习 4.11  </strong></span>设 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime \prime}\)</span> 都是有穷代入。证明：<span class="math inline">\(\mathfrak{s}^{\prime}\mathfrak{s}^{\prime \prime}\)</span> 也是有穷代入。
</div>

<div class="exercise">
<span id="exr:plsemexe12" class="exercise"><strong>练习 4.12  </strong></span>设 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 为任意公式，并设 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 为任意命题变号，其中 <span class="math inline">\(q\)</span> 不在 <span class="math inline">\(\varphi\)</span> 中出现。证明：<span class="math inline">\(\varphi(\psi / p)=\varphi(q / p)(\psi / q)\)</span>.
</div>

<div class="exercise">
<span id="exr:plsemexe13" class="exercise"><strong>练习 4.13  </strong></span>证明：对所有公式 <span class="math inline">\(\varphi\)</span> 及其子公式 <span class="math inline">\(\psi\)</span>，存在公式 <span class="math inline">\(\chi\)</span> 和命题变号 <span class="math inline">\(p\)</span> 使得 <span class="math inline">\(\varphi=\chi(\psi / p)\)</span>，并说明即使对同一个这样的 <span class="math inline">\(p\)</span>，<span class="math inline">\(\chi\)</span> 也不是唯一的。
</div>

<div class="exercise">
<span id="exr:plsemexe14" class="exercise"><strong>练习 4.14  </strong></span>设 <span class="math inline">\(\varnothing \neq A \subseteq \mathbf{Pr}\)</span>，设 <span class="math inline">\(\mathfrak{s}\)</span> 和 <span class="math inline">\(\mathfrak{s}^{\prime}\)</span> 为任意代入，并设 <span class="math inline">\(\sigma\)</span> 和 <span class="math inline">\(\sigma^{\prime}\)</span> 为任意真值指派，满足对每一个 <span class="math inline">\(p \in A,(\mathfrak{s}(p))^{\sigma}=\left(\mathfrak{s}^{\prime}(p)\right)^{\sigma^{\prime}}\)</span>. 证明：对所有 <span class="math inline">\(A\)</span>-公式<span class="math inline">\(\varphi\)</span>，<span class="math inline">\((\varphi(\mathfrak{s}))^{\sigma}=(\varphi(\mathfrak{s}^{\prime}))^{\sigma^{\prime}}\)</span>.
</div>

<div class="exercise">
<span id="exr:plsemexe15" class="exercise"><strong>练习 4.15  </strong></span>试从习题 3.13 直接证明定理 3.0（P.112）。
</div>

<div class="exercise">
<span id="exr:plsemexe16" class="exercise"><strong>练习 4.16  </strong></span>试从定理 3.1 直接证明定理 3.0（P.112）。
</div>

<div class="exercise">
<span id="exr:plsemexe17" class="exercise"><strong>练习 4.17  </strong></span>证明推论 3.4（P.114）（提示：先将置换结果讲清楚）；然后试用推论 3.4 直接证明推论 3.3。
</div>

<div class="exercise">
<span id="exr:plsemexe18" class="exercise"><strong>练习 4.18  </strong></span>设 <span class="math inline">\(\varphi\)</span> 为重言式，并设 <span class="math inline">\(\mathfrak{s}\)</span> 为任意代入。证明：<span class="math inline">\(\varphi(\mathfrak{s})\)</span> 是重言式。
</div>

<div class="exercise">
<span id="exr:plsemexe19" class="exercise"><strong>练习 4.19  </strong></span>运用重言蕴涵等语义概念的「严格定义」，证明习题 2.17（P.97）和习题 2.18（P.98）中的各个命题。
</div>

<div class="exercise">
<span id="exr:plsemexe20" class="exercise"><strong>练习 4.20  </strong></span>完成命题 3.13（P.118）的证明。
</div>

<div class="exercise">
<p><span id="exr:plsemexe21" class="exercise"><strong>练习 4.21  </strong></span>证明下列命题。设 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 为任意不含相同命题变号的公式。证明：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\varphi \rightarrow \psi\)</span> 是重言式当且仅当或者 <span class="math inline">\(\varphi\)</span> 是矛盾式或者 <span class="math inline">\(\psi\)</span> 是重言式。</li>
<li><span class="math inline">\(\varphi \leftrightarrow \psi\)</span> 是重言式当且仅当或者 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 都是矛盾式或者 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 都是重言式。
</div></li>
</ol>

<div class="exercise">
<p><span id="exr:plsemexe22" class="exercise"><strong>练习 4.22  </strong></span>求下列公式的析取范式与合取范式：</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(p \vee q \rightarrow p \wedge q\)</span></li>
<li><span class="math inline">\(p \wedge q \rightarrow(\neg r \rightarrow p)\)</span></li>
<li><span class="math inline">\((p \rightarrow q \wedge r) \rightarrow(\neg p \rightarrow \neg q \wedge \neg r)\)</span></li>
<li><span class="math inline">\((p \rightarrow q \vee \neg r) \leftrightarrow(r \rightarrow q \wedge \neg p)\)</span></li>
<li><span class="math inline">\(p \vee q \rightarrow(p \rightarrow \neg q)\)</span></li>
<li><span class="math inline">\((p \vee q) \wedge((r \rightarrow \neg p \wedge \neg q) \wedge(\neg r \rightarrow r))\)</span></li>
<li><span class="math inline">\((p \rightarrow \neg q \wedge r) \leftrightarrow(q \vee(\neg r \wedge p))\)</span></li>
<li><span class="math inline">\(((p \rightarrow q) \rightarrow p) \rightarrow q) \rightarrow r\)</span>
</div></li>
</ol>

<div class="exercise">
<span id="exr:plsemexe23" class="exercise"><strong>练习 4.23  </strong></span>证明范式存在定理，即定理 3.2（P.120）和定理 3.3（P.121）
</div>

<div class="exercise">
<span id="exr:plsemexe24" class="exercise"><strong>练习 4.24  </strong></span>证明：每个含 <span class="math inline">\(n\)</span> 个命题变号 <span class="math inline">\(q_0, \cdots, q_{n-1}\)</span> 的 <span class="math inline">\(\mathscr{L}_0\)</span>-公式都表达一个 <span class="math inline">\(n\)</span> 元真值函数。
</div>

<div class="exercise">
<span id="exr:plsemexe25" class="exercise"><strong>练习 4.25  </strong></span>设 <span class="math inline">\(\varphi\)</span> 和 <span class="math inline">\(\psi\)</span> 为任意 <span class="math inline">\(\mathscr{L}_0\)</span>-公式，其中出现的命题变号相同。证明：<span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 表达同一个真值函数当且仅当 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\psi\)</span> 重言等值。
</div>

<div class="exercise">
<p><span id="exr:plsemexe26" class="exercise"><strong>练习 4.26  </strong></span>证明：对每个 <span class="math inline">\(\mathscr{L}_{\neg, \lor, \land}\)</span>-公式 <span class="math inline">\(\varphi\)</span>，
1. 存在 <span class="math inline">\(\mathscr{L}_{\neg, \lor}\)</span>-公式 <span class="math inline">\(\varphi^{\prime}\)</span>，使得 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 重言等值并且 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 含相同的命题变号。</p>
<ol style="list-style-type: decimal">
<li>存在 <span class="math inline">\(\mathscr{L}_{\neg, \land}\)</span>-公式 <span class="math inline">\(\varphi^{\prime}\)</span>，使得 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 重言等值并且 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 含相同的命题变号。</li>
<li>存在 <span class="math inline">\(\mathscr{L}_{\neg, \rightarrow}\)</span>-公式 <span class="math inline">\(\varphi^{\prime}\)</span>，使得 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 重言等值并且 <span class="math inline">\(\varphi\)</span> 与 <span class="math inline">\(\varphi^{\prime}\)</span> 含相同的命题变号。
</div></li>
</ol>

<div class="exercise">
<span id="exr:plsemexe27" class="exercise"><strong>练习 4.27  </strong></span>证明：用 <span class="math inline">\(\mid\)</span> 定义 <span class="math inline">\(\rightarrow\)</span> 和 <span class="math inline">\(\land\)</span>，用 <span class="math inline">\(||\)</span> 定义 <span class="math inline">\(\lor\)</span> 和 <span class="math inline">\(\rightarrow\)</span>，并证明 <span class="math inline">\(\lbrace \mid\rbrace\)</span> 和 <span class="math inline">\(\lbrace \|\rbrace\)</span> 分别都是函数完全的。
</div>

<div class="exercise">
<p><span id="exr:plsemexe28" class="exercise"><strong>练习 4.28  </strong></span>证明：<span class="math inline">\(\lbrace \neg \leftrightarrow\rbrace\)</span> 不可定义 <span class="math inline">\(\lor\)</span>，<span class="math inline">\(\lbrace \neg \veebar\rbrace\)</span> 不可定义 <span class="math inline">\(\land\)</span>，且 <span class="math inline">\(\lbrace \lor, \land, \rightarrow, \leftrightarrow\rbrace\)</span> 不可定义 <span class="math inline">\(\neg\)</span>.</p>
<p>设 <span class="math inline">\(\mathbb{F}\)</span> 为任意真值函数集合，并设 <span class="math inline">\(f\)</span> 为任意真值函数。如果 <span class="math inline">\(f\)</span> 可以由 <span class="math inline">\(\mathbb{F}\)</span> 中的函数复合而成，我们就称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{F}\)</span> 可定义的。下述习题的目的，是直接证明「函数版本」的函数完全性（见§3.5.0（P.122）开端处的说明）。这个证明应比 §3.5.1（P.124）中的证明「漂亮」，尽管思路可以差不多。熟悉函数复合的读者可以试做。</p>
对每个自然数 <span class="math inline">\(n&gt;0\)</span>，令 <span class="math inline">\(f_{\lor, n}\)</span> 为 <span class="math inline">\(n\)</span> 元真值函数，使得对所有 <span class="math inline">\(a_{0}, \cdots, a_{n-1} \in\lbrace 0,1\rbrace\)</span>，<span class="math inline">\(f_{\lor, n}(a_{0}, \cdots, a_{n-1})=1\)</span> 当且仅当 <span class="math inline">\(a_{0}, \cdots, a_{n-1}\)</span> 中至少有一个是 1；并令 <span class="math inline">\(f_{\wedge, n}\)</span> 为 <span class="math inline">\(n\)</span> 元真值函数，使得对所有 <span class="math inline">\(a_{0}, \cdots, a_{n-1} \in \lbrace 1, 0\rbrace\)</span>，<span class="math inline">\(f_{\wedge, n}(a_{0}, \cdots, a_{n-1})=1\)</span> 当且仅当 <span class="math inline">\(a_{0}, \cdots, a_{n+1}\)</span> 都是 1.
</div>

<div class="exercise">
<span id="exr:plsemexe29" class="exercise"><strong>练习 4.29  </strong></span>令 <span class="math inline">\(\mathbb{F}=\lbrace f_{\neg}\rbrace \cup\lbrace f_{\vee, n}: n&gt;0\rbrace \cup\lbrace f_{\wedge, n}: n&gt;0\rbrace\)</span>. 证明：所有真值函数都是 <span class="math inline">\(\mathbb{F}\)</span> 可定义的。
</div>

<div class="exercise">
<p><span id="exr:plsemexe30" class="exercise"><strong>练习 4.30  </strong></span>证明：</p>
<ol style="list-style-type: decimal">
<li>所有真值函数都是 <span class="math inline">\(\lbrace f_{\neg}, f_{\lor}, f_{\wedge}\rbrace\)</span>-可定义的；</li>
<li>所有真值函数都是 <span class="math inline">\(\lbrace f_{\neg}, f_{\lor}\rbrace\)</span>-可定义的，都是 <span class="math inline">\(\lbrace f_{\neg}, f_{\wedge}\rbrace\)</span>-可定义的，并且都是 <span class="math inline">\(\lbrace f_{\neg}, f_{\rightarrow}\rbrace\)</span>-可定义的；</li>
<li>所有真值函数都是 <span class="math inline">\(\lbrace f_{\mid}\rbrace\)</span>-可定义的，并且都是 <span class="math inline">\(\lbrace f_{\|}\rbrace\)</span>-可定义的。
</div></li>
</ol>
<br>
<br>
<hr>
<p><strong>Editorial comments</strong></p>
<p>有屁请在此处放，看看谁的屁更响。</p>
<script src="https://utteranc.es/client.js"
        repo="superfluous-man/baby-logic"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>
</div>





<script>
const toggleButton = document.getElementsByClassName("show-more-text");
var i;
//const link = document.createElement('a');


for (i = 0; i < toggleButton.length; i++) {
    toggleButton[i].addEventListener("click", function() {
    this.classList.toggle("more-text-active");
    let content = this.nextElementSibling;
    if (content.style.display === "block") {
      content.style.display = "none";
      this.innerHTML = '<i class="fa fa-plus-square-o" ></i>';
     } else {
      content.style.display = "block";
      this.innerHTML = '<i class="fa fa-minus-square-o" ></i>';
    }
  });
}
</script>
            </section>

          </div>
        </div>
      </div>
<a href="chap-truth-table.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="references.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": false,
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
