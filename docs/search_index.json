[["index.html", "Baby Logic Welcome", " Baby Logic Lǐ Èrgǒu 2021-03-03 Welcome 「逻辑」有很多种，「逻辑学」也有很多种。不同的人学习逻辑学有不同的目的。本笔记中的「逻辑学」知识主要服务于语言、思维的分析，不追求逻辑学在其他领域的功能。 本笔记大致列出逻辑基础学习阶段的主要材料，主要参考（chāoxí）以下课本攒集而成： 参考文献： 徐明, 2008. 符号逻辑讲义[M].武汉:武汉大学出版社. 胡龙彪,黄华新, 2006. 逻辑学教程[M].杭州:浙江大学出版社. 黄华新,张则幸, 2011. 逻辑学导论（第二版）[M].杭州:浙江大学出版社. 安德鲁·辛普森, 2005. 离散数学导学[M].冯速,译.北京:机械工业出版社. Tidman P, Kahane H, 2002. Logic and Philosophy: A Modern Introduction[M]. Ninth. Boston: Cengage Learning. Smith N J J, 2012. Logic: The Laws of Truth[M]. New Jersey: Princeton University Press. Copi I M, Cohen C, Rodych V, 2018. Introduction to Logic[M]. New York: Routledge. Bergmann M, Moor J, Nelson J, 2014. The Logic Book[M]. Sixth. New York: McGraw‑Hill. 其中，直接取自《符号逻辑讲义》的材料最多，取自《逻辑学导论》較多，素樸集合論、表列演算則直接取自完全開源的 Open Logic Project 項目源碼。 Editorial comments 有屁请在此处放，看看谁的屁更响。 "],["bookintro.html", " 1 全书绪论 1.1 论说 1.2 演绎 1.3 一致性 1.4 逻辑或「逻辑」的若干问题", " 1 全书绪论 “I know what you’re thinking about,” said Tweedledum; “but it isn’t so, nohow.” “Contrariwise,” continued Tweedledee, “if it was so, it might be; and if it were so, it would be; but as it isn’t, it ain’t. That’s logic.”Lewis Carroll, Through the Looking-Glass, 1872 在我上大学的时候，不少关于 \\(X\\) 的课程始于下面这样的问题： 什么是 \\(X\\)？（\\(X\\) 的定义） 学好 \\(X\\) 在理论上有什么意义？ 学好 \\(X\\) 在实践上有什么意义？ 怎样学好 \\(X\\)？…… 然后给出一些答案和细节，构成该课程的「绪言」。近年来，一些新出版的教科书仍沿袭这样的惯例，甚至「读经风」也要从「为什么要读」「读什么」和「怎样读」等问题刮起。这门课叫「符号逻辑」，是当代逻辑即数理逻辑的入门课程。按惯例，好像也该先讲讲什么是逻辑，什么是符号逻辑，什么是当代逻辑，为什么要学及如何学好逻辑，等等。 像「逻辑是什么」或「当代逻辑是什么」这类问题，如果问的是逻辑或当代逻辑等的定义，那么我劝初学者不必太认真。初学逻辑，自然想知道逻辑学大概是怎么回事，想知道逻辑学家大概做些什么。但是，若想满足这种好奇心，与其在脑子里装些不明不白的「定义」，倒不如对逻辑学里讨论的问题以及讨论的方法多一点认真。这是因为：对一个学科的整体上的理解，是以对该学科中的问题和方法的理解为前提的。当然，这并不是说，关于逻辑或数理逻辑的各种说法都不值得思考。这里的要点是：不具备足够逻辑知识的人，分不出这些说法的好坏高低，反而容易因为学了某些「定义」「分类」或「方向」，就自以为有些「逻辑学问」甚至「超逻辑学问」了。待到真有点逻辑学问后，再来思考这类问题为时不晚——只要那时还有这种兴趣。 在这门课上，把逻辑作为学科来谈时，通常都是指当代的形式逻辑，也称当代逻辑、现代逻辑或（广义）数理逻辑。我们虽不定义逻辑是什么，但以普通人的知识为背景，我们可以随便谈谈逻辑学大概讨论些什么问题。关于逻辑学有以下几种说法： 逻辑学是关于论说（argument）的。 逻辑学是关于推理（inference, reasoning）的。 逻辑学是关于理论或信念的一致性（consistency）的。 1.1 论说 无论是关于整个世界的某种看法，还是关于一类事物的某种理论，都是由一些句子来表达的。这些句子大体上可以分为两类：真句子和假句子。 在很多情况下，确定一个句子的真假的最基本方法是直接考察句中所谈的事物。但是，直接考察经常是做不到或不易做到的。因而，为确定一给定句子 \\(\\varphi\\) 的真假，人们往往需要比较 \\(\\varphi\\) 和某些已知其真假的句子 \\(\\psi_0\\),…,\\(\\psi_n\\)。即使只考虑是否应该相信 \\(\\varphi\\)，我们也常需比较 \\(\\varphi\\) 和某些我们相信或不相信的句子 \\(\\chi_0\\),…,\\(\\chi_n\\)。从 \\(\\psi_0\\),…,\\(\\psi_n\\)（或 \\(\\chi_0\\),…,\\(\\chi_n\\)）到 \\(\\varphi\\) 或其否定的过渡，通常被称为「推理」。(Henkin, 1967) 在上述语境中，\\(\\psi_0, \\cdots, \\psi_n\\)（或 \\(\\chi_0, \\cdots,\\chi_n\\)）常被称为「前提」，\\(\\varphi\\)（或其否定）常被称为「结论」。人们把一集前提和从它得出的结论合起来，称之为论说，亦称论证（argument）。这里，「推理」指从前提得出结论的过程，而「论说」指前提和结论的集合。考虑下面的两句话，从中我们能得出什么结论？ 例 1.1 (宝宝的爱) 人人都爱我的宝宝。 我的宝宝只爱我。 人们可以去编些故事，比如说，「我」指某人，「宝宝」指她（他）的孩子或情人，等等。但假定张三说，他从例 1.1 得出「我的宝宝就是我」，我们会同意吗？张三是这样得出他的结论的（用「宝宝」代替「我的宝宝」）： 既然人人爱宝宝，而宝宝是人，所以宝宝爱宝宝。「宝宝只爱我」说的是：对任何 \\(x\\)，如果宝宝爱 \\(x\\)，那么 \\(x\\) 就是我；从而如果宝宝爱宝宝，那么宝宝就是我。既然宝宝爱宝宝，所以宝宝就是我。 通常人们用下述方法表示一个论说：将其前提和结论列出，用一道线将前提与结论分开，并在结论前加上「\\(\\therefore\\)」表示「所以」。比如，张三从例 1.1 中的前提到结论「我的宝宝就是我」的论说就可以表示为： 例 1.2 (我的宝宝就是我) 人人都爱我的宝宝。 我的宝宝只爱我。 所以，我的宝宝就是我。 1.1.1 论说的好坏 论说有好有坏。逻辑学要做的事情之一，就是区分好的论说与坏的论说，或者说是给出一般的方法，而依据这些方法，我们能对论说的好坏作出正确的判断。这大概是对逻辑的最常见的一种说明。要说明上述示例是否好的论说，先要说明什么样的论说是好的，什么样的是不好的。对此，最直观又最简单的说法与下面说的差不多： 对任何一个论说，如果在每个使其前提都真的情况下，其结论也一定真，那么这个论说是好的；如果在某些情况下，该论说的前提都真而结论假，那么这个论说就是坏的（不好的）。 这种直观的说法可以让人对论说的好坏有个初步的印象，但不够清楚准确。比如，什么叫作「使前提都真的情况」，什么叫作「在某个情况下，一个命题是真的」，等等，现在都还不清楚。这种说法的优点，是它强调了论说的好坏不在于前提和结论的真假，而在于它们的真假在不同情况下的比较。 1.1.2 论说形式的好坏 一个具体论说的好坏与其前提和结论的真假无关：一个好论说的前提和结论可能都是假的，而一个坏论说的前提和结论也可能都是真的。（注：论说本身的好坏与论说形式的好坏是相互区别而又有联系的两个问题。）比如下面这个论说： 例 1.3 (企鹅与猴子) 企鹅都是鸟。 猴子都不是企鹅。 所以，猴子都不是鸟。 它的前提和结论都是真的，但人们仅凭直观就知道这个论说是不好的；人们会说：不是企鹅的不一定就不是鸟，比如说麻雀就不是企鹅，但不能因此说麻雀不是鸟。企鹅的确都是鸟，猴子的确都不是企鹅，并且猴子也的确都不是鸟；但是，最后一个命题之前的「所以」是没道理的。再看下面的论说： 例 1.4 (爱运动的男生) 爱运动的学生学习成绩都很好。 男学生都爱运动。 所以，男学生学习成绩都很好。 它的前提和结论都是假的，但整个论说似乎无懈可击。 常听到争论中的人说：「即使你的论证没问题，你的前提本身就是假的，结论当然也是假的。」这是一种常见的误解，仿佛好论说会「保存」虚假性，即会把前提的虚假性传到结论上。例 1.5 表明好论说并不保存虚假性： 例 1.5 (猫都是人) 所有的猫都是人。 所有的学生都是猫。 所以，所有的学生都是人。 易见两个前提都是假的，结论是真的，而整个论说也无懈可击。 前提有真有假的好论说或坏论说的例子也很多，不一一列举了。一般说来，真、假前提和真、假结论的各种组合情况，就坏论说而言都是可能的；就好论说而言也差不多，只有一个例外：好论说不会有真前提和假结论。 上面说过，对任何一个论说，如果在每个使其前提都真的情况下，其结论也一定真，那么这个论说是好的。所谓使前提都真的情况，简单地说就是能使所有前提同时成立的一种解释，而这种解释既可以是现实也可以和现实无关。比如我们讨论例 1.3 中的坏论说时，给出的理由是「麻雀不是企鹅，但不能因此而说麻雀不是鸟」。这相当于把「猴子」换成了「麻雀」或是把「猴子」解释成了麻雀。当然，这是不够清楚的说法。清楚一些的说法涉及「论说的形式」（argument form）。我们暂时依赖直观判断什么是一个论说的形式： 例 1.6 (论说及其形式) 所有的猫都是人。 张三是猫。 所以，张三是人。 其直观形式为： 所有 \\(S\\) 是 \\(P\\)。 \\(a\\) 是 \\(S\\)。 所以，\\(a\\) 是 \\(P\\)。 再如下列是例 1.3 的论证形式： 所有 \\(S\\) 是 \\(P\\)。 所有 \\(Q\\) 都不是 \\(S\\)。 所以，所有 \\(Q\\) 都不是 \\(P\\)。 下列是例 1.4 的论证形式： 所有 \\(S\\) 是 \\(P\\)。 所有 \\(Q\\) 是 \\(S\\)。 所以，所有 \\(Q\\) 是 \\(P\\)。 不同的论说可以有相同的形式，而具有相同形式的论说称为这个论说形式的特例（instance）。例如，例 1.7 中有两个不同的论说，但它们的形式同是上列例 1.3 之形式，并且同是该形式之特例： 例 1.7 (论说形式之特例) 企鹅都是鸟。 猴子都不是企鹅。 所以，猴子都不是鸟。 下列论说与上一论说形式相同： 企鹅都是鸟。 麻雀都不是企鹅。 所以，麻雀都不是鸟。 一个论说形式的众多特例中有一类被称为「反例」。一个论说形式的反例（counter example）是这个论说形式的特例，其所有前提都是真的，而其结论是假的。如果一个论说形式没有反例，那么该论说形式是好的；如果一个论说形式有反例，那么该论说形式是坏的（不好的）。 1.1.3 论说好坏取决于形式的好坏 一个论说的形式是好的（亦即它的形式没有反例），则称其为好的论说。一个论说的形式是坏的（亦即它的形式有反例），则称其为坏的论说。 既然具体论说的好坏在于它的形式的好坏，那么就任何具体论说而言，它的（前提和）结论真不足以说明它好，而它的（前提和）结论假也不足以说明它坏——它的好坏在于同样形式的特例中有没有前提真而结论假的论说。由此可知，要说明一个论说是坏的论说，最直接的方法是去找一个与它形式相同且前提真而结论假的论说。 我们来看如何说明一个论说是坏的论说。先考虑例 1.7 下方的论说，易见它的前提都真而结论假；我们知道其形式是例 1.6 所列之形式，所以它是例 1.6 左列形式的反例。既然例 1.6 所列形式有反例，它就是坏的论说形式。现在来看例 1.3 中的论说，亦即例 1.7 左侧的论说，其形式也是例 1.6 所列之形式。我们现在知道例 1.6 所列形式是坏的论说形式，所以，例 1.3 中的论说是个坏的论说。我们来看另一个论说： 例 1.8 (论说形式与内容) 浩毕特都生活在沙伊鄂。 拜根斯都是浩毕特。 所以，拜根斯都生活在沙伊鄂。 其论说形式为： 所有 \\(S\\) 是 \\(P\\)。 所有 \\(Q\\) 是 \\(S\\)。 所以，所有 \\(Q\\) 是 \\(P\\)。 在了解「浩毕特」「沙伊鄂」和「拜根斯」的意思之前，我们无法判断例 1.8 论证的前提或结论的真假。但是，我们知道其形式。 这个形式有下述特点：无论把什么类名词放在 \\(S\\)，\\(P\\) 或 \\(Q\\) 的位置上，都不会得到具有真前提和假结论的论说，即不会得到例 1.8 所列形式的反例。这就是说，例 1.8 所列之形式是好的论说形式。因为例 1.8 所列之论说是例 1.8 所列之形式的特例，所以它是个好的论说。 然，说一个论说形式没有反例，并非仅仅是说没有找到它的反例，因为没找到反例不等于没有反例。例 1.8 所列之论说形式比较简单，容易看出它不会有反例；但是，一个好的论说形式可以很复杂，仅靠直观未必能说出它是否有反例。这门课程的任务之一，就是学会判别好坏论说形式的若干方法。 如果承认一个论说是好的，那么接受其前提就无法理性地拒绝其结论，从而否定其结论也就无法理性地坚持其前提；如果断定一个论说是坏的，那么接受其前提的同时可以拒绝其结论。用逻辑术语来说，如果一个论说是好的，那就意味着它的前提「逻辑蕴涵」（logically implies）它的结论（当代逻辑不仅讨论给定命题集合是否逻辑蕴涵某给定命题，它更要突破具体命题和具体命题集合的限制，把逻辑蕴涵关系作为对象来讨论。），或者说结论是前提的「逻辑后承」（logical consequence）；如果一个论说是坏的，那就意味着它的前提和结论之间没有逻辑蕴涵关系，亦即结论不是前提的逻辑后承。我们将在第一编中讨论逻辑蕴涵的一种简单形式——重言蕴涵（重言后承），而在第三编中讨论逻辑蕴涵（逻辑后承）。 1.2 演绎 前面列举的关于逻辑学的几种说法中，有一种是「逻辑学是关于推理的」。当谈到论说的好坏与推理的关系时，也有类似于下述命题的说法：对任何一个论说，如果从其前提能够合理地推出其结论，该论说就是好的；如果从其前提不能合理地推出其结论，该论说就是坏的（不好的）。 所谓「合理地推出结论」，通常被理解为一个末端是这个结论的推理链（chain of reasoning），它可以只有一两步，也可以有很多步，但（关键的是）每一步都要「合理」。对「合理性」的各种要求或解释，形成了不同类型的推理链。演绎（deduction）是这些类型中的一种。 演绎对「合理性」的基本要求是：「推理链」中的每个推理步骤，如果不是前提、定义、预设、公理、假设等或已经从这些东西「合理地」推出的命题，那么一定是从它们用某些明确的规则得到的。这些明确的规则都要有如下性质：在演绎中使用这些规则时，人们从真命题只能得到真命题。众所周知的各种三段论、假言推理规则和选言推理规则等就属于这种规则。（演绎中也常用被称之为「引理」和「定理」之类的东西。它们虽与公认的规则不同，但因为它们也是经演绎得到的，所以可以把它们看作是已经「合理地推出」的命题。）如此说来，至少直观上看，演绎像是将一个个好的论说接起来——它一步步推出的每个命题都是该命题前面某些命题的逻辑后承。 1.2.1 演绎的例子一 数学证明都是演绎的例子，我们就不列举了。这里来看另一类例子。上一节谈到例 1.2 之论说，我们曾假定张三给岀了他的说明。那个说明其实就是个演绎的例子。虽然那个说明中的命题并没有列成链，而对每一步到下一步的过渡，也没说明是运用了什么规则；但是，人们可以把例 1.2 的说明「还原」成符合上述说法的演绎： 例 1.9 (宝宝的演绎) 所有的人都爱我的宝宝。➠ 前提（经过复述） 我的宝宝是人。➠ 预设 我的宝宝爱我的宝宝。➠ 三段论 我的宝宝只爱我。➠ 前提 对每个 \\(x\\)，如果我的宝宝爱 \\(x\\)，那么 \\(x\\) 就是我。➠ 「按定义改写」 如果我的宝宝爱我的宝宝，那么我的宝宝就是我。➠ 特例 我的宝宝就是我。➠ 肯定前件的假言推理（modus ponens） 上述演绎「还原」的文字过程，可按照后续章节介绍的谓词逻辑的自然演绎方法表现。设定论域为人，\\(\\mathbf{a}\\) 为「我」，\\(\\mathbf{b}\\) 为「我的宝宝」，\\(Px\\) 表示「\\(x\\) 是人」，\\(Lxy\\) 表示「\\(x\\) 爱 \\(y\\)」，则本例推理过程可表述为（学完相关章节后再阅读这个自然演绎的例子）： 当然，这个例子难免让人觉得怪。比较近情理的一个说法是：对于「所有的人都爱我的宝宝」这句话，人们往往不把其中的「所有的人」理解为所有的人，而是理解为宝宝以外的所有人。根据这种说法，从「所有的人都爱我的宝宝」应该得不出「我的宝宝爱我的宝宝」，进而从上述两个前提应该得不出「我的宝宝就是我」这个结论。 「所有的人」的这种「…以外的所有的人」的用法，是个习惯或语境的问题，而非命题的逻辑结构或推理的问题。显然，我们不能说「所有的人」的意思就是「宝宝以外的所有的人」的意思，因为在「所有的人都要睡觉」「所有的人都要吃饭」等句子中，「所有的人」显然不是指宝宝以外的所有的人。当然我们就更不能说「所有的 \\(S\\) 是 \\(P\\)」中的「所有的 \\(S\\)」应理解为宝宝以外的所有的 \\(S\\)。如果把「所有的人都爱我的宝宝」的形式概括为「所有的 \\(S\\) 都与 \\(a\\) 有关系 \\(R\\)」（其中 \\(a\\) 是某个 \\(S\\)，就像我的宝宝是人），那么「所有的 \\(S\\)」在句子中的意思是否就是所有不等于 \\(a\\) 的 \\(S\\) 呢？有些时候是这样，但显然也并不总是这样。 比如，正常人不会认「所有的正整数都大于 1」这一命题是真的，因为正整数 1 不大于 1。然而，假如「所有的正整数」的意思就是所有不等于 1 的正整数，那么我们就必须承认这是个真命题。这样的例子太多了。日常会话中，我们习惯于怎么省事怎么说，「差不多就行」，甚至应该尽可能避免繁琐。但我们谈到理论问题时，「差一点」也不行。上面的例子告诉我们，如果在我们的理论中，我们把下列命题中的「除了 \\(a\\)」漏掉了， 所有的 \\(S\\) 都与 \\(a\\) 有关系 \\(R\\)，除了 \\(a\\). \\(a\\) 是 \\(S\\) 且只与 \\(b\\) 有关系 \\(R\\). 那么「\\(a\\) 就是 \\(b\\)」就成了从我们理论中可以演绎出来的一个结论，尽管我们可能并不想要它。 1.2.2 演绎的例子二 我们来看另一个演绎的例子。据说，有人曾针对古典逻辑（注：「古典逻辑」是狭义的数理逻辑的另一个名字。狭义的数理逻辑包括「四论」（公理集合论、模型论、递归论和证明论），也包括本书讨论的命题逻辑和一阶逻辑等理论。在当代逻辑范围内，古典逻辑范围外，还有众多逻辑分支，俗称「非古典逻辑」。）「从假命题可推出任何命题」这一特点向罗素挑战，要他从「2+2=5」推出「罗素和教皇是同一个人」，罗素当即以下述演绎（或类似的演绎）作出回应： 例 1.10 (从假命题可推出任何命题) 2+2=5 ➠ 假设 2=3 ➠ 等词法则（等式两边各减 2） 3=2 ➠ 等词法则（对称性） 2=1 ➠ 等词法则（等式两边各减 1） 罗素和教皇是两个人。 ➠ 事实 罗素和教皇是同一个人。 ➠ 等词法则（运用上述「2=1」） 这个演绎也有点「怪」。上一个例子的前提「所有的人都爱我的宝宝」，虽然未必是真的，但在某些情况下可能是真的，至少我们不知道它是否在任何情况下都是假的。在这个例子中，我们却知道前提「2+2=5」在任何情况下都是假的。演绎和好的论说一样，它并不考虑前提或结论的真假。只要推演规则的选择适当，运用这些规则得到的命题都是前提的逻辑后承，亦即演绎保存真实性。正因如此，演绎不仅仅可以用来（从正面）说明某个命题的真实性，它同样可以用来（从反面）说明某个命题的荒谬性。当然，演绎并不保存荒谬性，可以从荒谬的命题演绎出的不仅仅是荒谬的命题。 1.2.3 可演绎性、可证性和独立性 如果从一集命题（理论、前提或假设）演绎出了某个命题 \\(\\varphi\\)，那么 \\(\\varphi\\) 当然是从这集命题可演绎（deducible）的。从集命题可演绎的常被称为这集命题的演绎后承（deductive consequence）。没有前提的演绎称为证明，无需前提就可演绎的称为可证明的或可证的（provable）。说一个命题是不可证或从给定命题集不可演绎，不是说没有找到它的证明或演绎，而是说不存在这样的证明或演绎。（注：当代逻辑不仅研究某些给定命题是否可证或可演绎，它更系统地研究可证性（可演绎性）和不可证性（不可演绎性）。注意：可证性和可演绎性都是相对于演绎「系统」来谈的。对于不同的演绎「系统」，一个命题是否可证或从一集命题是否可演绎的问题，完全可以有不同的答案。） 独立性就是不可演绎性，只不过它多用于人们感兴趣的命题。一个系统不可证明的命题通常很多，人们不会对所有这些命题都有同样的兴趣。人们有兴趣的命题在一系统中是否不可证，常被称为这些命题的（相对于该系统的）独立性（independence）问题。比如，「独立性」很多时候被用在系统的公理上。给定一个系统和系统中的一个公理 \\(\\varphi\\)。如果从 \\(\\varphi\\) 以外的所有公理经系统的全部推理规则不可证明 \\(\\varphi\\)，那么 \\(\\varphi\\) 就是独立的。换句话说，该系统的全部推理规则和 \\(\\varphi\\) 以外的所有公理构成该系统的一个子系统，而如果 \\(\\varphi\\) 在这个子系统中不可证，我们就称 \\(\\varphi\\) 是独立的（independent）。对于一个系统的公理集合，如果其中每个公理都是独立的，我们就称这个公理集合是独立的。 1.2.4 可演绎性与论说 至此，我们已经初步了解了检验论说好坏的两种基本方法：演绎和对论说形式的检验。这两种方法之间有没有关系呢？ 我们说过，演绎对推演规则的要求是从真命题只能得到真命题。读者可能已经由此猜测：如果从一个论说的前提能够演绎出它的结论，这个论说的形式就是好的。事实上，这个猜测是正确的，而肯定其正确性的定理称为「可靠性定理」。 进一步的问题是，如果从前提演绎不出结论，那是否意味着这个论说的形式一定是不好的呢？或者换个方式来问，如果一个论说的形式是好的，是否一定有一个从它的前提到它的结论的演绎呢？这个命题的答案就本书讨论的演绎系统来说也是肯定的。给出这一问题肯定答案的定理称为「完全性定理」。 演绎和论说虽然关系密切，但它们在某些方面是很不同的。论说的好坏离不开真或假的概念。然而，演绎在一定程度上可以是机械的，与真和假的概念无关。对于确定的公理、假设和推演规则，我们可以逐个去试，看运用每一条公理、假设和规则能得到什么；而只要有足够长的时间和足够大的空间，凡是可演绎出来的命题，我们终究可以找到它的一个演绎。虽然这种办法很笨，而且谁也没有那么多时间把公理、假设和规则一个个地去试；但从理论上说，用这种笨办法总能找到可演绎命题的演绎。这里的关键是：在构造或寻找演绎的过程中，人们可以完全不考虑命题的真假，甚至可以根本没有真和假的观念——他们可以仅仅把规则运用于各个命题，而且在这样运用时又仅仅考察这些命题的形式结构。 1.3 一致性 1.3.1 关于一致性的基本想法 通常，我们可以说某人言行（不）一致，指的是此人说的和做的（不）一样。这和逻辑里说的一致性不同。逻辑里说的一致性（consistency），从直观上说就是不自相矛盾，不自打嘴巴，或者是能说得过去，能自圆其说，或者是相关的各命题可以相安无事，等等。（注：参见 §2.5.3（P.88）中的「可满足性」分析。）也有人把一致性叫作自恰。有时我们也会说一个理论和另一个理论不一致，或一组信念与另一组信念不一致，等等。在这种情况下，我们的意思是说，把这两个理论或这两组信念合在一起就不一致。 很多时候，说一个理论（或一集信念）是一致的，意思是说，在适当的解释下，这个理论中的所有命题都同时是真的；而说一个理论（或一集信念）是不一致的，是说在任何解释下，这个理论中的命题都不会同时是真的。这种一致性的观念是一种「语义」观念，我们可以称它为「语义一致性」。当代逻辑中还有另一种一致性的观念：对于每一个理论，如果从它不能演绎出任何一对矛盾的命题，那么它就是一致的；否则，它就是不一致的。这种一致性的观念是一种「语法」观念，我们可以称它为「语法一致性」。在当代逻辑研究中，「一致性」通常指语法一致性，而语义一致性被称为「可满足性」。 语法一致性和语义一致性有如下关系： 相对于给定的演绎系统，如果语义一致的理论都是语法一致的，那么该系统一定有「可靠性」，亦即从前提可演绎的都是这些前提的逻辑后承。 相对于给定的演绎系统，如果语法一致的理论都是语义一致的，那么该系统一定有「完全性」，亦即只要是前提的逻辑后承都从这些前提可演绎。（注：这一节中有几个命题，其真实性对初学者来说可能不那么明显。我们并不打算在此处详细讨论这些命题，而会在后面讨论它们。所以，即使现在不明白这些命题为什么成立，初学者也不必因此而对逻辑心生畏惧；读完这本讲义后回头来看这些命题时，就会明白它们成立的理由了。） 1.3.2 不一致命题集的例子 一个不一致的命题集合，如果其中的命题比较简单且数量很少，那么它的不一致性通常容易被发现。那些直接包含矛盾的命题集显然是不一致性的。比如： 海德格尔是纳粹。 海德格尔不是纳粹。 在任何解释下，如果这两个命题之一是真的，则另一个不可能是真的；所以任何解释都不能使这集命题同时成立。 在一定预设或直观背景下，有些不一致的命题集虽不是简单地包含一个命题和它的否定，但可以导出一对直接否定对方的命题。比如： 吾盾之坚，物莫能陷也。 吾矛之利，于物无不陷也。 如果那个卖矛和盾的人既有矛 \\(a\\) 又有盾 \\(b\\)，那么由上述言论即可导致「\\(a\\) 不能陷 \\(b\\)」和「\\(a\\) 能陷 \\(b\\)」的矛盾。 有些命题集只含一个命题，但仍能导出矛盾的命题。比如「这位理发师为且只为所有不为自己理发的人理发。（注：这是集合论中罗素悖论的通俗形式，俗称「理发师悖论」。）」通过这个命题我们知道： 这位理发师只为那些不为自己理发的人理发（即不为任何为自己理发的人理发）。 这位理发师为所有不为自己理发的人理发。 这位理发师要么为自己理发要么不为自己理发。但是，如果他为自己理发，那么根据第 0 条他就不为自己理发；而如果他不为自己理发，那么根据第 1 条他就为自己理发。 有些不一致的命题集合，其中任意一对命题都不导致矛盾，甚至去掉其中任何一个命题的结果都是一致的。比如： 例 1.11 (不一致的命题集) 哲学家都是求真的人。 求真的人都不喜欢神侃。 张三是哲学家。 张三喜欢神侃。 请读者检查：这个命题集不一致，尽管从中任选三个命题都一致。 1.3.3 一致性、逻辑蕴涵与可演绎性 理论或信念的一致性和它们的「真实性」或「正确性」是不同的。逻辑学本身不注重其他学科的具体理论或信念的真伪，（注：从某种意义上说，逻辑学非常重视数学理论的真伪，弗雷格和罗素等甚至深信数学可以归结为逻辑。这有点离题了。总之，至少可以说，逻辑学本身不注重逻辑和数学之外的具体理论或信念的真伪。）但注重这些具体理论和信念内部各命题之间的关系，或不同理论、不同信念集合之间的关系；正如逻辑不注重具体论说的前提或结论的真伪，但注重这些前提与结论之间的关系。一个理论或一组信念的一致性，或更一般地，一集命题的一致性，是这集命题为真的必要条件。如果一个理论不一致，那么这个理论的内部有互不相容的命题，而任何一种解释都不能使这个理论中的所有命题同时成立。一个理论或一种信念被人们相信或接受，通常不会仅仅因为它是一致的；但如果它不一致，它就是不可接受的。 一致性与逻辑蕴涵和可演绎性是「相通」的（就本书涉及的系统而言）： 如果一个理论不一致，那么对其中的任何命题，该理论的其他命题一定逻辑蕴涵它的否定。 如果一个理论是一致的，那么对其中的任何命题，该理论的其他命题不会逻辑蕴涵它的否定。 如果一个理论不一致，那么对其中的任何命题，它的否定从该理论的其他命题一定可演绎。 如果一个理论是一致的，那么对其中的任何命题，它的否定从该理论的其他命题一定不可演绎。（注：把一致性理解为语义一致性时，上述第三个命题等价于「完全性定理」，第四个等价于「可靠性定理」；而把一致性理解为语法一致性时，上述第一个命题等价于「可靠性定理」，第二个等价于「完全性定理」（后两个合起来是定理334）。） 为了简单地说明上述命题的意思，我们来看例 1.11。我们说过，这个「理论」是不一致的。例 1.11 命题 1 的否定可以从命题 2, 3, 4 演绎出来（或被它们逻辑蕴涵）： 由命题 2, 4 知，张三不是求真的人，再与命题 3 合并，得知张三是哲学家但不是求真的人，进而得到：有些哲学家不是求真的人，即命题 0 的否定。 接下来我们看例 1.11 中命题 2 的否定可以从命题 1, 3, 4 演绎出来（或被它们逻辑蕴涵）： 由命题 1, 3 知，张三是求真的人，再与命题 4 合并，得知张三既是求真的人又喜欢神侃，进而得到：有些求真的人喜欢神侃，即命题 1 的否定。 至于例 1.11 中命题 3 的否定和命题 4 的否定是否的确可以分别从其他三条命题演绎出来（或分别被它们逻辑蕴涵），这里就不讨论了，留给读者思考。 1.4 逻辑或「逻辑」的若干问题 近年来，一些与逻辑或「逻辑」有关的谈论实在有些离谱，我们在这里不得不说几句。 1.4.1 「逻辑是什么」不是逻辑问题 在中国，「逻辑是什么」或「什么是逻辑」这类问题谈的特别多，学生们也好奇。一位美国逻辑学家在访问中国期间，曾应邀在某次学术讨论会上做了报告。事后，有一次他和我通电话，谈起那次会议。我问他与会者对他发言的讨论情况，他回答说，没什么逻辑问题，基本上就是问「逻辑是什么」。 学逻辑的人首先应该明白：「逻辑是什么」这类问题都不是逻辑问题。如果我们去上数学课或物理课，或是去读一篇数学论文或物理学论文，老师或作者会在那里大谈数学是什么或物理学是什么吗？不会，至少通常不会。相反，他们会讨论一些具体的数学或物理问题，会告诉我们如何解决这些问题；他们也会讨论一些理论，会告诉我们这些理论如何解决若干类问题。相反，如果我们去上国内流行的哲学课或读一篇哲学论文，遇到对具体哲学问题的讨论的概率几乎就是零。所以，从这样的角度来看，逻辑学像科学（注：本讲义中，「科学」指数学和被称为自然科学的那些学科。我们无意在这里涉及科学哲学中关于数学是否科学的问题，也无意介入对类似问题的讨论。自然，一旦数学是科学，当代逻辑学也应是科学，因为无论是就对象还是就方法而言，当代逻辑学与数学的类似都不亚于任何其他被称为科学的学科。）而不像国内流行的哲学，因为逻辑学研究各种各样的具体的逻辑问题。 「逻辑是什么」这类问题，当然可以讨论。这样的讨论有两种。一是随便谈谈看法，二是认真的学术讨论。如果是随便谈看法，即使是外行来谈，只要谈的不是太离谱人们也不会去较真，因为任何人都可以有自己的看法。（注：“Few men think, yet all will have opinions?” — George Berkeley, Three Dialogues between Hylas and philonous, 1713.）认真的学术讨论则不同，它决不像外行或初学者想像的那么简单，而且即使讨论者的态度是十二分的认真，也未必能使人严肃认真地对待他们的讨论。这是因为，要认真讨论「逻辑是什么」这类问题，首先要熟悉逻辑，要有较全面的学识和较好的修养。倘若只读了几本逻辑教科书，甚至连像样的教课书都没好好读过，那么讨论「逻辑是什么」这类问题是不会得要领的，从而无法指望内行人认真对待这样的讨论。 总有一些人，逻辑没入门，却偏偏热衷于谈论「逻辑是什么」，「逻辑学有多少种」，「逻辑研究有几个层面」和「逻辑学的发展方向」，等等。他们把外行话当「学术论文」写，当「学术报告」讲，甚至不惜误人子弟也要把这些东西炒响做大。真想学点逻辑的人要小心：这些东西只和「逻辑」这个名称有关，和逻辑学的内容不沾边。任何人把自己做的事称作「对科学研究的贡献」，都只是他个人的事；但如果以为只要能炒响做大，内行们就不得不认真对待，甚至不得不承认，那才是典型的科学外行的一厢情愿。 1.4.2 逻辑与「逻辑」的用法 有「专家」说，要想确定逻辑是什么，就要看历史上和现实中人们怎么用「逻辑」这个词，并声称只有这样得出的看法才是「客观的」。于是，经过对「逻辑」用法的一番「考察」得出结论：逻辑除亚里士多德逻辑、数理逻辑和概率逻辑，还有方法论和知识论、非形式逻辑和辩证逻辑，共有五六种。 按说，当「专家」一本正经地谈「学术」时，总不至于信口开河；可我们的「专家」实在不争气。单看结论就已令人大跌眼镜，因为仅凭常识也知道「逻辑」的用法远不止这五六种。 用 google 搜索一下就有以下结果：当代逻辑（数理逻辑、古典逻辑、哲学逻辑、非古典逻辑）、形式逻辑、归纳逻辑、概率逻辑、传统逻辑、发现的逻辑、辩证逻辑、非形式逻辑、自然语言逻辑、模糊逻辑、人工智能逻辑、中国古代逻辑、法律逻辑、经济逻辑、商业逻辑、商务逻辑、资本逻辑、营销逻辑、地产逻辑、自然逻辑、人文逻辑、社会逻辑、教育逻辑、文学逻辑、历史逻辑、艺术逻辑、审美逻辑、男性逻辑、女性逻辑、愤青逻辑、痴呆逻辑、行政逻辑、和谐逻辑、创新逻辑、文化逻辑、潜逻辑、足球逻辑、致富逻辑、运气逻辑、统治逻辑、专制逻辑、官场逻辑、官僚逻辑、升官逻辑、军阀逻辑、土匪逻辑、强盗逻辑、流氓逻辑、痞子逻辑、骗子逻辑、厕所逻辑，等等。 「逻辑」的诸多用法显然无法对应于「专家」说的那五六种逻辑，这一事实不仅无法否认，而且与「专家」的前提和结论无法同世而立。所以，如果我们的「专家」不肯放弃他的前提或结论，那就只会让自己落到全无逻辑的地步。（这也是「逻辑」的一种用法!） 外行人如何使用「逻辑」这个词，逻辑学者通常没必要认真，因为「逻辑」这个词早被人们或有意或无意地滥用，在很多情况下与作为一个学科的逻辑学没什么关系，正像「科学」这个词的很多用法与科学没什么关系一样。按说，内行人不在乎外行人对他们的学科怎么说一一科学家不在乎哲学家怎么定义科学就是很好的说明；那么，我们的「逻辑专家」在界定逻辑学时，何以恰恰相反，求助于外行关于「逻辑」的说法呢？套用一句话：这种人其实是外行，或者装作是外行。（二狗：「逻辑」有很多种，「逻辑学」也有很多种。） 1.4.3 逻辑与「习惯的说理方式」 地球是否围绕着太阳转？每个大于 1 的自然数是否都是某些素数的积？这些科学问题的答案和人们的习惯看法无关。同样地，从「如果 \\(\\varphi\\) 则 \\(\\chi\\)」和「如果 \\(\\psi\\) 则 \\(\\chi\\)」是否可推出「如果 \\(\\varphi\\) 或 \\(\\psi\\) 那么 \\(\\chi\\)」，也和人们的说理习惯无关。逻辑区分好的说理和坏的说理，但不以人们习惯的说理方式为根据。 记得曾有人主张「有些 \\(S\\) 是 \\(P\\)」蕴涵「有些 \\(S\\) 不是 \\(P\\)」，理由就是人们常这样说理，比如从「有些学生迟到了」推岀「有些同学没迟到」，等等。令人费解的是，这些人大都承认，从「所有 \\(S\\) 是 \\(P\\)」可以「合理地」推出「有些 \\(S\\) 是 \\(P\\)」（假定说「所有\\(S\\) 是 \\(P\\)」时总有 \\(S\\) 存在），却看不出这样一来，从「所有 \\(S\\) 是 \\(P\\)」就可以「合理地」推出「有些 \\(S\\) 不是 \\(P\\)」，于是可以「合理地」推出逻辑矛盾。把习惯的说理方式看作合理的说理方式，其结果只会是混乱。 近来更有人把文化问题装扮成科学问题，宣称存在不同的逻辑，其理由是不同文化中人们有不同的说理方式和习惯。按照这种人的说法，不仅中国人的说理方式和习惯与西方人的不同，汉族的说理方式和习惯与其他民族的也不同；所以中国有中国的逻辑，西方有西方的逻辑；汉族有汉族的逻辑，其他民族有其他民族的逻辑。同时，为了表明这种「理论研究」有社会效益，还特意为它插上「有助于各民族的相互了解」和「有利于社会发展」的标签。 不同文化中，人们的确可以有不同的说理方式和习惯；但同一个文化中，人们照样可以有不同的说理方式和习惯。倘若说理方式和习惯的不同真能说明存在不同的逻辑，那么，岂止是各国可以有各国的逻辑，或各民族可以有各民族的逻辑？各地区也可以有各地区的逻辑，各校又可以有各校的逻辑，甚至个人还可以有个人的逻辑——谁没有自己的说理方式和习惯呢？这世界上有一类人，他们习惯的说理方式是「空着肚子说气壮的话」，以自称「永远不会错」为这类气壮话的典型。这能否说明存在一种与之相应的「逻辑」，进而也该对它做一番「研究」呢？ 假如今天哪个文化圈里的人习惯地认为圆周率是 3，或习惯地认为一万乘以一万就是无穷，那么头脑正常的人不会因此而声称存在不同的数学。假如昨天发现了某个远离现代社会的原始部落，那里的人都习惯地认为太阳绕着地球转，或认为人是猫变来的，那么头脑正常的人也不会因此而声称存在不同的物理学或生物学。偏偏中国的哲学和逻辑学先天不足，后天失调，「不同说理方式和习惯导致不同逻辑」这类昏话，竟也可以被称作学术研究而登堂入室。 1.4.4 当代逻辑、传统逻辑和「普通人需要的逻辑」 这门课叫「符号逻辑」，取这个名字只是为区别于其他逻辑课程，如「数理逻辑」等；但这些课程名称的不同，并不意味着符号逻辑和数理逻辑是不同的逻辑。在国际主流逻辑学界，「符号逻辑」「数理逻辑」「形式逻辑」「当代逻辑」通常都是指同一个东西。 传统的形式逻辑（在国内曾被称为「形式逻辑」，现在多被称为「普通逻辑」或「传统逻辑」）是幼年的形式逻辑，它从根本上说只构成当代逻辑的一个很小的部分。尽管幼年的形式逻辑在人类文明史上有着不可磨灭的贡献，但随着科学的发展，它提供的逻辑观念、理论和工具，相对于科学（尤其是数学）研究的需要来说，显得越来越贫乏，越来越不足道。自弗雷格以来的当代逻辑，无论是就基础的坚实还是就方法的完善来讲，都大大超过了幼年的形式逻辑；而更重要的是，从当代逻辑研究中产生的新观念和发现的新规律，为科学的发展提供了更好的逻辑理论和工具。(Tarski, 1941)用 20 世纪最杰出的逻辑学家哥德尔的话说： 数理逻辑不是别的，就是形式逻辑的准确和完备的表述。它有很不同的两面。一方面，它是数学的一个部门，处理着类、关系、符号组合等等，而不是数、函数、几何图形等等。另一方面，它是先于一切科学的一门科学，包含着位于一切科学底层的观念和原理。(Gödel, 1944) 有些人总在抱怨：当代逻辑太技术化，太专业化了，越来越不适宜满足日常思维的实际需求。他们举出很多当代逻辑不考虑普通人需求的证据，如形式语言和数学方法等，还有很多当代逻辑课不受普通学生欢迎的故事。有些人甚至声称，数理逻辑的纯技术化和数学化发展，已经在某种程度上对逻辑的存在构成了威胁。于是他们主张搞一种源于传统逻辑而又适应普通人思维实际需要的「新逻辑」，称之为「批判性思维」或「非形式逻辑」。 「批判性思维」之类的东西，作为一种初级逻辑的教学模式，或者作为关于初级逻辑的普及和日常应用的探索，是值得鼓励的。在美国不少大学，「逻辑导论」课是通选课，虽俗称「baby logic」，但仍有不少学生难以过关；而「批判性思维」课（如果有的话），俗称「baby baby logic」，就是专为这些学生开设的。国内不少学生甚至学者在逻辑性方面的欠缺是严重的，而普通的「逻辑导论」课又似乎对他们帮助不大；因而就逻辑的教学和普及而言，我赞成借鉴甚至进口「批判性思维」这类课程。（二狗：批判性思维：foetus logic；逻辑导论：baby logic；经典数理逻辑：basic logic.）但是，就逻辑理论而言，「新逻辑」并不是新逻辑，因为无论人们的愿望是什么，它尚未提供能与当代逻辑理论相比的逻辑理论。 初级逻辑的普及和日常应用问题，甚至当代逻辑的应用问题，都可以讨论甚至应该重视；但面向大众的逻辑课是一回事，逻辑理论研究是另一回事。这问题本来很简单，就像文科学生的数学课，总不能和数学系的课一模一样；但这决不意味着「文科数学」是有别于主流数学的另一种数学。其实，即使从应用角度来说，当代逻辑的主要目标也是为理论研究、尤其是科学理论研究提供更好的逻辑理论和工具——它早已远远超出了「满足普通人日常需要」的眼界。在这方面，逻辑学和其他科学一样，其理论研究结果应该不是普通人一看就懂且马上能用的。在科学的实际应用方面，普通人包括学生大概都有发言权；但倘若评价科学理论要以外行的好恶为标准，科学理论问题要靠他们投票来解决，那么科学就不再是科学了。 当代逻辑学家既不拒绝对新问题的探讨，也不拒绝对现有理论的重新思考。惟其如此，才会出现众多的所谓新逻辑。不过，新逻辑的出现，不是靠拒绝当代逻辑的基本思想和方法，更不是靠知难而退式的「另起炉灶」。恰恰相反，这些新逻辑都是运用当代逻辑基本思想和方法的产物，进而逐步成为当代逻辑的新分支。（注：这些分支数量之多，已使精通所有分支的「全才」成为「历史人物」。十多年前去世的 A. Church 传说是最后一位「所有逻辑文章的评审员」，而这种说法显然不是针对晚年的 Church 来说的。）任何人想再搞一套逻辑都可以，但要拿出能与主流理论竞争的理论。当真要竞争，总不能比对手差太远，起码要知道对手做什么，而不能像某些「\\(X\\) 科学」的鼓吹者那样，对真正的科学一知半解，且所谓「竞争」也只限于对主流科学界的抱怨和基于非科学评价的煽情。 和任何科学一样，逻辑学研究有大量人的参与。随着学科的快速发展，除非是天才，不学习就要落后，落后严重的就会变成外行。说白了，即便是亚里士多德再世，如果他既不学当代逻辑又只能做他两千年前做出的工作，那么他也只是个亚氏逻辑专家，而不是当代的逻辑学家。这样说似乎对亚氏不敬，但逻辑学科的发展和进步使亚式逻辑成为历史却是事实。今天，只懂得毕达哥拉斯时代的数学的人不会被称为数学家，只懂得牛顿时代的物理学的人也不会被称为物理学家。根据同样的道理，只懂得亚式逻辑的人，不会是当代的逻辑学家。如今，想要成为逻辑学内行，学习当代逻辑是必由之路；而若想和当代逻辑竞争，学懂当代逻辑更是必要条件。 当代逻辑有很多分支，研究者文理各科都有，研究兴趣也不一样；但有一点是相同的，即都用形式语言和数学方法讨论逻辑问题。对当代逻辑专业化和技术化的抱怨，主要是针对这种形式语言和数学方法的抱怨。 弗雷格曾把他的概念文字与日常语言的关系比作显微镜与眼睛的关系。(Frege, 1879)眼睛的适用范围和适应环境的灵活性远远高于显微镜，然而，一旦科学研究需要更敏锐的分辨能力，眼睛就立刻让位于显微镜。尽管后者在满足普通人的实际需要方面毫无用武之地，但它不应因此而受到指责。研究方法上的改进推动科学的进步，甚至比孤立的个别发现更加重要，这在科学界已是共识。恰恰是形式语言和数学方法的运用，使人们对真假、逻辑蕴涵、演绎、证明、一致性和公理系统等的认识有了空前的提高，也使逻辑学最终走出了它的幼年时期而与其他科学站到了一起，并为其他科学的理论研究提供了大量的逻辑理论和工具。在这种情况下，抱怨形式语言和数学方法不满足日常思维的需求，就像抱怨显微镜无助于提高普通人对日常现象的观察能力；这不仅不得要领，更清楚地表明抱怨者没有跟上逻辑学科的发展，其「逻辑观」还停留在弗雷格之前的某个年代。 当然，这并不是说当代逻辑对普通人的工作和生活完全没有影响。与各种科学理论研究一样，当代逻辑要绕很多弯子才能与普通人联系上。比如，我们都知道，个人电脑和计算机网络对普通人工作和生活的影响越来越大；而当代逻辑通过个人电脑和计算机网络就联系到我们的工作和生活，只不过要兜个圈子：它先联系到计算机科学，再经后者的理论研究联系到它的应用研究和技术研究，最后再经过具体硬件和软件的开发、生产和销售等中介，才联系到个人电脑和计算机网络，才联系到我们的工作和生活。尽管当代逻辑是计算机科学的基础理论之一，但使用个人电脑和计算机网络的普通人，却不需要懂当代逻辑（即使普通的程序员也不需要懂多少）。科学就是这样：它不要求所有的人都懂，却可以使所有的人受益。 如果读者愿意学点当代逻辑，又做好了克服困难的思想准备，那么我们的「逻辑旅程」就可以开始了。不过，当代逻辑从弗雷格算起虽只有一百多年时间，但内容丰富，分支很多，而且发展很快。读者在这里能够看到的，只是它最浅显的一部分。这份讲义虽然长达几百页，一旦学懂了，大概就只剩几十页了。 Editorial comments 有屁请在此处放，看看谁的屁更响。 "],["prechap.html", " 2 预备章节 2.1 集合：属性、元素、外延 2.2 关系：集合上的结构 2.3 函数：关系之特例 2.4 基数：集合大小的度量", " 2 预备章节 天下万物生于有，有生于无。……道生一，一生二，二生三，三生万物。万物负阴而抱阳，冲气以为和。《道德经》第四十章、四十二章 2.1 集合：属性、元素、外延 2.1.1 Extensionality A set is a collection of objects, considered as a single object. The objects making up the set are called elements or members of the set. If \\(x\\) is an element of a set \\(a\\), we write \\(x \\in a\\); if not, we write \\(x \\notin a\\). The set which has no elements is called the empty set and denoted “\\(\\varnothing\\).” It does not matter how we specify the set, or how we order its elements, or indeed how many times we count its elements. All that matters are what its elements are. We codify this in the following principle. 定义 2.1 (Extensionality) If \\(A\\) and \\(B\\) are sets, then \\(A = B\\) iff every element of \\(A\\) is also an element of \\(B\\), and vice versa. Extensionality licenses some notation. In general, when we have some objects \\(a_{1}, \\cdots, a_{n}\\), then \\(\\lbrace a_{1}, \\cdots, a_{n}\\rbrace\\) is the set whose elements are \\(a_1, \\ldots, a_n\\). We emphasise the word “the,” since extensionality tells us that there can be only one such set. Indeed, extensionality also licenses the following: \\[\\lbrace a, a, b \\rbrace = \\lbrace a, b \\rbrace = \\lbrace b,a \\rbrace. \\] This delivers on the point that, when we consider sets, we don’t care about the order of their elements, or how many times they are specified. 例 2.1 (bunch of objects) Whenever you have a bunch of objects, you can collect them together in a set. The set of Richard’s siblings, for instance, is a set that contains one person, and we could write it as \\(S =\\lbrace \\text{Ruth}\\rbrace\\). The set of positive integers less than \\(4\\) is \\(\\lbrace 1, 2, 3 \\rbrace\\), but it can also be written as \\(\\lbrace 3, 2, 1\\rbrace\\) or even as \\(\\lbrace 1, 2, 1, 2, 3\\rbrace\\). These are all the same set, by extensionality. For every element of \\(\\lbrace 1, 2, 3 \\rbrace\\) is also an element of \\(\\lbrace3, 2, 1 \\rbrace\\) (and of \\(\\lbrace 1, 2, 1, 2, 3\\rbrace\\)), and vice versa. Frequently we’ll specify a set by some property that its elements share. We’ll use the following shorthand notation for that: {\\(x: \\varphi(x)\\)}, where the \\(\\varphi(x)\\) stands for the property that \\(x\\) has to have in order to be counted among the elements of the set. 例 2.2 (property) In our example, we could have specified \\(S\\) also as \\[S = \\lbrace x: x \\text{ is a sibling of Richard}\\rbrace.\\] 例 2.3 (perfect number) A number is called perfect iff it is equal to the sum of its proper divisors (i.e., numbers that evenly divide it but aren’t identical to the number). For instance, \\(6\\) is perfect because its proper divisors are \\(1\\), \\(2\\), and \\(3\\), and \\(6 = 1 + 2 + 3\\). In fact, \\(6\\) is the only positive integer less than \\(10\\) that is perfect. So, using extensionality, we can say: \\[\\lbrace 6 \\rbrace = \\lbrace x: \\text{is perfect and } 0 \\leqslant x \\leqslant 10 \\rbrace.\\] We read the notation on the right as “the set of \\(x\\)’s such that \\(x\\) is perfect and \\(0 \\leqslant x \\leqslant 10\\).” The identity here confirms that, when we consider sets, we don’t care about how they are specified. And, more generally, extensionality guarantees that there is always only one set of \\(x\\)’s such that \\(\\varphi(x)\\). So, extensionality justifies calling \\(\\lbrace x: \\varphi(x)\\rbrace\\) the set of \\(x\\)’s such that \\(\\varphi(x)\\). Extensionality gives us a way for showing that sets are identical: to show that \\(A = B\\), show that whenever \\(x \\in A\\) then also \\(x \\in B\\), and whenever \\(y \\in B\\) then also \\(y \\in A\\). 问题 2.1 Prove that there is at most one empty set, i.e., show that if \\(A\\) and \\(B\\) are sets without elements, then \\(A = B\\). 2.1.2 Subsets and Power Sets We will often want to compare sets. And one obvious kind of comparison one might make is as follows: everything in one set is in the other too. This situation is sufficiently important for us to introduce some new notation. 定义 2.2 (Subset) If every element of a set \\(A\\) is also an element of \\(B\\), then we say that \\(A\\) is a subset of \\(B\\), and write \\(A \\subseteq B\\). If \\(A\\) is not a subset of \\(B\\) we write \\(A \\not\\subseteq B\\). If \\(A \\subseteq B\\) but \\(A \\neq B\\), we write \\(A \\subsetneq B\\) and say that \\(A\\) is a proper subset of \\(B\\). 例 2.4 Every set is a subset of itself, and \\(\\varnothing\\) is a subset of every set. The set of even numbers is a subset of the set of natural numbers. Also, \\(\\lbrace a, b \\rbrace \\subseteq \\lbrace a, b, c \\rbrace\\). But \\(\\lbrace a, b, e\\rbrace\\) is not a subset of \\(\\lbrace a, b, c \\rbrace\\). 例 2.5 The number \\(2\\) is an element of the set of integers, whereas the set of even numbers is a subset of the set of integers. However, a set may happen to both be an element and a subset of some other set, e.g., \\(\\lbrace 0\\rbrace \\in \\lbrace 0, \\lbrace 0 \\rbrace\\rbrace\\) and also \\(\\lbrace 0\\rbrace \\subseteq \\lbrace 0, \\lbrace 0\\rbrace\\rbrace\\). Extensionality gives a criterion of identity for sets: \\(A = B\\) iff every element of \\(A\\) is also an element of \\(B\\) and vice versa. The definition of “subset” defines \\(A \\subseteq B\\) precisely as the first half of this criterion: every element of \\(A\\) is also an element of \\(B\\). Of course the definition also applies if we switch \\(A\\) and \\(B\\): that is, \\(B \\subseteq A\\) iff every element of \\(B\\) is also an element of \\(A\\). And that, in turn, is exactly the “vice versa” part of extensionality. In other words, extensionality entails that sets are equal iff they are subsets of one another. 命题 2.1 \\(A = B\\) iff both \\(A \\subseteq B\\) and \\(B \\subseteq A\\). Now is also a good opportunity to introduce some further bits of helpful notation. In defining when \\(A\\) is a subset of \\(B\\) we said that “every element of \\(A\\) is \\(\\cdots\\),” and filled the “\\(\\cdots\\)” with “an element of \\(B\\).” But this is such a common shape of expression that it will be helpful to introduce some formal notation for it. 定义 2.3 \\((\\forall x \\in A) \\varphi\\) abbreviates \\(\\forall x(x \\in A \\rightarrow \\varphi)\\). Similarly, \\((\\exists x \\in A)\\varphi\\) abbreviates \\(\\exists x(x \\in A \\land \\varphi)\\). Using this notation, we can say that \\(A \\subseteq B\\) iff \\((\\forall x \\in A)x \\in B\\). Now we move on to considering a certain kind of set: the set of all subsets of a given set. 定义 2.4 (power set) The set consisting of all subsets of a set \\(A\\) is called the power set of \\(A,\\) written \\(\\mathscr{P}(A)\\). \\[\\mathscr{P}(A) =\\lbrace B: B \\subseteq A \\rbrace\\] 例 2.6 What are all the possible subsets of \\(\\lbrace a, b, c \\rbrace\\)? They are: \\(\\varnothing\\), \\(\\lbrace a\\rbrace\\), \\(\\lbrace b\\rbrace\\), \\(\\lbrace c\\rbrace\\), \\(\\lbrace a, b\\rbrace\\), \\(\\lbrace a, c\\rbrace\\), \\(\\lbrace b, c\\rbrace\\), \\(\\lbrace a, b, c\\rbrace\\). The set of all these subsets is \\(\\mathscr{P}(\\lbrace a,b,c)\\rbrace\\): \\[\\mathscr{P}(\\lbrace a, b, c \\rbrace) = \\lbrace\\varnothing, \\lbrace a \\rbrace, \\lbrace b\\rbrace, \\lbrace c\\rbrace, \\lbrace a, b\\rbrace, \\lbrace b, c\\rbrace, \\lbrace a, c\\rbrace, \\lbrace a, b, c\\rbrace\\rbrace\\] 问题 2.2 List all subsets of \\(\\lbrace a, b, c, d\\rbrace\\). 问题 2.3 Show that if \\(A\\) has \\(n\\) elements, then \\(\\mathscr{P}(A)\\) has \\(2^n\\) elements. 2.1.3 Some Important Sets 例 2.7 (Some Important Sets) We will mostly be dealing with sets whose elements are mathematical objects. Four such sets are important enough to have specific names: \\(\\mathbb{N} = \\lbrace 0, 1, 2, 3, \\cdots\\rbrace\\) ➠ the set of natural numbers \\(\\mathbb{Z} = \\lbrace \\cdots, -2, -1, 0, 1, 2, \\cdots\\rbrace\\) ➠ the set of integers \\(\\mathbb{Q} = \\lbrace \\frac{m}{n}: m, n \\in \\mathbb{Z} \\text{ and }n \\neq 0\\rbrace\\) ➠ the set of rationals \\(\\mathbb{R} = \\lbrace (-\\infty, \\infty)\\rbrace\\) ➠ the set of real numbers (the continuum) These are all infinite sets, that is, they each have infinitely many elements. As we move through these sets, we are adding more numbers to our stock. Indeed, it should be clear that \\(\\mathbb{N} \\subseteq \\mathbb{Z} \\subseteq \\mathbb{Q} \\subseteq \\mathbb{R}\\): after all, every natural number is an integer; every integer is a rational; and every rational is a real. Equally, it should be clear that \\(\\mathbb{N} \\subsetneq \\mathbb{Z} \\subsetneq \\mathbb{Q}\\), since \\(-1\\) is an integer but not a natural number, and \\(\\frac{1}{2}\\) is rational but not integer. It is less obvious that \\(\\mathbb{Q} \\subsetneq \\mathbb{R}\\), i.e., that there are some real numbers which are not rational. We’ll sometimes also use the set of positive integers \\(\\mathbb{Z}^{+} = \\lbrace 1, 2, 3, \\cdots\\rbrace\\) and the set containing just the first two natural numbers \\(\\mathbb{B} = \\lbrace 0, 1\\rbrace\\). 例 2.8 (Strings) Another interesting example is the set \\({A}^{*}\\) of finite strings over an alphabet \\(A\\): any finite sequence of elements of \\(A\\) is a string over \\(A\\). We include the empty string \\(\\Lambda\\) among the strings over \\(A\\), for every alphabet \\(A\\). For instance, \\[\\mathbb{B}^*=\\lbrace \\Lambda,0,1,00,01,10,11,000,001,010,011,100,101,110,111,0000,\\cdots\\rbrace .\\] If \\(x=x_{1}\\ldots x_{n}\\in A^{*}\\) is a string consisting of \\(n\\) “letters” from \\(A\\), then we say length of the string is \\(n\\) and write \\(\\text{len } {x}=n\\). 例 2.9 (Infinite sequences) For any set \\(A\\) we may also consider the set \\(A^\\omega\\) of infinite sequences of elements of \\(A\\). An infinite sequence \\(a_1a_2a_3a_4\\cdots\\) consists of a one-way infinite list of objects, each one of which is an element of \\(A\\). 2.1.4 Unions and Intersections We introduced definitions of sets by abstraction, i.e., definitions of the form \\(\\lbrace x: \\varphi(x)\\rbrace\\). Here, we invoke some property \\(\\varphi\\), and this property can mention sets we’ve already defined. So for instance, if \\(A\\) and \\(B\\) are sets, the set \\(\\lbrace x: x \\in A \\lor x \\in B\\rbrace\\) consists of all those objects which are elements of either \\(A\\) or \\(B\\), i.e., it’s the set that combines the elements of \\(A\\) and \\(B\\). We can visualize this as in Figure 2.1, where the highlighted area indicates the bb&gt;elements of the two sets \\(A\\) and \\(B\\) together. 图 2.1: Sets Union This operation on sets—combining them—is very useful and common, and so we give it a formal name and a symbol. 定义 2.5 (Union) The union of two sets \\(A\\) and \\(B\\), written \\(A \\cup B\\), is the set of all things which are elements of \\(A\\), \\(B\\), or both. \\[A \\cup B = \\lbrace x: x \\in A \\lor x \\in B\\rbrace\\] 例 2.10 Since the multiplicity of elements doesn’t matter, the union of two sets which have an element in common contains that element only once, e.g., \\(\\lbrace a, b, c\\rbrace \\cup \\lbrace a, 0, 1\\rbrace = \\lbrace a, b, c, 0, 1\\rbrace\\). The union of a set and one of its subsets is just the bigger set: \\(\\lbrace a, b, c \\rbrace \\cup \\lbrace a \\rbrace = \\lbrace a, b, c\\rbrace\\). The union of a set with the empty set is identical to the set: \\(\\lbrace a, b, c \\rbrace \\cup \\varnothing = \\lbrace a, b, c \\rbrace\\). 问题 2.4 Prove that if \\(A \\subseteq B\\), then \\(A \\cup B = B\\). We can also consider a “dual” operation to union. This is the operation that forms the set of all elements that are elements of \\(A\\) and are also elements of \\(B\\). This operation is called intersection, and can be depicted as in Figure 2.2. 图 2.2: Sets Intersection 定义 2.6 (Intersection) The intersection of two sets \\(A\\) and \\(B\\), written \\(A \\cap B\\), is the set of all things which are elements of both \\(A\\) and \\(B\\). \\[A \\cap B = \\lbrace x: x \\in A \\land x \\in B\\rbrace\\] Two sets are called disjoint if their intersection is empty. This means they have no elements in common. 例 2.11 If two sets have no elements in common, their intersection is empty: \\(\\lbrace a, b, c\\rbrace \\cap \\lbrace 0, 1\\rbrace = \\varnothing\\). If two sets do have elements in common, their intersection is the set of all those: \\(\\lbrace a, b, c \\rbrace \\cap \\lbrace a, b, d \\rbrace = \\lbrace a, b\\rbrace\\). The intersection of a set with one of its subsets is just the smaller set: \\(\\lbrace a, b, c\\rbrace \\cap \\lbrace a, b\\rbrace = \\lbrace a, b\\rbrace\\). The intersection of any set with the empty set is empty: \\(\\lbrace a, b, c \\rbrace \\cap \\varnothing = \\varnothing\\). 问题 2.5 Prove rigorously that if \\(A \\subseteq B\\), then \\(A \\cap B = A\\). We can also form the union or intersection of more than two sets. An elegant way of dealing with this in general is the following: suppose you collect all the sets you want to form the union (or intersection) of into a single set. Then we can define the union of all our original sets as the set of all objects which belong to at least one element of the set, and the intersection as the set of all objects which belong to every element of the set. 定义 2.7 (Union Operation) If \\(A\\) is a set of sets, then \\(\\bigcup A\\) is the set of elements of elements of \\(A\\): \\[ \\begin{aligned} \\bigcup A &amp; = \\{x: x \\text{ belongs to an element of } A\\}, \\text{ i.e.,}\\\\ &amp; = \\{x: \\text{there is a } B \\in A \\text{ so that } x \\in B\\} \\end{aligned} \\] 定义 2.8 (Intersection Operation) If \\(A\\) is a set of sets, then \\(\\bigcap A\\) is the set of objects which all elements of \\(A\\) have in common: \\[ \\begin{aligned} \\bigcap A &amp; = \\{x: x \\text{ belongs to every element of } A\\}, \\text{ i.e.,}\\\\ &amp; = \\{x: \\text{for all } B \\in A, x \\in B\\} \\end{aligned} \\] 例 2.12 Suppose \\(A = \\lbrace \\lbrace a, b \\rbrace , \\lbrace a, d, e \\rbrace , \\lbrace a, d \\rbrace \\rbrace\\). Then \\(\\bigcup A = \\lbrace a, b, d, e \\rbrace\\) and \\(\\bigcap A = \\lbrace a \\rbrace.\\) 问题 2.6 Show that if \\(A\\) is a set and \\(A \\in B\\), then \\(A \\subseteq \\bigcup B\\). We could also do the same for a sequence of sets \\(A_1\\), \\(A_2, \\cdots\\), \\[ \\begin{aligned} \\bigcup_i A_i &amp; = \\{x: x \\text{ belongs to one of the } A_i\\}\\\\ \\bigcap_i A_i &amp; = \\{x: x \\text{ belongs to every } A_i\\}. \\end{aligned} \\] When we have an index of sets, i.e., some set \\(I\\) such that we are considering \\(A_i\\) for each \\(i \\in I\\), we may also use these abbreviations: \\[ \\begin{aligned} \\bigcup_{i \\in I} A_i &amp; = \\bigcup \\{A_i: i \\in I\\}\\\\ \\bigcap_{i \\in I} A_i &amp; = \\bigcap\\{A_i: i \\in I\\} \\end{aligned} \\] Finally, we may want to think about the set of all elements in \\(A\\) which are not in \\(B\\). We can depict this as in Figure 2.3. 图 2.3: Sets Difference 定义 2.9 (Difference) The set difference \\(A \\setminus B\\) is the set of all elements of \\(A\\) which are not also elements of \\(B\\), i.e., \\[A\\setminus B = \\lbrace x: x\\in A \\text{ and } x \\notin B\\rbrace .\\] 问题 2.7 Prove that if \\(A \\subsetneq B\\), then \\(B \\setminus A \\neq \\varnothing\\). 2.1.5 Pairs, Tuples, Cartesian Products It follows from extensionality that sets have no order to their elements. So if we want to represent order, we use ordered pairs \\(⟨x, y⟩\\). In an unordered pair \\(\\lbrace x, y\\rbrace\\), the order does not matter: \\(\\lbrace x, y\\rbrace = \\lbrace y, x\\rbrace\\). In an ordered pair, it does: if \\(x \\neq y\\), then \\(⟨x, y⟩ \\neq ⟨y, x⟩\\). How should we think about ordered pairs in set theory? Crucially, we want to preserve the idea that ordered pairs are identical iff they share the same first element and share the same second element, i.e.: \\[⟨a, b⟩= ⟨c, d⟩\\text{ iff both }a = c \\text{ and }b=d.\\] We can define ordered pairs in set theory using the Wiener-Kuratowski definition. 定义 2.10 (Ordered pair) \\(⟨a, b⟩ = \\lbrace \\lbrace a\\rbrace , \\lbrace a, b\\rbrace \\rbrace\\). 问题 2.8 Using Definition 2.10, prove that \\(⟨a, b⟩= ⟨c, d⟩\\) iff both \\(a = c\\) and \\(b=d\\). Having fixed a definition of an ordered pair, we can use it to define further sets. For example, sometimes we also want ordered sequences of more than two objects, e.g., triples \\(⟨x, y, z⟩\\), quadruples \\(⟨x, y, z, u⟩\\), and so on. We can think of triples as special ordered pairs, where the first element is itself an ordered pair: \\(⟨x, y, z⟩\\) is \\(⟨⟨x, y⟩,z⟩\\). The same is true for quadruples: \\(⟨x,y,z,u⟩\\) is \\(⟨⟨⟨x,y⟩,z⟩,u⟩\\), and so on. In general, we talk of ordered \\(n\\)-tuples \\(⟨x_1, \\cdots, x_n⟩\\). Certain sets of ordered pairs, or other ordered \\(n\\)-tuples, will be useful. 定义 2.11 (Cartesian product) Given sets \\(A\\) and \\(B\\), their Cartesian product \\(A \\times B\\) is defined by \\[A \\times B = \\lbrace ⟨x, y⟩: x \\in A \\text{ and } y \\in B\\rbrace.\\] 例 2.13 If \\(A = \\lbrace 0, 1\\rbrace\\), and \\(B = \\lbrace 1, a, b\\rbrace\\), then their product is \\[A \\times B = \\lbrace ⟨0, 1⟩, ⟨0, a⟩, ⟨0, b⟩, ⟨1, 1⟩, ⟨1, a⟩, ⟨1, b⟩ \\rbrace.\\] 例 2.14 If \\(A\\) is a set, the product of \\(A\\) with itself, \\(A \\times A\\), is also written \\(A^2\\). It is the set of all pairs \\(⟨x, y⟩\\) with \\(x, y \\in A\\). The set of all triples \\(⟨x, y, z⟩\\) is \\(A^3\\), and so on. We can give a recursive definition: \\[\\begin{align*} A^1 &amp; = A\\\\ A^{k+1} &amp; = A^k \\times A \\end{align*}\\] 问题 2.9 List all elements of \\(\\lbrace 1, 2, 3\\rbrace ^3\\). 命题 2.2 If \\(A\\) has \\(n\\) elements and \\(B\\) has \\(m\\) elements, then \\(A \\times B\\) has \\(n\\cdot m\\) elements. Proof: For every element \\(x\\) in \\(A\\), there are \\(m\\) elements of the form \\(⟨x, y⟩ \\in A \\times B\\). Let \\(B_x = \\lbrace ⟨x, y⟩: y \\in B\\rbrace\\). Since whenever \\(x_1 \\neq x_2\\), \\(⟨x_1, y⟩ \\neq ⟨x_2, y⟩\\), \\(B_{x_1} \\cap B_{x_2} = \\varnothing\\). But if \\(A = \\lbrace x_1, \\cdots, x_n\\rbrace\\), then \\(A \\times B = B_{x_1} \\cup \\cdots \\cup B_{x_n}\\), and so has \\(n\\cdot m\\) elements. To visualize this, arrange the elements of \\(A \\times B\\) in a grid: \\[ \\begin{array}{rcccc} B_{x_1} = &amp; \\{⟨x_1, y_1⟩ &amp; ⟨x_1, y_2⟩ &amp; \\cdots &amp; ⟨x_1, y_m⟩\\}\\\\ B_{x_2} = &amp; \\{⟨x_2, y_1⟩ &amp; ⟨x_2, y_2⟩ &amp; \\cdots &amp; ⟨x_2, y_m⟩\\}\\\\ \\vdots &amp; &amp; \\vdots\\\\ B_{x_n} = &amp; \\{⟨x_n, y_1⟩ &amp; ⟨x_n, y_2⟩ &amp; \\cdots &amp; ⟨x_n, y_m⟩\\} \\end{array} \\] Since the \\(x_i\\) are all different, and the \\(y_j\\) are all different, no two of the pairs in this grid are the same, and there are \\(n\\cdot m\\) of them. 问题 2.10 Show, by induction on \\(k\\), that for all \\(k \\ge 1\\), if \\(A\\) has \\(n\\) elements, then \\(A^k\\) has \\(n^k\\) elements. 例 2.15 If \\(A\\) is a set, a word over \\(A\\) is any sequence of elements of \\(A\\). A sequence can be thought of as an \\(n\\)-tuple of elements of \\(A\\). For instance, if \\(A = \\lbrace a, b, c\\rbrace\\), then the sequence “\\(bac\\)” can be thought of as the triple \\(⟨b, a, c⟩\\). Words, i.e., sequences of symbols, are of crucial importance in computer science. By convention, we count elements of \\(A\\) as sequences of length \\(1\\), and \\(\\varnothing\\) as the sequence of length \\(0\\). The set of all words over \\(A\\) then is \\[A^* = \\lbrace \\varnothing\\rbrace \\cup A \\cup A^2 \\cup A^3 \\cup \\cdots\\] 2.1.6 Russell’s Paradox Extensionality licenses the notation \\(\\lbrace x: \\varphi(x)\\rbrace\\), for the set of \\(x\\)’s such that \\(\\varphi(x)\\). However, all that extensionality really licenses is the following thought. If there is a set whose members are all and only the \\(\\varphi\\)’s, then there is only one such set. Otherwise put: having fixed some \\(\\varphi\\), the set \\(\\lbrace x: \\varphi(x)\\rbrace\\) is unique, if it exists. But this conditional is important! Crucially, not every property lends itself to comprehension. That is, some properties do not define sets. If they all did, then we would run into outright contradictions. The most famous example of this is Russell’s Paradox. Sets may be elements of other sets—for instance, the power set of a set \\(A\\) is made up of sets. And so it makes sense to ask or investigate whether a set is an element of another set. Can a set be a member of itself? Nothing about the idea of a set seems to rule this out. For instance, if all sets form a collection of objects, one might think that they can be collected into a single set—the set of all sets. And it, being a set, would be an element of the set of all sets. Russell’s Paradox arises when we consider the property of not having itself as an element, of being non-self-membered. What if we suppose that there is a set of all sets that do not have themselves as an element? Does \\(R = \\lbrace x: x \\notin x\\rbrace\\) exist? It turns out that we can prove that it does not. 定理 2.1 (Russell’s Paradox) There is no set \\(R = \\lbrace x: x \\notin x\\rbrace\\). Proof: For reductio, suppose that \\[R = \\lbrace x: x \\notin x\\rbrace\\] exists. Then \\(R \\in R\\) iff \\(R \\notin R\\), since sets are extensional. But this is a contradicion. Let’s run through the proof that no set \\(R\\) of non-self-membered sets can exist more slowly. If \\(R\\) exists, it makes sense to ask if \\(R \\in R\\) or not—it must be either \\(\\in R\\) or \\(\\notin R\\). Suppose the former is true, i.e., \\(R \\in R\\). \\(R\\) was defined as the set of all sets that are not elements of themselves, and so if \\(R \\in R\\), then \\(R\\) does not have this defining property of \\(R\\). But only sets that have this property are in \\(R\\), hence, \\(R\\) cannot be an element of \\(R\\), i.e., \\(R \\notin R\\). But \\(R\\) can’t both be and not be an element of \\(R\\), so we have a contradiction. Since the assumption that \\(R \\in R\\) leads to a contradiction, we have \\(R \\notin R\\). But this also leads to a contradiction! For if \\(R \\notin R\\), it does have the defining property of \\(R\\), and so would be an element of \\(R\\) just like all the other non-self-membered sets. And again, it can’t both not be and be an element of \\(R\\). How do we set up a set theory which avoids falling into Russell’s Paradox, i.e., which avoids making the inconsistent claim that \\(R = \\lbrace x: x \\notin x\\rbrace\\) exists? Well, we would need to lay down axioms which give us very precise conditions for stating when sets exist (and when they don’t). The set theory sketched in this chapter doesn’t do this. It’s genuinely naïve. It tells you only that sets obey extensionality and that, if you have some sets, you can form their union, intersection, etc. It is possible to develop set theory more rigorously than this. 2.2 关系：集合上的结构 2.2.1 Relations as Sets In 2.1.3, we mentioned some important sets: \\(\\mathbb{N}\\), \\(\\mathbb{Z}\\), \\(\\mathbb{Q}\\), \\(\\mathbb{R}\\). You will no doubt remember some interesting relations between the elements of some of these sets. For instance, each of these sets has a completely standard order relation on it. There is also the relation is identical with that every object bears to itself and to no other thing. There are many more interesting relations that we’ll encounter, and even more possible relations. Before we review them, though, we will start by pointing out that we can look at relations as a special sort of set. For this, recall two things from 2.1.5. First, recall the notion of a ordered pair: given \\(a\\) and \\(b\\), we can form \\(⟨a, b⟩\\). Importantly, the order of elements does matter here. So if \\(a \\neq b\\) then \\(⟨a, b⟩ \\neq ⟨b, a⟩\\). (Contrast this with unordered pairs, i.e., \\(2\\)-element sets, where \\(\\lbrace a, b\\rbrace =\\lbrace b, a\\rbrace\\).) Second, recall the notion of a Cartesian product: if \\(A\\) and \\(B\\) are sets, then we can form \\(A \\times B\\), the set of all pairs \\(⟨x, y⟩\\) with \\(x \\in A\\) and \\(y \\in B\\). In particular, \\(A^{2}= A \\times A\\) is the set of all ordered pairs from \\(A\\). Now we will consider a particular relation on a set: the \\(&lt;\\)-relation on the set \\(\\mathbb{N}\\) of natural numbers. Consider the set of all pairs of numbers \\(⟨n, m⟩\\) where \\(n &lt; m\\), i.e., \\[R= \\lbrace ⟨n, m⟩: n, m \\in \\mathbb{N} \\text{ and } n &lt; m \\rbrace.\\] There is a close connection between \\(n\\) being less than \\(m\\), and the pair \\(⟨n, m⟩\\) being a member of \\(R\\), namely: \\[n &lt; m \\text{ iff }⟨n, m⟩ \\in R.\\] Indeed, without any loss of information, we can consider the set \\(R\\) to be the \\(&lt;\\)-relation on \\(\\mathbb{N}\\). In the same way we can construct a subset of \\(\\mathbb{N}^{2}\\) for any relation between numbers. Conversely, given any set of pairs of numbers \\(S \\subseteq \\mathbb{N}^{2}\\), there is a corresponding relation between numbers, namely, the relationship \\(n\\) bears to \\(m\\) if and only if \\(⟨n, m⟩ \\in S\\). This justifies the following definition: 定义 2.12 (Binary relation) A binary relation on a set \\(A\\) is a subset of \\(A^{2}\\). If \\(R \\subseteq A^{2}\\) is a binary relation on \\(A\\) and \\(x, y \\in A\\), we sometimes write \\(Rxy\\) (or \\(xRy\\)) for \\(⟨x, y⟩ \\in R\\). 例 2.16 The set \\(\\mathbb{N}^{2}\\) of pairs of natural numbers can be listed in a 2-dimensional matrix like this: \\[ \\begin{array}{ccccc} \\mathbf{⟨0,0⟩} &amp; ⟨0,1⟩ &amp; ⟨0,2⟩ &amp; ⟨0,3⟩ &amp; \\cdots\\\\ ⟨1,0⟩ &amp; \\mathbf{⟨1,1⟩} &amp; ⟨1,2⟩ &amp; ⟨1,3⟩ &amp; \\cdots\\\\ ⟨2,0⟩ &amp; ⟨2,1⟩ &amp; \\mathbf{⟨2,2⟩} &amp; ⟨2,3⟩ &amp; \\cdots\\\\ ⟨3,0⟩ &amp; ⟨3,1⟩ &amp; ⟨3,2⟩ &amp; \\mathbf{⟨3,3⟩} &amp; \\cdots\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\mathbf{\\ddots} \\end{array} \\] We have put the diagonal, here, in bold, since the subset of \\(\\mathbb{N}^2\\) consisting of the pairs lying on the diagonal, i.e., \\[\\lbrace ⟨0,0 ⟩, ⟨ 1,1 ⟩, ⟨ 2,2 ⟩, \\cdots\\rbrace ,\\] is the identity relation on \\(\\mathbb{N}\\). (Since the identity relation is popular, let’s define \\(Id_A=\\lbrace ⟨ x,x ⟩: x \\in X\\rbrace\\) for any set \\(A\\).) The subset of all pairs lying above the diagonal, i.e., \\[L = \\lbrace ⟨0,1⟩,⟨0,2⟩,\\cdots,⟨1,2⟩,⟨1,3⟩, \\cdots, ⟨2,3 ⟩, ⟨2,4⟩,\\cdots\\rbrace ,\\] is the less than relation, i.e., \\(Lnm\\) iff \\(n &lt; m\\). The subset of pairs below the diagonal, i.e., \\[G=\\lbrace ⟨1,0⟩,⟨2,0⟩, ⟨2,1⟩, ⟨3,0⟩,⟨3,1 ⟩,⟨3,2 ⟩, \\cdots\\rbrace ,\\] is the greater than relation, i.e., \\(Gnm\\) iff \\(n&gt;m\\). The union of \\(L\\) with \\(I\\), which we might call \\(K=L\\cup I\\), is the less than or equal to relation: \\(Knm\\) iff \\(n \\le m\\). Similarly, \\(H=G \\cup I\\) is the greater than or equal to relation. These relations \\(L\\), \\(G\\), \\(K\\), and \\(H\\) are special kinds of relations called orders. \\(L\\) and \\(G\\) have the property that no number bears \\(L\\) or \\(G\\) to itself (i.e., for all \\(n\\), neither \\(Lnn\\) nor \\(Gnn\\)). Relations with this property are called irreflexive, and, if they also happen to be orders, they are called strict orders. Although orders and identity are important and natural relations, it should be emphasized that according to our definition any subset of \\(A^{2}\\) is a relation on \\(A\\), regardless of how unnatural or contrived it seems. In particular, \\(\\varnothing\\) is a relation on any set (the empty relation, which no pair of elements bears), and \\(A^{2}\\) itself is a relation on \\(A\\) as well (one which every pair bears), called the universal relation. But also something like \\(E=\\lbrace ⟨n, m⟩: n&gt;5 \\text{ or } m \\times n \\ge 34\\rbrace\\) counts as a relation. 问题 2.11 List the elements of the relation \\(\\subseteq\\) on the set \\(\\mathscr{P}({\\lbrace a, b, c\\rbrace })\\). 2.2.2 Philosophical Reflections In 2.2.1, we defined relations as certain sets. We should pause and ask a quick philosophical question: what is such a definition doing? It is extremely doubtful that we should want to say that we have discovered some metaphysical identity facts; that, for example, the order relation on \\(\\mathbb{N}\\) turned out to be the set \\(R= \\lbrace ⟨n,m⟩: n, m \\in \\mathbb{N}\\text{ and } n &lt; m\\rbrace\\) we defined in 2.2.1. Here are three reasons why. First: in Definition 2.10, we defined \\(⟨a, b⟩ = \\lbrace \\lbrace a\\rbrace , \\lbrace a, b\\rbrace \\rbrace\\). Consider instead the definition \\(\\lVert a, b\\rVert = \\lbrace \\lbrace b\\rbrace , \\lbrace a, b\\rbrace \\rbrace = ⟨b,a⟩\\). When \\(a \\neq b\\), we have that \\(⟨a, b⟩ \\neq \\lVert a,b\\rVert\\). But we could equally have regarded \\(\\lVert a,b\\rVert\\) as our definition of an ordered pair, rather than \\(⟨a,b⟩\\). Both definitions would have worked equally well. So now we have two equally good candidates to “be” the order relation on the natural numbers, namely: \\[ \\begin{aligned} R &amp;= \\{⟨n,m⟩: n, m \\in \\mathbb{N} \\text{ and }n &lt; m\\}\\\\ S &amp;= \\{\\lVert n,m\\rVert: n, m \\in \\mathbb{N} \\text{ and }n &lt; m\\}. \\end{aligned} \\] Since \\(R \\neq S\\), by extensionality, it is clear that they cannot both be identical to the order relation on \\(\\mathbb{N}\\). But it would just be arbitrary, and hence a bit embarrassing, to claim that \\(R\\) rather than \\(S\\) (or vice versa) is the ordering relation, as a matter of fact. (This is a very simple instance of an argument against set-theoretic reductionism which Benacerraf made famous in 1965. We will revisit it several times.) Second: if we think that every relation should be identified with a set, then the relation of set-membership itself, \\(\\in\\), should be a particular set. Indeed, it would have to be the set \\(\\lbrace ⟨x,y⟩: x \\in y\\rbrace\\). But does this set exist? Given Russell’s Paradox, it is a non-trivial claim that such a set exists. In fact, it is possible to develop set theory in a rigorous way as an axiomatic theory. In this theory, it will be provable that there is no set of all sets. So, even if some relations can be treated as sets, the relation of set-membership will have to be a special case. Third: when we “identify” relations with sets, we said that we would allow ourselves to write \\(Rxy\\) for \\(⟨x,y⟩ \\in R\\). This is fine, provided that the membership relation, “\\(\\in\\),” is treated as a predicate. But if we think that “\\(\\in\\)” stands for a certain kind of set, then the expression “\\(⟨x,y⟩ \\in R\\)” just consists of three singular terms which stand for sets: “\\(⟨x,y⟩\\),” “\\(\\in\\),” and “\\(R\\).” And such a list of names is no more capable of expressing a proposition than the nonsense string: “the cup penholder the table.” Again, even if some relations can be treated as sets, the relation of set-membership must be a special case. (This rolls together a simple version of Frege’s concept horse paradox, and a famous objection that Wittgenstein once raised against Russell.) So where does this leave us? Well, there is nothing wrong with our saying that the relations on the numbers are sets. We just have to understand the spirit in which that remark is made. We are not stating a metaphysical identity fact. We are simply noting that, in certain contexts, we can (and will) treat (certain) relations as certain sets. 2.2.3 Special Properties of Relations Some kinds of relations turn out to be so common that they have been given special names. For instance, \\(\\leqslant\\) and \\(\\subseteq\\) both relate their respective domains (say, \\(\\mathbb{N}\\) in the case of \\(\\leqslant\\) and \\(\\mathscr{P}({A})\\) in the case of \\(\\subseteq\\)) in similar ways. To get at exactly how these relations are similar, and how they differ, we categorize them according to some special properties that relations can have. It turns out that (combinations of) some of these special properties are especially important: orders and equivalence relations. 定义 2.13 (Reflexivity) A relation \\(R \\subseteq A^2\\) is reflexive iff, for every \\(x \\in A\\), \\(Rxx\\). 定义 2.14 (Transitivity) A relation \\(R \\subseteq A^2\\) is transitive iff, whenever \\(Rxy\\) and \\(Ryz\\), then also \\(Rxz\\). 定义 2.15 (Symmetry) A relation \\(R \\subseteq A^2\\) is symmetric iff, whenever \\(Rxy\\), then also \\(Ryx\\). 定义 2.16 (Anti-symmetry) A relation \\(R \\subseteq A^2\\) is anti-symmetric iff, whenever both \\(Rxy\\) and \\(Ryx\\), then \\(x=y\\) (or, in other words: if \\(x\\neq y\\) then either \\(\\lnot Rxy\\) or \\(\\lnot Ryx\\)). In a symmetric relation, \\(Rxy\\) and \\(Ryx\\) always hold together, or neither holds. In an anti-symmetric relation, the only way for \\(Rxy\\) and \\(Ryx\\) to hold together is if \\(x = y\\). Note that this does not require that \\(Rxy\\) and \\(Ryx\\) holds when \\(x = y\\), only that it isn’t ruled out. So an anti-symmetric relation can be reflexive, but it is not the case that every anti-symmetric relation is reflexive. Also note that being anti-symmetric and merely not being symmetric are different conditions. In fact, a relation can be both symmetric and anti-symmetric at the same time (e.g., the identity relation is). 定义 2.17 (Connectivity) A relation \\(R \\subseteq A^2\\) is connected if for all \\(x,y\\in X\\), if \\(x \\neq y\\), then either \\(Rxy\\) or \\(Ryx\\). 问题 2.12 Give examples of relations that are (a) reflexive and symmetric but not transitive, (b) reflexive and anti-symmetric, (c) anti-symmetric, transitive, but not reflexive, and (d) reflexive, symmetric, and transitive. Do not use relations on numbers or sets. 定义 2.18 (Irreflexivity) A relation \\(R \\subseteq A^2\\) is called irreflexive if, for all \\(x \\in A\\), not \\(Rxx\\). 定义 2.19 (Asymmetry) A relation \\(R \\subseteq A^2\\) is called asymmetric if for no pair \\(x,y\\in A\\) we have both \\(Rxy\\) and \\(Ryx\\). Note that if \\(A \\neq \\varnothing\\), then no irreflexive relation on \\(A\\) is reflexive and every asymmetric relation on \\(A\\) is also anti-symmetric. However, there are \\(R \\subseteq A^2\\) that are not reflexive and also not irreflexive, and there are anti-symmetric relations that are not asymmetric. 2.2.4 Equivalence Relations The identity relation on a set is reflexive, symmetric, and transitive. Relations \\(R\\) that have all three of these properties are very common. 定义 2.20 (Equivalence relation) A relation \\(R \\subseteq A^2\\) that is reflexive, symmetric, and transitive is called an equivalence relation. elements \\(x\\) and \\(y\\) of \\(A\\) are said to be \\(R\\)-equivalent if \\(Rxy\\). Equivalence relations give rise to the notion of an equivalence class. An equivalence relation “chunks up” the domain into different partitions. Within each partition, all the objects are related to one another; and no objects from different partitions relate to one another. Sometimes, it’s helpful just to talk about these partitions directly. To that end, we introduce a definition: 定义 2.21 (Equivalence class) Let \\(R \\subseteq A^2\\) be an equivalence relation. For each \\(x \\in A\\), the equivalence class of \\(x\\) in \\(A\\) is the set \\([x]_R = \\lbrace y \\in A: Rxy\\rbrace\\). The quotient of \\(A\\) under \\(R\\) is \\(A/_R = \\lbrace [x]_R: x \\in A\\rbrace\\), i.e., the set of these equivalence classes. The next result vindicates the definition of an equivalence class, in proving that the equivalence classes are indeed the partitions of \\(A\\): 命题 2.3 If \\(R \\subseteq A^2\\) is an equivalence relation, then \\(Rxy\\) iff \\([x]_R = [y]_R\\). Proof: For the left-to-right direction, suppose \\(Rxy\\), and let \\(z \\in [x]_R\\). By definition, then, \\(Rxz\\). Since \\(R\\) is an equivalence relation, \\(Ryz\\). (Spelling this out: as \\(Rxy\\) and \\(R\\) is symmetric we have \\(Ryx\\), and as \\(Rxz\\) and \\(R\\) is transitive we have \\(Ryz\\).) So \\(z \\in [y]_R\\). Generalising, \\([x]_R \\subseteq [y]_R\\). But exactly similarly, \\([y]_R \\subseteq [x]_R\\). So \\([x]_R = [y]_R\\), by extensionality. &gt; For the right-to-left direction, suppose \\([x]_R = [y]_R\\). Since \\(R\\) is reflexive, \\(Ryy\\), so \\(y \\in [y]_R\\). Thus also \\(y \\in [x]_R\\) by the assumption that \\([x]_R = [y]_R\\). So \\(Rxy\\). 例 2.17 A nice example of equivalence relations comes from modular arithmetic. For any \\(a\\), \\(b\\), and \\(n \\in \\mathbb{N}\\), say that \\(a \\equiv_{n} b\\) iff dividing \\(a\\) by \\(n\\) gives remainder \\(b\\). (Somewhat more symbolically: \\(a \\equiv_{n} b\\) iff \\((\\exists k \\in \\mathbb{N})a - b = kn\\).) Now, \\(\\equiv_{n}\\) is an equivalence relation, for any \\(n\\). And there are exactly \\(n\\) distinct equivalence classes generated by \\(\\equiv_{n}\\); that is, \\({\\mathbb{N}/}_{\\equiv_{n}}\\) has \\(n\\) elements. These are: the set of numbers divisible by \\(n\\) without remainder, i.e., \\([0]_{\\equiv_{n}}\\); the set of numbers divisible by \\(n\\) with remainder \\(1\\), i.e., \\([1]_{\\equiv_{n}}; \\cdots\\); and the set of numbers divisible by \\(n\\) with remainder \\(n-1\\), i.e., \\([n-1]_{\\equiv_{n}}\\). 问题 2.13 Show that \\(\\equiv_{n}\\) is an equivalence relation, for any \\(n \\in \\mathbb{N}\\), and that \\({\\mathbb{N}/}_{\\equiv_{n}}\\) has exactly \\(n\\) members. 2.2.5 Orders Many of our comparisons involve describing some objects as being “less than,” “equal to,” or “greater than” other objects, in a certain respect. These involve order relations. But there are different kinds of order relations. For instance, some require that any two objects be comparable, others don’t. Some include identity (like \\(\\leqslant\\)) and some exclude it (like \\(&lt;\\)). It will help us to have a taxonomy here. 定义 2.22 (Preorder) A relation which is both reflexive and transitive is called a preorder. 定义 2.23 (Partial order) A preorder which is also anti-symmetric is called a partial order. 定义 2.24 (Linear order) A partial order which is also connected is called a total order or linear order. Every linear order is also a partial order, and every partial order is also a preorder, but the converses don’t hold. 例 2.18 Every linear order is also a partial order, and every partial order is also a preorder, but the converses don’t hold. The universal relation on \\(A\\) is a preorder, since it is reflexive and transitive. But, if \\(A\\) has more than one element, the universal relation is not anti-symmetric, and so not a partial order. 例 2.19 Consider the no longer than relation \\(\\preccurlyeq\\) on \\(\\mathbb{B}^*\\): \\(x \\preccurlyeq y\\) iff \\(\\text{len } {x} \\le \\text{len } {y}\\). This is a preorder (reflexive and transitive), and even connected, but not a partial order, since it is not anti-symmetric. For instance, \\(01 \\preccurlyeq 10\\) and \\(10 \\preccurlyeq 01\\), but \\(01 \\neq 10\\). 例 2.20 An important partial order is the relation \\(\\subseteq\\) on a set of sets. This is not in general a linear order, since if \\(a \\neq b\\) and we consider \\(\\mathscr{P}(\\lbrace a, b\\rbrace ) = \\lbrace \\varnothing, \\lbrace a\\rbrace , \\lbrace b\\rbrace , \\lbrace a,b\\rbrace \\rbrace\\), we see that \\(\\lbrace a\\rbrace \\nsubseteq \\lbrace b\\rbrace\\) and \\(\\lbrace a\\rbrace \\neq \\lbrace b\\rbrace\\) and \\(\\lbrace b\\rbrace \\nsubseteq \\lbrace a\\rbrace\\). 例 2.21 The relation of divisibility without remainder gives us a partial order which isn’t a linear order. For integers \\(n\\), \\(m\\), we write \\(n\\mid m\\) to mean \\(n\\) (evenly) divides \\(m\\), i.e., iff there is some integer \\(k\\) so that \\(m=kn\\). On \\(\\mathbb{N}\\), this is a partial order, but not a linear order: for instance, \\(2\\nmid3\\) and also \\(3\\nmid2\\). Considered as a relation on \\(\\mathbb{Z}\\), divisibility is only a preorder since it is not anti-symmetric: \\(1\\mid-1\\) and \\(-1\\mid1\\) but \\(1\\neq-1\\). 定义 2.25 (Strict order) A strict order is a relation which is irreflexive, asymmetric, and transitive. 定义 2.26 (Strict linear order) A strict order which is also connected is called a strict linear order. 例 2.22 \\(\\leqslant\\) is the linear order corresponding to the strict linear order \\(&lt;\\). \\(\\subseteq\\) is the partial order corresponding to the strict order \\(\\subsetneq\\). 定义 2.27 (Total order) A strict order which is also connected is called a total order. This is also sometimes called a strict linear order. Any strict order \\(R\\) on \\(A\\) can be turned into a partial order by adding the diagonal Id\\(_{A}\\), i.e., adding all the pairs \\(⟨x, x⟩\\). (This is called the reflexive closure of \\(R\\).) Conversely, starting from a partial order, one can get a strict order by removing Id\\(_A\\). These next two results make this precise. 命题 2.4 If \\(R\\) is a strict order on \\(A\\), then \\(R^+ = R \\cup Id_A\\) is a partial order. Moreover, if \\(R\\) is total, then \\(R^+\\) is a linear order. Proof: 1. Suppose \\(R\\) is a strict order, i.e., \\(R \\subseteq A^2\\) and \\(R\\) is irreflexive, asymmetric, and transitive. Let \\(R^+ = R \\cup Id_A\\). We have to show that \\(R^+\\) is reflexive, antisymmetric, and transitive. 1. \\(R^+\\) is clearly reflexive, since \\(⟨x, x⟩ \\in Id_A \\subseteq R^+\\) for all \\(x \\in A.\\) 1. To show \\(R^+\\) is antisymmetric, suppose for reductio that \\(R^+xy\\) and \\(R^+yx\\) but \\(x \\neq y\\). Since \\(⟨x,y⟩ \\in R \\cup Id_X\\), but \\(⟨x, y⟩ \\notin Id_X\\), we must have \\(⟨x, y⟩ \\in R\\), i.e., \\(Rxy\\). Similarly, \\(Ryx\\). But this contradicts the assumption that \\(R\\) is asymmetric. 1. To establish transitivity, suppose that \\(R^+xy\\) and \\(R^+yz\\). If both \\(⟨x, y⟩ \\in R\\) and \\(⟨y,z⟩ \\in R\\), then \\(⟨x, z⟩ \\in R\\) since \\(R\\) is transitive. Otherwise, either \\(⟨x, y⟩ \\in Id_X\\), i.e., \\(x = y\\), or \\(⟨y, z⟩ \\in Id_X\\), i.e., \\(y = z\\). In the first case, we have that \\(R^+yz\\) by assumption, \\(x = y\\), hence \\(R^+xz\\). Similarly in the second case. In either case, \\(R^+xz\\), thus, \\(R^+\\) is also transitive. 1. Concerning the “moreover” clause, suppose \\(R\\) is a total order, i.e., that \\(R\\) is connected. So for all \\(x \\neq y\\), either \\(Rxy\\) or \\(Ryx\\), i.e., either \\(⟨x, y⟩ \\in R\\) or \\(⟨y, x⟩ \\in R\\). Since \\(R \\subseteq R^+\\), this remains true of \\(R^+\\), so \\(R^+\\) is connected as well. 命题 2.5 If \\(R\\) is a partial order on \\(X\\), then \\(R^- = R \\setminus \\text{Id}_X\\) is a strict order. Moreover, if \\(R\\) is linear, then \\(R^-\\) is total. Proof: This is left as an exercise. 问题 2.14 Give a proof of Proposition 2.5. 例 2.23 \\(\\leqslant\\) is the linear order corresponding to the total order \\(&lt;\\). \\(\\subseteq\\) is the partial order corresponding to the strict order \\(\\subsetneq\\). The following simple result which establishes that total orders satisfy an extensionality-like property: 命题 2.6 If \\(&lt;\\) totally orders \\(A\\), then: \\[(\\forall a, b \\in A)((\\forall x \\in A)(x &lt; a \\leftrightarrow x &lt; b) \\rightarrow a = b)\\] Proof: Suppose \\((\\forall x \\in A)(x &lt; a \\leftrightarrow x &lt; b)\\). If \\(a &lt; b\\), then \\(a &lt; a\\), contradicting the fact that \\(&lt;\\) is irreflexive; so \\(a \\nless b\\). Exactly similarly, \\(b \\nless a\\). So \\(a = b\\), as \\(&lt;\\) is connected. 2.2.6 Graphs A graph is a diagram in which points—called “nodes” or “vertices” (plural of “vertex”)—are connected by edges. Graphs are a ubiquitous tool in discrete mathematics and in computer science. They are incredibly useful for representing, and visualizing, relationships and structures, from concrete things like networks of various kinds to abstract structures such as the possible outcomes of decisions. There are many different kinds of graphs in the literature which differ, e.g., according to whether the edges are directed or not, have labels or not, whether there can be edges from a node to the same node, multiple edges between the same nodes, etc. Directed graphs have a special connection to relations. 定义 2.28 (Directed graph) A directed graph \\(G = ⟨V, E⟩\\) is a set of vertices \\(V\\) and a set of edges \\(E \\subseteq V^2\\). According to our definition, a graph just is a set together with a relation on that set. Of course, when talking about graphs, it’s only natural to expect that they are graphically represented: we can draw a graph by connecting two vertices \\(v_1\\) and \\(v_2\\) by an arrow iff \\(⟨v_1, v_2⟩ \\in E\\). The only difference between a relation by itself and a graph is that a graph specifies the set of vertices, i.e., a graph may have isolated vertices. The important point, however, is that every relation \\(R\\) on a set \\(X\\) can be seen as a directed graph \\(⟨X, R⟩\\), and conversely, a directed graph \\(⟨V, E⟩\\) can be seen as a relation \\(E \\subseteq V^2\\) with the set \\(V\\) explicitly specified. 例 2.24 The graph \\(⟨V, E⟩\\) with \\(V = \\lbrace 1, 2, 3, 4\\rbrace\\) and \\(E = \\lbrace ⟨1,1⟩, ⟨1, 2⟩, ⟨1, 3⟩, ⟨2, 3⟩\\rbrace\\) looks like this: This is a different graph than \\(⟨V&#39;, E⟩\\) with \\(V&#39; = \\lbrace 1, 2, 3\\rbrace\\), which looks like this: 问题 2.15 Consider the less-than-or-equal-to relation \\(\\leqslant\\) on the set \\(\\lbrace 1, 2, 3, 4\\rbrace\\) as a graph and draw the corresponding diagram. 2.2.7 Operations on Relations It is often useful to modify or combine relations. In Proposition 2.4, we considered the union of relations, which is just the union of two relations considered as sets of pairs. Similarly, in Proposition 2.5, we considered the relative difference of relations. Here are some other operations we can perform on relations. 定义 2.29 (Operations on Relations) Let \\(R\\), \\(S\\) be relations, and \\(A\\) be any set. The inverse of \\(R\\) is \\(R^{-1} = \\lbrace ⟨y, x⟩: ⟨x, y⟩ \\in R\\rbrace\\). The relative product of \\(R\\) and \\(S\\) is \\((R \\mid S) = \\lbrace ⟨x, z⟩ : \\exists y(Rxy \\land Syz)\\rbrace\\). The restriction of \\(R\\) to \\(A\\) is \\(R\\upharpoonright_{A}= R \\cap A^2\\). The application of \\(R\\) to \\(A\\) is \\(R[A] = \\lbrace y : (\\exists x \\in A)Rxy\\rbrace\\) 例 2.25 Let \\(S \\subseteq \\mathbb{Z}^2\\) be the successor relation on \\(\\mathbb{Z}\\), i.e., \\(S = \\lbrace⟨x, y⟩ \\in \\mathbb{Z}^2: x + 1 = y\\rbrace\\), so that \\(Sxy\\) iff \\(x + 1 = y\\). \\(S^{-1}\\) is the predecessor relation on \\(\\mathbb{Z}\\), i.e., \\(\\lbrace ⟨x,y⟩\\in\\mathbb{Z}^2: x -1 =y\\rbrace\\). \\(S\\mid S\\) is \\(\\lbrace ⟨x,y⟩\\in\\mathbb{Z}^2: x + 2 =y\\rbrace\\) \\(S\\upharpoonright_{\\mathbb{N}}\\) is the successor relation on \\(\\mathbb{N}\\). \\(S[\\lbrace 1,2,3\\rbrace ]\\) is \\(\\lbrace 2, 3, 4\\rbrace\\). 定义 2.30 (Transitive closure) Let \\(R \\subseteq A^2\\) be a binary relation. The transitive closure of \\(R\\) is \\(R^+ = \\bigcup_{0 &lt; n \\in \\mathbb{N}} R^n\\), where we recursively define \\(R^1 = R\\) and \\(R^{n+1} = R^n \\mid R\\). The reflexive transitive closure of \\(R\\) is \\(R^* = R^+ \\cup Id_X\\). 例 2.26 Take the successor relation \\(S \\subseteq \\mathbb{Z}^2\\). \\(S^2xy\\) iff \\(x + 2 = y\\), \\(S^3xy\\) iff \\(x + 3 = y\\), etc. So \\(S^+xy\\) iff \\(x + n = y\\) for some \\(n &gt; 1\\). In other words, \\(S^+xy\\) iff \\(x &lt; y\\), and \\(S^*xy\\) iff \\(x \\le y\\). 问题 2.16 Show that the transitive closure of \\(R\\) is in fact transitive. 2.3 函数：关系之特例 2.3.1 Basics A function is a map which sends each element of a given set to a specific element in some (other) given set. For instance, the operation of adding \\(1\\) defines a function: each number \\(n\\) is mapped to a unique number \\(n+1\\). More generally, functions may take pairs, triples, etc., as inputs and returns some kind of output. Many functions are familiar to us from basic arithmetic. For instance, addition and multiplication are functions. They take in two numbers and return a third. In this mathematical, abstract sense, a function is a black box: what matters is only what output is paired with what input, not the method for calculating the output. 定义 2.31 (Function) A function \\(f \\colon A \\to B\\) is a mapping of each element of \\(A\\) to an element of \\(B\\). We call \\(A\\) the domain of \\(f\\) and \\(B\\) the codomain of \\(f\\). The elements of \\(A\\) are called inputs or arguments of \\(f\\), and the element of \\(B\\) that is paired with an argument \\(x\\) by \\(f\\) is called the value of \\(f\\) for argument \\(x\\), written \\(f(x)\\). The range \\(\\text{ran}(f)\\) of \\(f\\) is the subset of the codomain consisting of the values of \\(f\\) for some argument; \\(\\text{ran}(f) = \\lbrace f(x): x \\in A\\rbrace\\). The diagram in Figure 1.3 may help to think about functions. The ellipse on the left represents the function’s domain; the ellipse on the right represents the function’s codomain; and an arrow points from an argument in the domain to the corresponding value in the codomain. 例 2.27 Multiplication takes pairs of natural numbers as inputs and maps them to natural numbers as outputs, so goes from \\(\\mathbb{N} \\times \\mathbb{N}\\) (the domain) to \\(\\mathbb{N}\\) (the codomain). As it turns out, the range is also \\(\\mathbb{N}\\), since every \\(n \\in \\mathbb{N}\\) is \\(n \\times 1\\). 例 2.28 Multiplication is a function because it pairs each input—each pair of natural numbers—with a single output: \\(\\times \\colon \\mathbb{N}^2 \\to \\mathbb{N}\\). By contrast, the square root operation applied to the domain \\(\\mathbb{N}\\) is not functional, since each positive integer \\(n\\) has two square roots: \\(\\sqrt{n}\\) and \\(-\\sqrt{n}\\). We can make it functional by only returning the positive square root: \\(\\sqrt{\\phantom{X}} \\colon \\mathbb{N} \\to \\mathbb{R}\\). 例 2.29 The relation that pairs each student in a class with their final grade is a function—no student can get two different final grades in the same class. The relation that pairs each student in a class with their parents is not a function: students can have zero, or two, or more parents. We can define functions by specifying in some precise way what the value of the function is for every possible argment. Different ways of doing this are by giving a formula, describing a method for computing the value, or listing the values for each argument. However functions are defined, we must make sure that for each argment we specify one, and only one, value. 例 2.30 Let \\(f \\colon \\mathbb{N} \\to \\mathbb{N}\\) be defined such that \\(f(x) = x+1\\). This is a definition that specifies \\(f\\) as a function which takes in natural numbers and outputs natural numbers. It tells us that, given a natural number \\(x\\), \\(f\\) will output its successor \\(x+1\\). In this case, the codomain \\(\\mathbb{N}\\) is not the range of \\(f\\), since the natural number \\(0\\) is not the successor of any natural number. The range of \\(f\\) is the set of all positive integers, \\(\\mathbb{Z}^{+}\\). 例 2.31 Let \\(g \\colon \\mathbb{N} \\to \\mathbb{N}\\) be defined such that \\(g(x) = x+2-1\\). This tells us that \\(g\\) is a function which takes in natural numbers and outputs natural numbers. Given a natural number \\(n\\), \\(g\\) will output the predecessor of the successor of the successor of \\(x\\), i.e., \\(x+1\\). We just considered two functions, \\(f\\) and \\(g\\), with different definitions. However, these are the same function. After all, for any natural number \\(n\\), we have that \\(f(n) = n+1 = n+2-1 = g(n)\\). Otherwise put: our definitions for \\(f\\) and \\(g\\) specify the same mapping by means of different equations. Implicitly, then, we are relying upon a principle of extensionality for functions, \\[\\text{if }\\forall x\\, f(x) = g(x)\\text{, then }f = g\\] provided that \\(f\\) and \\(g\\) share the same domain and codomain. 例 2.32 We can also define functions by cases. For instance, we could define \\(h \\colon \\mathbb{N} \\to \\mathbb{N}\\) by \\[h(x) = \\begin{cases} \\displaystyle\\frac{x}{2} &amp; \\text{if $x$ is even} \\\\ \\displaystyle\\frac{x+1}{2} &amp; \\text{if $x$ is odd.} \\end{cases}\\] Since every natural number is either even or odd, the output of this function will always be a natural number. Just remember that if you define a function by cases, every possible input must fall into exactly one case. In some cases, this will require a proof that the cases are exhaustive and exclusive. 2.3.2 Kinds of Functions It will be useful to introduce a kind of taxonomy for some of the kinds of functions which we encounter most frequently. To start, we might want to consider functions which have the property that every member of the codomain is a value of the function. Such functions are called surjective, and can be pictured as in Figure 1.4. 定义 2.32 (Surjective function) A function \\(f \\colon A \\rightarrow B\\) is surjective iff \\(B\\) is also the range of \\(f\\), i.e., for every \\(y \\in B\\) there is at least one \\(x \\in A\\) such that \\(f(x) = y\\), or in symbols: \\[(\\forall y \\in B)(\\exists x \\in A)f(x) = y.\\] We call such a function a surjection from \\(A\\) to \\(B\\). If you want to show that \\(f\\) is a surjection, then you need to show that every object in \\(f\\)’s codomain is the value of \\(f(x)\\) for some input \\(x\\). Note that any function induces a surjection. After all, given a function \\(f \\colon A \\to B\\), let \\(f&#39; \\colon A \\to \\text{ran}(f)\\) be defined by \\(f&#39;(x) = f(x)\\). Since \\(\\text{ran}(f)\\) is defined as \\(\\lbrace f(x) \\in B: x \\in A\\rbrace\\), this function \\(f&#39;\\) is guaranteed to be a surjection. Now, any function maps each possible input to a unique output. But there are also functions which never map different inputs to the same outputs. Such functions are called injective, and can be pictured as in Figure 1.5. 定义 2.33 (Injective function) A function \\(f \\colon A \\rightarrow B\\) is injective iff for each \\(y \\in B\\) there is at most one \\(x \\in A\\) such that \\(f(x) = y\\). We call such a function an injection from \\(A\\) to \\(B\\). If you want to show that \\(f\\) is an injection, you need to show that for any elements \\(x\\) and \\(y\\) of \\(f\\)’s domain, if \\(f(x)=f(y)\\), then \\(x=y\\). 例 2.33 The constant function \\(f\\colon \\mathbb{N} \\to \\mathbb{N}\\) given by \\(f(x) = 1\\) is neither injective, nor surjective. The identity function \\(f\\colon \\mathbb{N} \\to \\mathbb{N}\\) given by \\(f(x) = x\\) is both injective and surjective. The successor function \\(f \\colon \\mathbb{N} \\to \\mathbb{N}\\) given by \\(f(x) = x+1\\) is injective but not surjective. The function \\(f \\colon \\mathbb{N} \\to \\mathbb{N}\\) defined by: \\[f(x) =\\begin{cases} \\displaystyle\\frac{x}{2} &amp; \\text{if $x$ is even} \\\\ \\displaystyle\\frac{x+1}{2} &amp; \\text{if $x$ is odd.} \\end{cases}\\] is surjective, but not injective. Often enough, we want to consider functions which are both injective and surjective. We call such functions bijective. They look like the function pictured in Figure 1.6. bijections are also sometimes called one-to-one correspondences, since they uniquely pair elements of the codomain with elements of the domain. 定义 2.34 (bijection) A function \\(f \\colon A \\to B\\) is bijective iff it is both surjective and injective. We call such a function a bijection from \\(A\\) to \\(B\\) (or between \\(A\\) and \\(B\\)). 2.3.3 Functions as Relations A function which maps elements of \\(A\\) to elements of \\(B\\) obviously defines a relation between \\(A\\) and \\(B\\), namely the relation which holds between \\(x\\) and \\(y\\) iff \\(f(x) = y\\). In fact, we might even—if we are interested in reducing the building blocks of mathematics for instance—identify the function \\(f\\) with this relation, i.e., with a set of pairs. This then raises the question: which relations define functions in this way? 定义 2.35 (Graph of a function) Let \\(f\\colon A \\to B\\) be a function. The graph of \\(f\\) is the relation \\(R_f \\subseteq A \\times B\\) defined by \\[R_f = \\lbrace ⟨x,y⟩: f(x) = y\\rbrace.\\] The graph of a function is uniquely determined, by extensionality. Moreover, extensionality (on sets) will immediate vindicate the implicit principle of extensionality for functions, whereby if \\(f\\) and \\(g\\) share a domain and codomain then they are identical if they agree on all values. Similarly, if a relation is “functional,” then it is the graph of a function. 命题 2.7 Let \\(R \\subseteq A \\times B\\) be such that: &gt; 1. If \\(Rxy\\) and \\(Rxz\\) then \\(y = z\\); and &gt; 1. for every \\(x \\in A\\) there is some \\(y \\in B\\) such that \\(⟨x,y⟩ \\in R\\). Then \\(R\\) is the graph of the function \\(f\\colon A \\to B\\) defined by \\(f(x) = y\\) iff \\(Rxy\\). Proof: Suppose there is a \\(y\\) such that \\(Rxy\\). If there were another \\(z \\neq y\\) such that \\(Rxz\\), the condition on \\(R\\) would be violated. Hence, if there is a \\(y\\) such that \\(Rxy\\), this \\(y\\) is unique, and so \\(f\\) is well-defined. Obviously, \\(R_f = R\\). Every function \\(f\\colon A \\to B\\) has a graph, i.e., a relation on \\(A \\times B\\) defined by \\(f(x) = y\\). On the other hand, every relation \\(R \\subseteq A \\times B\\) with the properties given in Proposition 1.6 is the graph of a function \\(f \\colon A \\to B\\). Because of this close connection between functions and their graphs, we can think of a function simply as its graph. In other words, functions can be identified with certain relations, i.e., with certain sets of tuples. Note, though, that the spirit of this “identification” is as in §1.1.1（P.28）: it is not a claim about the metaphysics of functions, but an observation that it is convenient to treat functions as certain sets. One reason that this is so convenient, is that We can now consider performing similar operations on functions as we performed on relations (see §1.1.6（P.34）). In particular: 定义 2.36 Let \\(f \\colon A \\to B\\) be a function with \\(C\\subseteq A\\). The restriction of \\(f\\) to \\(C\\) is the function \\(f\\upharpoonright_{C}\\colon C \\to B\\) defined by \\((f\\upharpoonright_{C})(x) = f(x)\\) for all \\(x \\in C\\). In other words, \\(f\\upharpoonright_{C} = \\lbrace ⟨x, y⟩ \\in R_f: x \\in C\\rbrace\\). The application of \\(f\\) to \\(C\\) is \\(f[C] = \\lbrace f(x): x \\in C\\rbrace\\). We also call this the image of \\(C\\) under \\(f\\). It follows from these definition that \\(\\text{ran}(f) = f[\\text{dom}(f)]\\), for any function \\(f\\). These notions are exactly as one would expect, given the definitions in §1.1.6（P.34）and our identification of functions with relations. But two other operations—inverses and relative products—require a little more detail. We will provide that in the §1.2.3（P.41）and §1.2.4（P.42）. 2.3.4 Inverses of Functions We think of functions as maps. An obvious question to ask about functions, then, is whether the mapping can be “reversed.” For instance, the successor function \\(f(x) = x + 1\\) can be reversed, in the sense that the function \\(g(y) = y - 1\\) “undoes” what \\(f\\) does. But we must be careful. Although the definition of \\(g\\) defines a function \\(\\mathbb{Z} \\to \\mathbb{Z}\\), it does not define a function \\(\\mathbb{N} \\to \\mathbb{N}\\), since \\(g(0) \\notin \\mathbb{N}\\). So even in simple cases, it is not quite obvious whether a function can be reversed; it may depend on the domain and codomain. This is made more precise by the notion of an inverse of a function. 定义 2.37 (Inverses of Functions) A function \\(g \\colon B \\to A\\) is an inverse of a function \\(f \\colon A \\to B\\) if \\(f(g(y)) = y\\) and \\(g(f(x)) = x\\) for all \\(x \\in A\\) and \\(y \\in B\\). If \\(f\\) has an inverse \\(g\\), we often write \\(f^{-1}\\) instead of \\(g\\). Now we will determine when functions have inverses. A good candidate for an inverse of \\(f\\colon A \\to B\\) is \\(g\\colon B \\to A\\) “defined by” \\[g(y) = \\text{&quot;the&quot; $x$ such that $f(x) = y$.}\\] But the scare quotes around “defined by” (and “the”) suggest that this is not a definition. At least, it will not always work, with complete generality. For, in order for this definition to specify a function, there has to be one and only one \\(x\\) such that \\(f(x) = y\\)—the output of \\(g\\) has to be uniquely specified. Moreover, it has to be specified for every \\(y \\in B\\). If there are \\(x_1\\) and \\(x_2 \\in A\\) with \\(x_1 \\neq x_2\\) but \\(f(x_1) = f(x_2)\\), then \\(g(y)\\) would not be uniquely specified for \\(y = f(x_1) = f(x_2)\\). And if there is no \\(x\\) at all such that \\(f(x) = y\\), then \\(g(y)\\) is not specified at all. In other words, for \\(g\\) to be defined, \\(f\\) must be both injective and surjective. 命题 2.8 Every bijection has a unique inverse. Proof: Exercise. 问题 2.17 Prove Proposition 2.8. That is, show that if \\(f\\colon A \\to B\\) is bijective, an inverse \\(g\\) of \\(f\\) exists. You have to define such a \\(g\\), show that it is a function, and show that it is an inverse of \\(f\\), i.e., \\(f(g(y)) = y\\) and \\(g(f(x)) = x\\) for all \\(x \\in A\\) and \\(y \\in B\\). However, there is a slightly more general way to extract inverses. We saw in §1.2.1（P.37）that every function \\(f\\) induces a surjection \\(f&#39; \\colon A \\to \\text{ran}(f)\\) by letting \\(f&#39;(x) = f(x)\\) for all \\(x \\in A\\). Clearly, if \\(f\\) is an injection, then \\(f&#39;\\) is a bijection, so that it has a unique inverse by Proposition 1.7. By a very minor abuse of notation, we sometimes call the inverse of \\(f&#39;\\) simply “the inverse of \\(f\\).” 问题 2.18 Show that if \\(f\\colon A \\to B\\) has an inverse \\(g\\), then \\(f\\) is bijective. 命题 2.9 Every function \\(f\\) has at most one inverse. Proof: Exercise. 问题 2.19 Prove Proposition 1.8. That is, show that if \\(g\\colon B \\to A\\) and \\(g&#39;\\colon B \\to A\\) are inverses of \\(f\\colon A \\to B\\), then \\(g = g&#39;\\), i.e., for all \\(y \\in B\\), \\(g(y) = g&#39;(y)\\). 2.3.5 Composition of Functions We saw in§1.2.3（P.41）that the inverse \\(f^{-1}\\) of a bijection \\(f\\) is itself a function. Another operation on functions is composition: We can define a new function by composing two functions, \\(f\\) and \\(g\\), i.e., by first applying \\(f\\) and then \\(g\\). Of course, this is only possible if the ranges and domains match, i.e., the range of \\(f\\) must be a subset of the domain of \\(g\\). This operation on functions is the analogue of the operation of relative product on relations from §1.1.6（P.34）. A diagram might help to explain the idea of composition. In Figure 1.7, we depict two functions \\(f \\colon A \\to B\\) and \\(g \\colon B \\to C\\) and their composition \\((g\\circ f)\\). The function \\((g\\circ f) \\colon A \\to C\\) pairs each element of \\(A\\) with a element of \\(C\\). We specify which element of \\(C\\) a element of \\(A\\) is paired with as follows: given an input \\(x \\in A\\), first apply the function \\(f\\) to \\(x\\), which will output some \\(f(x) = y \\in B\\), then apply the function \\(g\\) to \\(y\\), which will output some \\(g(f(x)) = g(y) = z \\in C\\). 定义 2.38 (Composition) Let \\(f\\colon A \\to B\\) and \\(g\\colon B \\to C\\) be functions. The composition of \\(f\\) with \\(g\\) is \\(g\\circ f \\colon A \\to C\\), where \\((g\\circ f)(x) = g(f(x))\\). 例 2.34 Consider the functions \\(f(x) = x + 1\\), and \\(g(x) = 2x\\). Since \\((g\\circ f)(x) = g(f(x))\\), for each input \\(x\\) you must first take its successor, then multiply the result by two. So their composition is given by \\((g\\circ f)(x) = 2(x+1)\\). 问题 2.20 Show that if \\(f \\colon A \\to B\\) and \\(g \\colon B \\to C\\) are both injective, then \\(g\\circ f\\colon A \\to C\\) is injective. 问题 2.21 Show that if \\(f \\colon A \\to B\\) and \\(g \\colon B \\to C\\) are both surjective, then \\(g\\circ f\\colon A \\to C\\) is surjective. 问题 2.22 Suppose \\(f \\colon A \\to B\\) and \\(g \\colon B \\to C\\). Show that the graph of \\(g\\circ f\\) is \\(R_f \\mid R_g\\). 2.3.6 Partial Functions It is sometimes useful to relax the definition of function so that it is not required that the output of the function is defined for all possible inputs. Such mappings are called partial functions. 定义 2.39 (Partial function) A partial function \\(f \\colon A \\nrightarrow B\\) is a mapping which assigns to every element of \\(A\\) at most one element of \\(B\\). If \\(f\\) assigns an element of \\(B\\) to \\(x \\in A\\), we say \\(f(x)\\) is defined, and otherwise undefined. If \\(f(x)\\) is defined, we write \\(f(x) \\downarrow\\), otherwise \\(f(x) \\uparrow\\). The domain of a partial function \\(f\\) is the subset of \\(A\\) where it is defined, i.e., \\(\\text{dom}(f) = \\lbrace x \\in A: f(x) \\downarrow\\rbrace\\). 例 2.35 Every function \\(f\\colon A \\to B\\) is also a partial function. Partial functions that are defined everywhere on \\(A\\)—i.e., what we so far have simply called a function—are also called total functions. 例 2.36 The partial function \\(f \\colon \\mathbb{R} \\nrightarrow \\mathbb{R}\\) given by \\(f(x) = 1/x\\) is undefined for \\(x = 0\\), and defined everywhere else. 问题 2.23 Given \\(f\\colon A \\nrightarrow B\\), define the partial function \\(g\\colon B \\nrightarrow A\\) by: for any \\(y \\in B\\), if there is a unique \\(x \\in A\\) such that \\(f(x) = y\\), then \\(g(y) = x\\); otherwise \\(g(y) \\uparrow\\). Show that if \\(f\\) is injective, then \\(g(f(x)) = x\\) for all \\(x \\in \\text{dom}(f)\\), and \\(f(g(y)) = y\\) for all \\(y \\in \\text{ran}(f)\\). 定义 2.40 (Graph of a partial function) Let \\(f\\colon A \\nrightarrow B\\) be a partial function. The graph of \\(f\\) is the relation \\(R_f \\subseteq A \\times B\\) defined by \\[R_f = \\lbrace ⟨x,y⟩: f(x) = y\\rbrace.\\] 命题 2.10 Suppose \\(R \\subseteq A \\times B\\) has the property that whenever \\(Rxy\\) and \\(Rxy&#39;\\) then \\(y = y&#39;\\). Then \\(R\\) is the graph of the partial function \\(f\\colon X \\nrightarrow Y\\) defined by: if there is a \\(y\\) such that \\(Rxy\\), then \\(f(x) = y\\), otherwise \\(f(x) \\uparrow\\). If \\(R\\) is also serial, i.e., for each \\(x \\in X\\) there is a \\(y \\in Y\\) such that \\(Rxy\\), then \\(f\\) is total. Proof: Suppose there is a \\(y\\) such that \\(Rxy\\). If there were another \\(y&#39; \\neq y\\) such that \\(Rxy&#39;\\), the condition on \\(R\\) would be violated. Hence, if there is a \\(y\\) such that \\(Rxy\\), that \\(y\\) is unique, and so \\(f\\) is well-defined. Obviously, \\(R_f = R\\) and \\(f\\) is total if \\(R\\) is serial. 2.4 基数：集合大小的度量 This section discusses enumerations, countability and uncountability. Several sections come in two versions: a more elementary one, that takes enumerations to be lists, or surjections from \\(\\mathbb{Z}^{+}\\); and a more abstract onethat defines enumerations as bijections with \\(\\mathbb{N}\\). 2.4.1 Introduction When Georg Cantor developed set theory in the 1870s, one of his aims was to make palatable the idea of an infinite collection—an actual infinity, as the medievals would say. A key part of this was his treatment of the size of different sets. If \\(a\\), \\(b\\) and \\(c\\) are all distinct, then the set \\(\\lbrace a, b, c\\rbrace\\) is intuitively larger than \\(\\lbrace a, b\\rbrace\\). But what about infinite sets? Are they all as large as each other? It turns out that they are not. The first important idea here is that of an enumeration. We can list every finite set by listing all its elements. For some infinite sets, we can also list all their elements if we allow the list itself to be infinite. Such sets are called enumerable. Cantor’s surprising result, which we will fully understand by the end of this section, was that some infinite sets are not enumerable. 2.4.2 Enumerations and enumerable Sets This section discusses enumerations of sets, defining them as surjections from \\(\\mathbb{Z}^{+}\\). It does things slowly, for readers with little mathematical background. An alternative, terser version is given in §1.3.10（P.62）, which defines enumerations differently: as bijections with \\(\\mathbb{N}\\) (or an initial segment). We’ve already given examples of sets by listing their elements. Let’s discuss in more general terms how and when we can list the elements of a set, even if that set is infinite. 定义 2.41 (Enumeration, informally) Informally, an enumeration of a set \\(A\\) is a list (possibly infinite) of elements of \\(A\\) such that every element of \\(A\\) appears on the list at some finite position. If \\(A\\) has an enumeration, then \\(A\\) is said to be enumerable. A couple of points about enumerations: We count as enumerations only lists which have a beginning and in which every element other than the first has a single element immediately preceding it. In other words, there are only finitely many elements between the first element of the list and any other element. In particular, this means that every element of an enumeration has a finite position: the first element has position \\(1\\), the second position \\(2\\), etc. We can have different enumerations of the same set \\(A\\) which differ by the order in which the elements appear: \\(4\\), \\(1\\), \\(25\\), \\(16\\), \\(9\\) enumerates the (set of the) first five square numbers just as well as \\(1\\), \\(4\\), \\(9\\), \\(16\\), \\(25\\) does. Redundant enumerations are still enumerations: \\(1\\), \\(1\\), \\(2\\), \\(2\\), \\(3\\), \\(3, \\cdots\\), enumerates the same set as \\(1\\), \\(2\\), \\(3, \\cdots\\), does. Order and redundancy do matter when we specify an enumeration: we can enumerate the positive integers beginning with \\(1\\), \\(2\\), \\(3\\), \\(1, \\cdots\\), but the pattern is easier to see when enumerated in the standard way as \\(1\\), \\(2\\), \\(3\\), \\(4, \\cdots\\). Enumerations must have a beginning: , \\(3\\), \\(2\\), \\(1\\) is not an enumeration of the positive integers because it has no first element. To see how this follows from the informal definition, ask yourself, “at what position in the list does the number 76 appear?” The following is not an enumeration of the positive integers: \\(1\\), \\(3\\), \\(5, \\cdots, 2\\), \\(4\\), \\(6, \\cdots\\). The problem is that the even numbers occur at places \\(\\infty + 1\\), \\(\\infty + 2\\), \\(\\infty + 3\\), rather than at finite positions. The empty set is enumerable: it is enumerated by the empty list! 命题 2.11 If \\(A\\) has an enumeration, it has an enumeration without repetitions. Proof: Suppose \\(A\\) has an enumeration \\(x_1\\), \\(x_2, \\cdots\\), in which each \\(x_i\\) is an element of \\(A\\). We can remove repetitions from an enumeration by removing repeated elements. For instance, we can turn the enumeration into a new one in which we list \\(x_i\\) if it is an element of \\(A\\) that is not among \\(x_1, \\cdots, x_{i-1}\\) or remove \\(x_i\\) from the list if it already appears among \\(x_1, \\cdots, x_{i-1}\\). The last argument shows that in order to get a good handle on enumerations and enumerable sets and to prove things about them, we need a more precise definition. The following provides it. 定义 2.42 (Enumeration, formally) An enumeration of a set \\(A \\neq \\varnothing\\) is any surjective function \\(f \\colon \\mathbb{Z}^{+} \\to A\\). Let’s convince ourselves that the formal definition and the informal definition using a possibly infinite list are equivalent. First, any surjective function from \\(\\mathbb{Z}^{+}\\) to a set \\(A\\) enumerates \\(A\\). Such a function determines an enumeration as defined informally above: the list \\(f(1)\\), \\(f(2)\\), \\(f(3), \\cdots\\). Since \\(f\\) is surjective, every element of \\(A\\) is guaranteed to be the value of \\(f(n)\\) for some \\(n \\in \\mathbb{Z}^{+}\\). Hence, every element of \\(A\\) appears at some finite position in the list. Since the function may not be injective, the list may be redundant, but that is acceptable (as noted above). On the other hand, given a list that enumerates all elements of \\(A\\), we can define a surjective function \\(f\\colon \\mathbb{Z}^{+} \\to A\\) by letting \\(f(n)\\) be the \\(n\\)th element of the list, or the final element of the list if there is no \\(n\\)th element. The only case where this does not produce a surjective function is when \\(A\\) is empty, and hence the list is empty. So, every non-empty list determines a surjective function \\(f\\colon \\mathbb{Z}^{+} \\to A\\). 定义 2.43 A set \\(A\\) is enumerable iff it is empty or has an enumeration. 例 2.37 A function enumerating the positive integers (\\(\\mathbb{Z}^{+}\\)) is simply the identity function given by \\(f(n) = n\\). A function enumerating the natural numbers \\(\\mathbb{N}\\) is the function \\(g(n) = n - 1\\). 例 2.38 The functions \\(f\\colon \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}\\) and \\(g \\colon \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}\\) given by \\[\\begin{align*} &amp; f(n) = 2n \\text{ and}\\\\ &amp; g(n) = 2n+1 \\end{align*}\\] enumerate the even positive integers and the odd positive integers, respectively. However, neither function is an enumeration of \\(\\mathbb{Z}^{+}\\), since neither is surjective. 问题 2.24 Define an enumeration of the positive squares \\(1\\), \\(4\\), \\(9\\), \\(16, \\cdots\\) 例 2.39 The function \\(f(n) = (-1)^{n} \\lceil \\frac{(n-1)}{2}\\rceil\\) (where \\(\\lceil x \\rceil\\) denotes the ceiling function, which rounds \\(x\\) up to the nearest integer) enumerates the set of integers \\(\\mathbb{Z}\\). Notice how \\(f\\) generates the values of \\(\\mathbb{Z}\\) by “hopping” back and forth between positive and negative integers: \\[ \\begin{array}{c c c c c c c c} f(1) &amp; f(2) &amp; f(3) &amp; f(4) &amp; f(5) &amp; f(6) &amp; f(7) &amp; \\cdots \\\\ \\\\ - \\lceil \\tfrac{0}{2} \\rceil &amp; \\lceil \\tfrac{1}{2}\\rceil &amp; - \\lceil \\tfrac{2}{2} \\rceil &amp; \\lceil \\tfrac{3}{2} \\rceil &amp; - \\lceil \\tfrac{4}{2} \\rceil &amp; \\lceil \\tfrac{5}{2} \\rceil &amp; - \\lceil \\tfrac{6}{2} \\rceil &amp; \\cdots \\\\ \\\\ 0 &amp; 1 &amp; -1 &amp; 2 &amp; -2 &amp; 3 &amp; \\cdots \\end{array} \\] You can also think of \\(f\\) as defined by cases as follows: \\[ f(n) = \\begin{cases} 0 &amp; \\text{if $n = 1$}\\\\ n/2 &amp; \\text{if $n$ is even}\\\\ -(n-1)/2 &amp; \\text{if $n$ is odd and $&gt;1$} \\end{cases} \\] 问题 2.25 Show that if \\(A\\) and \\(B\\) are enumerable, so is \\(A \\cup B\\). To do this, suppose there are surjective functions \\(f\\colon \\mathbb{Z}^{+} \\to A\\) and \\(g\\colon \\mathbb{Z}^{+} \\to B\\), and define a surjective function \\(h\\colon \\mathbb{Z}^{+} \\to A \\cup B\\) and prove that it is surjective. Also consider the cases where \\(A\\) or \\(B = \\varnothing\\). 问题 2.26 Show that if \\(B \\subseteq A\\) and \\(A\\) is enumerable, so is \\(B\\). To do this, suppose there is a surjective function \\(f\\colon \\mathbb{Z}^{+} \\to A\\). Define a surjective function \\(g\\colon \\mathbb{Z}^{+} \\to B\\) and prove that it is surjective. What happens if \\(B = \\varnothing\\)? 问题 2.27 Show by induction on \\(n\\) that if \\(A_1\\), \\(A_2, \\cdots, A_n\\) are all enumerable, so is \\(A_1 \\cup \\cdots \\cup A_n\\). You may assume the fact that if two sets \\(A\\) and \\(B\\) are enumerable, so is \\(A \\cup B\\). Although it is perhaps more natural when listing the elements of a set to start counting from the \\(1\\)st element, mathematicians like to use the natural numbers \\(\\mathbb{N}\\) for counting things. They talk about the \\(0\\)th, \\(1\\)st, \\(2\\)nd, and so on, elements of a list. Correspondingly, we can define an enumeration as a surjective function from \\(\\mathbb{N}\\) to \\(A\\). Of course, the two definitions are equivalent. 命题 2.12 There is a surjection \\(f\\colon \\mathbb{Z}^{+} \\to A\\) iff there is a surjection \\(g\\colon \\mathbb{N} \\to A\\). Proof: Given a surjection \\(f\\colon \\mathbb{Z}^{+} \\to A\\), we can define \\(g(n) = f(n+1)\\) for all \\(n \\in \\mathbb{N}\\). It is easy to see that \\(g\\colon \\mathbb{N} \\to A\\) is surjective. Conversely, given a surjection \\(g\\colon \\mathbb{N} \\to A\\), define \\(f(n) = g(n+1)\\). This gives us the following result: 推论 2.1 A set \\(A\\) is enumerable iff it is empty or there is a surjective function \\(f\\colon \\mathbb{N} \\to A\\). We discussed above than an list of elements of a set \\(A\\) can be turned into a list without repetitions. This is also true for enumerations, but a bit harder to formulate and prove rigorously. Any function \\(f\\colon \\mathbb{Z}^{+} \\to A\\) must be defined for all \\(n \\in \\mathbb{Z}^{+}\\). If there are only finitely many elements in \\(A\\) then we clearly cannot have a function defined on the infinitely many elements of \\(\\mathbb{Z}^{+}\\) that takes as values all the elements of \\(A\\) but never takes the same value twice. In that case, i.e., in the case where the list without repetitions is finite, we must choose a different domain for \\(f\\), one with only finitely many elements. Not having repetitions means that \\(f\\) must be injective. Since it is also surjective, we are looking for a bijection between some finite set \\(\\lbrace 1, \\cdots, n\\rbrace\\) or \\(\\mathbb{Z}^{+}\\) and \\(A\\). 推论 2.2 A set \\(A\\) is enumerable iff it is empty or there is a bijection \\(f\\colon N \\to A\\) where either \\(N = \\mathbb{N}\\) or \\(N = \\lbrace 0, \\cdots, n\\rbrace\\) for some \\(n \\in \\mathbb{N}\\). Proof: \\(A\\) is enumerable iff \\(A\\) is empty or there is a surjective \\(f\\colon \\mathbb{Z}^{+} \\to A\\). By Proposition 1.12, the latter holds iff there is a bijective function \\(f\\colon Z \\to A\\) where \\(Z = \\mathbb{Z}^{+}\\) or \\(Z = \\lbrace 1, \\cdots, n\\rbrace\\) for some \\(n \\in \\mathbb{Z}^{+}\\). By the same argument as in the proof of Proposition 1.11, that in turn is the case iff there is a bijection \\(g\\colon N \\to A\\) where either \\(N = \\mathbb{N}\\) or \\(N = \\lbrace 0, \\cdots, n-1\\rbrace\\). 问题 2.28 According to Definition1.48（P.63）, a set \\(A\\) is enumerable iff \\(A = \\varnothing\\) or there is a surjective \\(f\\colon \\mathbb{Z}^{+} \\to A\\). It is also possible to define “enumerable set” precisely by: a set is enumerable iff there is a injective function \\(g\\colon A \\to \\mathbb{Z}^{+}\\). Show that the definitions are equivalent, i.e., show that there is a injective function \\(g\\colon A \\to \\mathbb{Z}^{+}\\) iff either \\(A = \\varnothing\\) or there is a surjective \\(f\\colon \\mathbb{Z}^{+} \\to A\\). 2.4.3 Cantor’s Zig-Zag Method We’ve already considered some “easy” enumerations. Now we will consider something a bit harder. Consider the set of pairs of natural numbers, which we defined in§1.0.4（P.22）defined by: \\[\\mathbb{N} \\times \\mathbb{N} = \\lbrace ⟨n,m⟩: n,m \\in \\mathbb{N}\\rbrace\\] We can organize these ordered pairs into an array, like so: \\[ \\begin{array}{ c | c | c | c | c | c} &amp; \\mathbf 0 &amp; \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\cdots \\\\ \\hline \\mathbf 0 &amp; ⟨0,0⟩ &amp; ⟨0,1⟩ &amp; ⟨0,2⟩ &amp; ⟨0,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf 1 &amp; ⟨1,0⟩ &amp; ⟨1,1⟩ &amp; ⟨1,2⟩ &amp; ⟨1,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf 2 &amp; ⟨2,0⟩ &amp; ⟨2,1⟩ &amp; ⟨2,2⟩ &amp; ⟨2,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf 3 &amp; ⟨3,0⟩ &amp; ⟨3,1⟩ &amp; ⟨3,2⟩ &amp; ⟨3,3⟩ &amp; \\cdots \\\\ \\hline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots\\\\ \\end{array} \\] Clearly, every ordered pair in \\(\\mathbb{N} \\times \\mathbb{N}\\) will appear exactly once in the array. In particular, \\(⟨n,m⟩\\) will appear in the \\(n\\)th row and \\(m\\)th column. But how do we organize the elements of such an array into a “one-dimensional” list? The pattern in the array below demonstrates one way to do this (although of course there are many other options): \\[ \\begin{array}{ c | c | c | c | c | c | c} &amp; \\mathbf 0 &amp; \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\mathbf 4 &amp;\\cdots \\\\ \\hline \\mathbf 0 &amp; 0 &amp; 1&amp; 3 &amp; 6&amp; 10 &amp;\\cdots \\\\ \\hline \\mathbf 1 &amp;2 &amp; 4&amp; 7 &amp; 11 &amp; \\cdots &amp;\\cdots \\\\ \\hline \\mathbf 2 &amp; 5 &amp; 8 &amp; 12 &amp; \\cdots &amp; \\cdots&amp;\\cdots \\\\ \\hline \\mathbf 3 &amp; 9 &amp; 13 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\mathbf 4 &amp; 14 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots&amp;\\cdots &amp; \\ddots\\\\ \\end{array} \\] This pattern is called Cantor’s zig-zag method. It enumerates \\(\\mathbb{N} \\times \\mathbb{N}\\) as follows: \\[⟨0,0⟩, ⟨0,1⟩, ⟨1,0⟩, ⟨0,2⟩, ⟨1,1⟩, ⟨2,0⟩, ⟨0,3⟩, ⟨1,2⟩, ⟨2,1⟩, ⟨3,0⟩, \\cdots\\] And this establishes the following: 命题 2.13 \\(\\mathbb{N} \\times \\mathbb{N}\\) is enumerable. Proof: Let \\(f \\colon \\mathbb{N} \\to \\mathbb{N}\\times\\mathbb{N}\\) take each \\(k \\in \\mathbb{N}\\) to the tuple \\(⟨n,m⟩ \\in \\mathbb{N} \\times \\mathbb{N}\\) such that \\(k\\) is the value of the \\(n\\)th row and \\(m\\)th column in Cantor’s zig-zag array. This technique also generalises rather nicely. For example, we can use it to enumerate the set of ordered triples of natural numbers, i.e.: \\[\\mathbb{N} \\times \\mathbb{N} \\times \\mathbb{N} = \\Setabs{⟨n,m,k⟩}{n,m,k \\in \\mathbb{N}}\\] We think of \\(\\mathbb{N} \\times \\mathbb{N} \\times \\mathbb{N}\\) as the Cartesian product of \\(\\mathbb{N} \\times \\mathbb{N}\\) with \\(\\mathbb{N}\\), that is, \\[\\mathbb{N}^3 = (\\mathbb{N} \\times \\mathbb{N}) \\times \\mathbb{N} =\\lbrace ⟨⟨n,m⟩,k⟩: n, m, k \\in \\mathbb{N}\\rbrace\\] and thus we can enumerate \\(\\mathbb{N}^3\\) with an array by labelling one axis with the enumeration of \\(\\mathbb{N}\\), and the other axis with the enumeration of \\(\\mathbb{N}^2\\): \\[ \\begin{array}{ c | c | c | c | c | c} &amp; \\mathbf 0 &amp; \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\cdots \\\\ \\hline \\mathbf{⟨0,0⟩} &amp; ⟨0,0,0⟩ &amp; ⟨0,0,1⟩ &amp; ⟨0,0,2⟩ &amp; ⟨0,0,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf{⟨0,1⟩} &amp; ⟨0,1,0⟩ &amp; ⟨0,1,1⟩ &amp; ⟨0,1,2⟩ &amp; ⟨0,1,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf{⟨1,0⟩} &amp; ⟨1,0,0⟩ &amp; ⟨1,0,1⟩ &amp; ⟨1,0,2⟩ &amp; ⟨1,0,3⟩ &amp; \\cdots \\\\ \\hline \\mathbf{⟨0,2⟩} &amp; ⟨0,2,0⟩ &amp; ⟨0,2,1⟩ &amp; ⟨0,2,2⟩ &amp; ⟨0,2,3⟩ &amp; \\cdots\\\\ \\hline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots \\\\ \\end{array} \\] Thus, by using a method like Cantor’s zig-zag method, we may similarly obtain an enumeration of \\(\\mathbb{N}^3\\). And we can keep going, obtaining enumerations of \\(\\mathbb{N}^n\\) for any natural number \\(n\\). So, we have: 命题 2.14 \\(\\mathbb{N}^n\\) is enumerable, for every \\(n \\in \\mathbb{N}\\). 2.4.4 Pairing Functions and Codes Cantor’s zig-zag method makes the enumerability of \\(\\mathbb{N}^n\\) visually evident. But let us focus on our array depicting \\(\\mathbb{N}^2\\). Following the zig-zag line in the array and counting the places, we can check that \\(⟨1,2⟩\\) is associated with the number \\(7\\). However, it would be nice if we could compute this more directly. That is, it would be nice to have to hand the inverse of the zig-zag enumeration, \\(g\\colon \\mathbb{N}^2 \\to \\mathbb{N}\\), such that \\[\\begin{align*} &amp; g(⟨0,0⟩) = 0,\\;\\\\ &amp; g(⟨0,1⟩) = 1,\\;\\\\ &amp; g(⟨1,0⟩) = 2, \\; \\cdots,\\\\ &amp; g(⟨1,2⟩) = 7, \\; \\cdots \\end{align*}\\] This would enable to calculate exactly where \\(⟨n, m⟩\\) will occur in our enumeration. In fact, we can define \\(g\\) directly by making two observations. First: if the \\(n\\)th row and \\(m\\)th column contains value \\(v\\), then the \\((n+1)\\)st row and \\((m-1)\\)st column contains value \\(v + 1\\). Second: the first row of our enumeration consists of the triangular numbers, starting with \\(0\\), \\(1\\), \\(3\\), \\(5\\), etc. The \\(k\\)th triangular number is the sum of the natural numbers \\(&lt; k\\), which can be computed as \\(k(k+1)/2\\). Putting these two observations together, consider this function: \\[g(n,m) = \\frac{(n+m+1)(n+m)}{2} + n\\] We often just write \\(g(n, m)\\) rather that \\(g(⟨n, m⟩)\\), since it is easier on the eyes. This tells you first to determine the \\((n+m)^\\text{th}\\) triangle number, and then subtract \\(n\\) from it. And it populates the array in exactly the way we would like. So in particular, the pair \\(⟨1, 2⟩\\) is sent to \\(\\frac{4 \\times 3}{2} + 1 = 7\\). This function \\(g\\) is the inverse of an enumeration of a set of pairs. Such functions are called pairing functions. 定义 2.44 (Pairing function) A function \\(f\\colon A \\times B \\to \\mathbb{N}\\) is an arithmetical pairing function if \\(f\\) is injective. We also say that \\(f\\) encodes \\(A \\times B\\), and that \\(f(x,y)\\) is the code for \\(⟨x,y⟩\\). We can use pairing functions encode, e.g., pairs of natural numbers; or, in other words, we can represent each pair of elements using a single number. Using the inverse of the pairing function, we can decode the number, i.e., find out which pair it represents. 问题 2.29 Give an enumeration of the set of all non-negative rational numbers. 问题 2.30 Show that \\(\\mathbb{Q}\\) is enumerable. Recall that any rational number can be written as a fraction \\(z/m\\) with \\(z \\in \\mathbb{Z}\\), \\(m \\in \\mathbb{N}^+\\). 问题 2.31 Define an enumeration of \\(\\mathbb{B}^*\\). 问题 2.32 Recall from your introductory logic course that each possible truth table expresses a truth function. In other words, the truth functions are all functions from \\(\\mathbb{B}^k \\to \\mathbb{B}\\) for some \\(k\\). Prove that the set of all truth functions is enumerable. 问题 2.33 Show that the set of all finite subsets of an arbitrary infinite enumerable set is enumerable. 问题 2.34 A subset of \\(\\mathbb{N}\\) is said to be cofinite iff it is the complement of a finite set \\(\\mathbb{N}\\); that is, \\(A \\subseteq \\mathbb{N}\\) is cofinite iff \\(\\mathbb{N}\\setminus A\\) is finite. Let \\(I\\) be the set whose elements are exactly the finite and cofinite subsets of \\(\\mathbb{N}\\). Show that \\(I\\) is enumerable. 问题 2.35 Show that the enumerable union of enumerable sets is enumerable. That is, whenever \\(A_1\\), \\(A_2\\), are sets, and each \\(A_i\\) is enumerable, then the union \\(\\bigcup_{i=1}^\\infty A_i\\) of all of them is also enumerable. [NB: this is hard!] 问题 2.36 Let \\(f \\colon A \\times B \\to \\mathbb{N}\\) be an arbitrary pairing function. Show that the inverse of \\(f\\) is an enumeration of \\(A \\times B\\). 问题 2.37 Specify a function that encodes \\(\\mathbb{N}^3\\). 2.4.5 An Alternative Pairing Function There are other enumerations of \\(\\mathbb{N}^2\\) that make it easier to figure out what their inverses are. Here is one. Instead of visualizing the enumeration in an array, start with the list of positive integers associated with (initially) empty spaces. Imagine filling these spaces successively with pairs \\(⟨n,m⟩\\) as follow. Starting with the pairs that have \\(0\\) in the first place (i.e., pairs \\(⟨0,m⟩\\)), put the first (i.e., \\(⟨0,0⟩\\)) in the first empty place, then skip an empty space, put the second (i.e., \\(⟨0,2⟩\\)) in the next empty place, skip one again, and so forth. The (incomplete) beginning of our enumeration now looks like this \\[ \\begin{array}{@{}c c c c c c c c c c c@{}} \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\mathbf 4 &amp; \\mathbf 5 &amp; \\mathbf 6 &amp; \\mathbf 7 &amp; \\mathbf 8 &amp; \\mathbf 9 &amp; \\mathbf{10} &amp; \\cdots \\\\ \\\\ ⟨0,1⟩ &amp; &amp; ⟨0,2⟩ &amp; &amp; ⟨0,3⟩ &amp; &amp; ⟨0,4⟩ &amp; &amp; ⟨0,5⟩ &amp; &amp; \\cdots \\\\ \\end{array} \\] Repeat this with pairs \\(⟨1,m⟩\\) for the place that still remain empty, again skipping every other empty place: \\[ \\begin{array}{@{}c c c c c c c c c c c@{}} \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\mathbf 4 &amp; \\mathbf 5 &amp; \\mathbf 6 &amp; \\mathbf 7 &amp; \\mathbf 8 &amp; \\mathbf 9 &amp; \\mathbf{10} &amp; \\cdots \\\\ \\\\ ⟨0,0⟩ &amp; ⟨1,0⟩ &amp; ⟨0,1⟩ &amp; &amp; ⟨0,2⟩ &amp; ⟨1,1⟩ &amp; ⟨0,3⟩ &amp; &amp; ⟨0,4⟩ &amp; ⟨1,2⟩ &amp; \\cdots \\\\ \\end{array} \\] Enter pairs \\(⟨2,m⟩\\), \\(⟨2,m⟩\\), etc., in the same way. Our completed enumeration thus starts like this: \\[ \\begin{array}{@{}cc c c c c c c c c c@{}} \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\mathbf 4 &amp; \\mathbf 5 &amp; \\mathbf 6 &amp; \\mathbf 7 &amp; \\mathbf 8 &amp; \\mathbf 9 &amp; \\mathbf{10} &amp; \\cdots \\\\ \\\\ ⟨0,0⟩ &amp; ⟨1,0⟩ &amp; ⟨0,1⟩ &amp; ⟨2,0⟩ &amp; ⟨0,2⟩ &amp; ⟨1,1⟩ &amp; ⟨0,3⟩ &amp; ⟨3,0⟩ &amp; ⟨0,4⟩ &amp; ⟨1,2⟩ &amp; \\cdots \\\\ \\end{array} \\] If we number the cells in the array above according to this enumeration, we will not find a neat zig-zag line, but this arrangement: \\[ \\begin{array}{ c | c | c | c | c | c | c | c } &amp; \\mathbf 0 &amp; \\mathbf 1 &amp; \\mathbf 2 &amp; \\mathbf 3 &amp; \\mathbf 4 &amp; \\mathbf 5 &amp; \\cdots \\\\ \\hline \\mathbf 0 &amp; 1 &amp; 3 &amp; 5 &amp; 7 &amp; 9 &amp; 11 &amp; \\cdots \\\\ \\hline \\mathbf 1 &amp; 2 &amp; 6 &amp; 10 &amp; 14 &amp; 18 &amp; \\cdots &amp; \\cdots \\\\ \\hline \\mathbf 2 &amp; 4 &amp; 12 &amp; 20 &amp; 28 &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\mathbf 3 &amp; 8 &amp; 24 &amp; 40 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\mathbf 4 &amp; 16 &amp; 48 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\mathbf 5 &amp; 32 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ \\hline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots\\\\ \\end{array} \\] We can see that the pairs in row \\(0\\) are in the odd numbered places of our enumeration, i.e., pair \\(⟨0,m⟩\\) is in place \\(2m+1\\); pairs in the second row, \\(⟨1,m⟩\\), are in places whose number is the double of an odd number, specifically, \\(2 \\cdot (2m+1)\\); pairs in the third row, \\(⟨2,m⟩\\), are in places whose number is four times an odd number, \\(4 \\cdot (2m+1)\\); and so on. The factors of \\((2m+1)\\) for each row, \\(1\\), \\(2\\), \\(4\\), \\(8\\), , are exactly the powers of \\(2\\): \\(1= 2^0\\), \\(2 = 2^1\\), \\(4 = 2^2\\), \\(8 = 2^3, \\cdots\\).In fact, the relevant exponent is always the first member of the pair in question. Thus, for pair \\(⟨n,m⟩\\) the factor is \\(2^n\\). This gives us the general formula: \\(2^n \\cdot (2m+1)\\). However, this is a mapping of pairs to positive integers, i.e., \\(⟨0,0⟩\\) has position \\(1\\). If we want to begin at position \\(0\\) we must subtract \\(1\\) from the result. This gives us: 例 2.40 The function \\(h\\colon \\mathbb{N}^2 \\to \\mathbb{N}\\) given by \\[h(n,m) = 2^n (2m+1) - 1\\] is a pairing function for the set of pairs of natural numbers \\(\\mathbb{N}^2\\). Accordingly, in our second enumeration of \\(\\mathbb{N}^2\\), the pair \\(⟨0,0⟩\\) has code \\(h(0,0) = 2^0(2\\cdot 0+1) - 1 = 0\\); \\(⟨1,2⟩\\) has code \\(2^{1} \\cdot (2 \\cdot 2 + 1) - 1 = 2 \\cdot 5 - 1 = 9\\); \\(⟨2,6⟩\\) has code \\(2^{2} \\cdot (2 \\cdot 6 + 1) - 1 = 51\\). Sometimes it is enough to encode pairs of natural numbers \\(\\mathbb{N}^2\\) without requiring that the encoding is surjective. Such encodings have inverses that are only partial functions. 例 2.41 The function \\(j\\colon \\mathbb{N}^2 \\to \\mathbb{N}^+\\) given by \\[j(n,m) = 2^n3^m\\] is a injective function \\(\\mathbb{N}^2 \\to \\mathbb{N}\\). 2.4.6 Nonenumerable Sets This section proves the non-enumerability of \\(\\mathbb{B}^\\omega\\) and \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) using the definition in §1.3.1（P.45）. It is designed to be a little more elementary and a little more detailed than the version in §1.3.10（P.62）. Some sets, such as the set \\(\\mathbb{Z}^{+}\\) of positive integers, are infinite. So far we’ve seen examples of infinite sets which were all enumerable. However, there are also infinite sets which do not have this property. Such sets are called nonenumerable. First of all, it is perhaps already surprising that there are nonenumerable sets. For any enumerable set \\(A\\) there is a surjective function \\(f \\colon \\mathbb{Z}^{+} \\to A\\). If a set is nonenumerable there is no such function. That is, no function mapping the infinitely many elements of \\(\\mathbb{Z}^{+}\\) to \\(A\\) can exhaust all of \\(A\\). So there are “more” elements of \\(A\\) than the infinitely many positive integers. How would one prove that a set is nonenumerable? You have to show that no such surjective function can exist. Equivalently, you have to show that the elements of \\(A\\) cannot be enumerated in a one way infinite list. The best way to do this is to show that every list of elements of \\(A\\) must leave at least one element out; or that no function \\(f\\colon \\mathbb{Z}^{+} \\to A\\) can be surjective. We can do this using Cantor’s diagonal method. Given a list of elements of \\(A\\), say, \\(x_1\\), \\(x_2, \\cdots\\), we construct another element of \\(A\\) which, by its construction, cannot possibly be on that list. Our first example is the set \\(\\mathbb{B}^\\omega\\) of all infinite, non-gappy sequences of \\(0\\)’s and \\(1\\)’s. 定理 2.2 \\(\\mathbb{B}^\\omega\\) is nonenumerable. Proof: Suppose, by way of contradiction, that \\(\\mathbb{B}^\\omega\\) is enumerable, i.e., suppose that there is a list \\(s_{1}\\), \\(s_{2}\\), \\(s_{3}\\), \\(s_{4}, \\cdots\\), of all elements of \\(\\mathbb{B}^\\omega\\). Each of these \\(s_i\\) is itself an infinite sequence of \\(0\\)’s and \\(1\\)’s. Let’s call the \\(j\\)-th element of the \\(i\\)-th sequence in this list \\(s_i(j)\\). Then the \\(i\\)-th sequence \\(s_i\\) is \\[s_i(1), s_i(2), s_i(3), \\cdots\\] We may arrange this list, and the elements of each sequence \\(s_i\\) in it, in an array: \\[ \\begin{array}{c|c|c|c|c|c} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; \\cdots \\\\\\hline 1 &amp; \\mathbf{s_{1}(1)} &amp; s_{1}(2) &amp; s_{1}(3) &amp; s_1(4) &amp; \\cdots \\\\\\hline 2 &amp; s_{2}(1)&amp; \\mathbf{s_{2}(2)} &amp; s_2(3) &amp; s_2(4) &amp; \\cdots \\\\\\hline 3 &amp; s_{3}(1)&amp; s_{3}(2) &amp; \\mathbf{s_3(3)} &amp; s_3(4) &amp; \\cdots \\\\\\hline 4 &amp; s_{4}(1)&amp; s_{4}(2) &amp; s_4(3) &amp; \\mathbf{s_4(4)} &amp; \\cdots \\\\\\hline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\mathbf{\\ddots} \\end{array} \\] The labels down the side give the number of the sequence in the list \\(s_1\\), \\(s_2\\), ; the numbers across the top label the elements of the individual sequences. For instance, \\(s_{1}(1)\\) is a name for whatever number, a \\(0\\) or a \\(1\\), is the first element in the sequence \\(s_{1}\\), and so on. Now we construct an infinite sequence, \\(\\overline{s}\\), of \\(0\\)’s and \\(1\\)’s which cannot possibly be on this list. The definition of \\(\\overline{s}\\) will depend on the list \\(s_1\\), \\(s_2, \\cdots\\). Any infinite list of infinite sequences of \\(0\\)’s and \\(1\\)’s gives rise to an infinite sequence \\(\\overline{s}\\) which is guaranteed to not appear on the list. To define \\(\\overline{s}\\), we specify what all its elements are, i.e., we specify \\(\\overline{s}(n)\\) for all \\(n \\in \\mathbb{Z}^{+}\\). We do this by reading down the diagonal of the array above (hence the name “diagonal method”) and then changing every \\(1\\) to a \\(0\\) and every \\(1\\) to a \\(0\\). More abstractly, we define \\(\\overline{s}(n)\\) to be \\(0\\) or \\(1\\) according to whether the \\(n\\)-th element of the diagonal, \\(s_n(n)\\), is \\(1\\) or \\(0\\). \\[ \\overline{s}(n) = \\begin{cases} 1 &amp; \\text{if $s_{n}(n) = 0$}\\\\ 0 &amp; \\text{if $s_{n}(n) = 1$}. \\end{cases} \\] If you like formulas better than definitions by cases, you could also define \\(\\overline{s}(n) = 1 - s_n(n)\\). Clearly \\(\\overline{s}\\) is an infinite sequence of \\(0\\)’s and \\(1\\)’s, since it is just the mirror sequence to the sequence of \\(0\\)’s and \\(1\\)’s that appear on the diagonal of our array. So \\(\\overline{s}\\) is an element of \\(\\mathbb{B}^\\omega\\). But it cannot be on the list \\(s_1\\), \\(s_2, \\cdots\\), Why not? It can’t be the first sequence in the list, \\(s_1\\), because it differs from \\(s_1\\) in the first element. Whatever \\(s_1(1)\\) is, we defined \\(\\overline{s}(1)\\) to be the opposite. It can’t be the second sequence in the list, because \\(\\overline{s}\\) differs from \\(s_2\\) in the second element: if \\(s_2(2)\\) is \\(0\\), \\(\\overline{s}(2)\\) is \\(1\\), and vice versa. And so on. More precisely: if \\(\\overline{s}\\) were on the list, there would be some \\(k\\) so that \\(\\overline{s} = s_{k}\\). Two sequences are identical iff they agree at every place, i.e., for any \\(n\\), \\(\\overline{s}(n) = s_{k}(n)\\). So in particular, taking \\(n = k\\) as a special case, \\(\\overline{s}(k) = s_{k}(k)\\) would have to hold. \\(s_k(k)\\) is either \\(0\\) or \\(1\\). If it is \\(0\\) then \\(\\overline{s}(k)\\) must be \\(1\\)—that’s how we defined \\(\\overline{s}\\). But if \\(s_k(k) = 1\\) then, again because of the way we defined \\(\\overline{s}\\), \\(\\overline{s}(k) = 0\\). In either case \\(\\overline{s}(k) \\neq s_{k}(k)\\). We started by assuming that there is a list of elements of \\(\\mathbb{B}^\\omega\\), \\(s_1\\), \\(s_2, \\cdots\\), From this list we constructed a sequence \\(\\overline{s}\\) which we proved cannot be on the list. But it definitely is a sequence of \\(0\\)’s and \\(1\\)’s if all the \\(s_i\\) are sequences of \\(0\\)’s and \\(1\\)’s, i.e., \\(\\overline{s} \\in \\mathbb{B}^\\omega\\). This shows in particular that there can be no list of all elements of \\(\\mathbb{B}^\\omega\\), since for any such list we could also construct a sequence \\(\\overline{s}\\) guaranteed to not be on the list, so the assumption that there is a list of all sequences in \\(\\mathbb{B}^\\omega\\) leads to a contradiction. \\(\\blacksquare\\) This proof method is called “diagonalization” because it uses the diagonal of the array to define \\(\\overline{s}\\). Diagonalization need not involve the presence of an array: we can show that sets are not enumerable by using a similar idea even when no array and no actual diagonal is involved. 定理 2.3 \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) is not enumerable. Proof: We proceed in the same way, by showing that for every list of subsets of \\(\\mathbb{Z}^{+}\\) there is a subset of \\(\\mathbb{Z}^{+}\\) which cannot be on the list. Suppose the following is a given list of subsets of \\(\\mathbb{Z}^{+}\\): \\[ Z_{1}, Z_{2}, Z_{3}, \\cdots \\] We now define a set \\(\\overline{Z}\\) such that for any \\(n \\in \\mathbb{Z}^{+}\\), \\(n \\in \\overline{Z}\\) iff \\(n \\notin Z_{n}\\): \\[ \\overline{Z} = \\lbrace n \\in \\mathbb{Z}^{+}: n \\notin Z_n\\rbrace\\] \\(\\overline{Z}\\) is clearly a set of positive integers, since by assumption each \\(Z_n\\) is, and thus \\(\\overline{Z} \\in \\mathscr{P}({\\mathbb{Z})^{+}}\\). But \\(\\overline{Z}\\) cannot be on the list. To show this, we’ll establish that for each \\(k \\in \\mathbb{Z}^{+}\\), \\(\\overline{Z} \\neq Z_k\\). So let \\(k \\in \\mathbb{Z}^{+}\\) be arbitrary. We’ve defined \\(\\overline{Z}\\) so that for any \\(n \\in \\mathbb{Z}^{+}\\), \\(n \\in \\overline{Z}\\) iff \\(n \\notin Z_n\\). In particular, taking \\(n=k\\), \\(k \\in \\overline{Z}\\) iff \\(k \\notin Z_k\\). But this shows that \\(\\overline{Z} \\neq Z_k\\), since \\(k\\) is an element of one but not the other, and so \\(\\overline{Z}\\) and \\(Z_k\\) have different elements. Since \\(k\\) was arbitrary, \\(\\overline{Z}\\) is not on the list \\(Z_1\\), \\(Z_2, \\cdots\\) \\(blacksquare\\) The preceding proof did not mention a diagonal, but you can think of it as involving a diagonal if you picture it this way: Imagine the sets \\(Z_1\\), \\(Z_2, \\cdots\\), written in an array, where each element \\(j \\in Z_i\\) is listed in the \\(j\\)-th column. Say the first four sets on that list are \\(\\lbrace 1,2,3,\\cdots\\rbrace\\), \\(\\lbrace 2, 4, 6, \\cdots\\rbrace\\), \\(\\lbrace 1,2,5\\rbrace\\), and \\(\\lbrace 3,4,5,\\cdots\\rbrace\\). Then the array would begin with \\[ \\begin{array}{r@{}rrrrrrr} Z_1 = \\lbrace &amp; \\mathbf{1}, &amp; 2, &amp; 3, &amp; 4, &amp; 5, &amp; 6, &amp; \\cdots\\rbrace \\\\ Z_2 = \\lbrace &amp; &amp; \\mathbf{2}, &amp; &amp; 4, &amp; &amp; 6, &amp; \\cdots\\rbrace \\\\ Z_3 = \\lbrace &amp; 1, &amp; 2, &amp; &amp; &amp; 5\\phantom{,} &amp; &amp; \\rbrace \\\\ Z_4 = \\lbrace &amp; &amp; &amp; 3, &amp; \\mathbf{4}, &amp; 5, &amp; 6, &amp; \\cdots\\rbrace \\\\ \\vdots &amp; &amp; &amp; &amp; &amp; \\ddots \\end{array} \\] Then \\(\\overline{Z}\\) is the set obtained by going down the diagonal, leaving out any numbers that appear along the diagonal and include those \\(j\\) where the array has a gap in the \\(j\\)-th row/column. In the above case, we would leave out \\(1\\) and \\(2\\), include \\(3\\), leave out \\(4\\), etc. 问题 2.38 Show that \\(\\mathscr{P}({\\mathbb{N})}\\) is nonenumerable by a diagonal argument. 问题 2.39 Show that the set of functions \\(f \\colon \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}\\) is nonenumerable by an explicit diagonal argument. That is, show that if \\(f_1\\), \\(f_2\\), , is a list of functions and each \\(f_i\\colon \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}\\), then there is some \\(\\overline{f}\\colon \\mathbb{Z}^{+} \\to \\mathbb{Z}^{+}\\) not on this list. 2.4.7 Reduction This section proves non-enumerability by reduction, matching the results in §1.3.5（P.53）. An alternative, slightly more condensed version matching the results in §1.3.11（P.64）is provided in§1.3.12（P.66）. We showed \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) to be nonenumerable by a diagonalization argument. We already had a proof that \\(\\mathbb{B}^\\omega\\), the set of all infinite sequences of \\(0\\)s and \\(1\\)s, is nonenumerable. Here’s another way we can prove that \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) is nonenumerable: Show that if \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) is enumerable then \\(\\mathbb{B}^\\omega\\) is also enumerable. Since we know \\(\\mathbb{B}^\\omega\\) is not enumerable, \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) can’t be either. This is called reducing one problem to another—in this case, we reduce the problem of enumerating \\(\\mathbb{B}^\\omega\\) to the problem of enumerating \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\). A solution to the latter—an enumeration of \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\)—would yield a solution to the former—an enumeration of \\(\\mathbb{B}^\\omega\\). How do we reduce the problem of enumerating a set \\(B\\) to that of enumerating a set \\(A\\)? We provide a way of turning an enumeration of \\(A\\) into an enumeration of \\(B\\). The easiest way to do that is to define a surjective function \\(f\\colon A \\to B\\). If \\(x_1\\), \\(x_2, \\cdots\\), enumerates \\(A\\), then \\(f(x_1)\\), \\(f(x_2), \\cdots\\), would enumerate \\(B\\). In our case, we are looking for a surjective function \\(f\\colon \\mathscr{P}({\\mathbb{Z})^{+}} \\to \\mathbb{B}^\\omega\\). 问题 2.40 Show that if there is an injective function \\(g\\colon B \\to A\\), and \\(B\\) is nonenumerable, then so is \\(A\\). Do this by showing how you can use \\(g\\) to turn an enumeration of \\(A\\) into one of \\(B\\). Proof (Proof of Theorem 2.3 by reduction): Suppose that \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) were enumerable, and thus that there is an enumeration of it, \\(Z_{1}\\), \\(Z_{2}\\), \\(Z_{3}, \\cdots\\) Define the function \\(f \\colon \\mathscr{P}({\\mathbb{Z})^{+}} \\to \\mathbb{B}^\\omega\\) by letting \\(f(Z)\\) be the sequence \\(s_{k}\\) such that \\(s_{k}(n) = 1\\) iff \\(n \\in Z\\), and \\(s_k(n) = 0\\) otherwise. This clearly defines a function, since whenever \\(Z \\subseteq \\mathbb{Z}^{+}\\), any \\(n \\in \\mathbb{Z}^{+}\\) either is an element of \\(Z\\) or isn’t. For instance, the set \\(2\\mathbb{Z}^{+} = \\lbrace 2, 4, 6, \\cdots\\rbrace\\) of positive even numbers gets mapped to the sequence \\(010101\\cdots\\), the empty set gets mapped to \\(0000\\cdots\\) and the set \\(\\mathbb{Z}^{+}\\) itself to \\(1111\\cdots\\). It also is surjective: Every sequence of \\(0\\)s and \\(1\\)s corresponds to some set of positive integers, namely the one which has as its members those integers corresponding to the places where the sequence has \\(1\\)s. More precisely, suppose \\(s \\in \\mathbb{B}^\\omega\\). Define \\(Z \\subseteq \\mathbb{Z}^{+}\\) by: \\[Z = \\lbrace n \\in \\mathbb{Z}^{+}: s(n) = 1\\rbrace\\] Then \\(f(Z) = s\\), as can be verified by consulting the definition of \\(f\\). Now consider the list \\[f(Z_1), f(Z_2), f(Z_3), \\cdots\\] Since \\(f\\) is surjective, every member of \\(\\mathbb{B}^\\omega\\) must appear as a value of \\(f\\) for some argument, and so must appear on the list. This list must therefore enumerate all of \\(\\mathbb{B}^\\omega\\). So if \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) were enumerable, \\(\\mathbb{B}^\\omega\\) would be enumerable. But \\(\\mathbb{B}^\\omega\\) is nonenumerable (Theorem 2.2). Hence \\(\\mathscr{P}({\\mathbb{Z})^{+}}\\) is nonenumerable. \\(\\blacksquare\\) It is easy to be confused about the direction the reduction goes in. For instance, a surjective function \\(g \\colon \\mathbb{B}^\\omega \\to B\\) does not establish that \\(B\\) is nonenumerable. (Consider \\(g \\colon \\mathbb{B}^\\omega \\to \\mathbb{B}\\) defined by \\(g(s) = s(1)\\), the function that maps a sequence of \\(0\\)’s and \\(1\\)’s to its first element. It is surjective, because some sequences start with \\(0\\) and some start with \\(1\\). But \\(\\mathbb{B}\\) is finite.) Note also that the function \\(f\\) must be surjective, or otherwise the argument does not go through: \\(f(x_1)\\), \\(f(x_2), \\cdots\\), would then not be guaranteed to include all the elements of \\(B\\). For instance, \\[ h(n) = \\underbrace{000\\cdots0}_{\\text{$n$ $0$&#39;s}} \\] defines a function \\(h\\colon \\mathbb{Z}^{+} \\to \\mathbb{B}^\\omega\\), but \\(\\mathbb{Z}^{+}\\) is enumerable. 问题 2.41 Show that the set of all sets of pairs of positive integers is nonenumerable by a reduction argument. 问题 2.42 Show that \\(\\mathbb{N}^\\omega\\), the set of infinite sequences of natural numbers, is nonenumerable by a reduction argument. 问题 2.43 Let \\(P\\) be the set of functions from the set of positive integers to the set \\(\\lbrace 0\\rbrace\\), and let \\(Q\\) be the set of partial functions from the set of positive integers to the set \\(\\lbrace 0\\rbrace\\). Show that \\(P\\) is enumerable and \\(Q\\) is not. (Hint: reduce the problem of enumerating \\(\\mathbb{B}^\\omega\\) to enumerating \\(Q\\)). 问题 2.44 Let \\(S\\) be the set of all surjective functions from the set of positive integers to the set \\(\\lbrace 0,1\\rbrace\\), i.e., \\(S\\) consists of all surjective \\(f\\colon \\mathbb{Z}^{+} \\to \\mathbb{B}\\). Show that \\(S\\) is nonenumerable. 问题 2.45 Show that the set \\(\\mathbb{R}\\) of all real numbers is nonenumerable. Editorial comments 有屁请在此处放，看看谁的屁更响。 "],["chap-truth-table.html", " 3 联结词与真值表 3.1 联结词与复合句 3.2 真值、非真值函数联结词 3.3 符号化 3.4 命题逻辑的基本语法 3.5 基本真值表和真值的计算 3.6 若干基本语义概念的真值表刻画 3.7 本章习题", " 3 联结词与真值表 There is no royal road to logic, and really valuable ideas can only be had at the price of close attention.Charles Peirce, How to Make Our Ideas Clear, 1878 命题逻辑（propositional logic），也称语句逻辑（sentential logic），是从联结词和复合句的角度讨论逻辑蕴涵、可演绎性和一致性。这意味着我们会忽略很多常见的东西，如主词、谓词和量词等。命题和语句其实还是有区别的，但我们在这门课里暂时不加区分（技术用语除外）。用「命题」方便时用「命题」，用「语句」或「句子」方便时用「语句」或「句子」。 论说的前提和结论都由陈述句（declarative sentence）构成，我们的信念也由陈述句表达。那么，什么是陈述句呢？直观上我们似乎都知道陈述句是什么样的句子，但要对这个问题提供一个严格而准确的答案是不容易的。目前，我们可以满足于一个简单化的答案：对于任何一个语句 \\(\\varphi\\)，如果我们问「\\(\\varphi\\) 是真的吗？\\(\\varphi\\) 是假的吗？」是有意义的，那么我们就称 \\(\\varphi\\) 为陈述句。(Hodges, 1977)针对本书讨论的句子，我们有两个预设： 我们讨论的句子只限于陈述句。 我们讨论的陈述句只限于非真即假的陈述句。 如果一个句子是真的，我们也说该句子的真值是真；如果一个句子是假的，我们也说该句子的真值是假。真和假统称为真值（truth-values）。用这个概念来重复上面的第一个预设，那就是：我们讨论的语句都有真值；用它来重复上面第二个预设，那就是：我们讨论的真值只有两个。 学过「逻辑导论」的读者，对本章大部分内容是熟悉的，这里权当复习一次。不过，我们并不假设读者学过「逻辑导论」。本章的内容是自足的，无须预设任何大学课程。当然，没学过「逻辑导论」的读者，可能要比学过「逻辑导论」的读者多花些时间或气力。 3.1 联结词与复合句 3.1.1 联结词 命题联结词（propositional connectives），也作语句联结词（sentential connectives），又称命题算子（propositional operators）或语句算子（sentential operators）。直观地说，它们是带空格（序列）的表达式，使得以陈述句填入这些空格的结果总是陈述句。通常，我们将命题联结词简称为联结词。 例 3.1 (下面的表达式都是联结词) \\(\\underline{\\hspace{5em}}\\)，并且\\(\\underline{\\hspace{5em}}\\)。 （虽然）\\(\\underline{\\hspace{5em}}\\)，但是\\(\\underline{\\hspace{5em}}\\)。 （或者）\\(\\underline{\\hspace{5em}}\\)，或者\\(\\underline{\\hspace{5em}}\\)。 并非\\(\\underline{\\hspace{5em}}\\)。 如果\\(\\underline{\\hspace{5em}}\\)，那么\\(\\underline{\\hspace{5em}}\\)。 只要\\(\\underline{\\hspace{5em}}\\)，（就）\\(\\underline{\\hspace{5em}}\\)。 \\(\\underline{\\hspace{5em}}\\)，除非\\(\\underline{\\hspace{5em}}\\)。 既然\\(\\underline{\\hspace{5em}}\\)，（就）\\(\\underline{\\hspace{5em}}\\)。 因为\\(\\underline{\\hspace{5em}}\\)，所以\\(\\underline{\\hspace{5em}}\\)。 之所以\\(\\underline{\\hspace{5em}}\\)，是因为\\(\\underline{\\hspace{5em}}\\)。 可以想像\\(\\underline{\\hspace{5em}}\\)。 张三相信\\(\\underline{\\hspace{5em}}\\)。 李四认为\\(\\underline{\\hspace{5em}}\\)。 王五知道\\(\\underline{\\hspace{5em}}\\)。 政客们喜欢说\\(\\underline{\\hspace{5em}}\\)。 从平民的角度看，\\(\\underline{\\hspace{5em}}\\)。 对每个自然数 \\(n &gt; 0\\)，如果一个联结词有 \\(n\\) 个空格，通常就称它是 \\(n\\) 元联结词。习惯上，当说到联结词时，人们更喜欢只提联结词表达式中的文字（或符号）而省略那些空格。比如，人们会说「并且」是联结词，意思是说「\\(\\underline{\\hspace{2em}}\\)并且\\(\\underline{\\hspace{2em}}\\)」是联结词；人们也会说「如果–那么」是二元联结词，意思是说「如果\\(\\underline{\\hspace{2em}}\\)那么\\(\\underline{\\hspace{2em}}\\)」是二元联结词。 有些读者可能会认为，对联结词的上述简单说法有点怪。比如， 例 3.2 (联结算子) 如果张三和李四是同学，那么\\(\\underline{\\hspace{2em}}\\)。 相信太阳绕着地球转的人认为\\(\\underline{\\hspace{2em}}\\)。 是带空格的表达式，并且以陈述句填入空格的结果总是陈述句。所以按上述说法，它应该是个一元联结词。可是，说这样的表达式是联结词，总觉得有点怪。读者可以用例 3.1 中的联结词造出很复杂的复合句，然后还原若干个空格，从而得到很多与例 3.2 第〇条类似的例子；读者也可以找到例 3.1 中没有的符合关于联结词的上述说法的「怪」例子，如例 3.2 第一条。 如果觉得例 3.2 的例子怪，大概是因为它们都包含陈述句而我们称它们为联结词，但词中又似乎不该有句。当然，常用的和我们将仔细讨论的联结词都是（或都对应于）自然语言中的词或词组，而且「联结词」看上去也应是指有联结功能的词或词组。但是，常用联结词是词或词组这个事实，不应限制我们对联结词的一般情况的讨论，而且我们也可以给联结词取其他名称，比如「联结算子」等（「联结词」的使用只是沿袭惯例）。 其实，我们讨论的联结词不过是陈述句集合上的某种函数（运算）：对每个这样的 \\(n\\) 元函数，一旦给定有序的 \\(n\\) 个陈述句作为其自变量的取值，该函数的值是个唯一的陈述句，亦即由给定陈述句依次填入联结词的空格序列所得到的句子。 说到函数，读者一定熟悉自然数集合上的加法运算 +。我们知道它是二元函数：任给两个自然数 \\(k\\) 和 \\(n\\)，一定有唯一的自然数，它是 \\(k\\) 与 \\(n\\) 和，即 \\(k+n\\)。如果我们把 \\(k\\) 固定，比如说令 \\(k=3\\)，那么 \\(3+n\\) 还是不是自然数集合上的运算呢？当然还是。 再来看例 3.2 联结词的「怪」例子，它们很像 \\(3+n\\) 这样的函数：将二元联结词「如果–那么」的第一个元的值固定为「张三和李四是同学」，其结果就是陈述句集合上的一元函数；同理，将二元联结词「相信\\(\\underline{\\hspace{2em}}\\)的人认为\\(\\underline{\\hspace{2em}}\\)。」中的第一个元的值固定为「太阳绕着地球转」，其结果也是陈述句集合上的一元函数。 3.1.2 复合句和简单句 直观地说，复合句（compound sentence）是其中用到联结词的陈述句。不是复合句的陈述句叫做简单句（simple sentence）。 读者应注意用（use）与提（mention）的区别。用了联结词的语句是复合句，仅仅提到而没用到联结词的语句不是复合句。这也就是为什么我们没有说复合句是包含联结词或有联结词出现的陈述句，而说复合句是其中用到联结词的陈述句。比如 例 3.3 (联结算子) 张三喜欢用『但是』，但是从来不在该用的地方用。 这句话第二个「但是」是被用作联结词的，第一个「但是」只是被提到，没有被用作联结词。所以，「张三喜欢用『但是』」不是复合句——虽然其中有联结词「但是」，但它只是被提到而没有被用到。「用」和「提」的区别是语言哲学中讨论的问题。很多人习惯用引号表示「提」，但这种方法也不是完全没有缺陷的。我们这里大体上遵循这个习惯。当然，可以被提的不限于联结词。 说得具体一些，复合句是用联结词联结某些句子而形成的句子。由此可知，复合句中的某些部分本身也会是陈述句。例如： 例 3.4 (下面的句子都是复合句) 如果王五是赵六的表哥，那么王五比赵六年长。 虽然王五是赵六的表哥，但赵六比王五高。 王五不是赵六的表哥。（并非王五是赵六的表哥。） 有可能王五是赵六的表哥。 王五不相信赵六是他的表哥。 假如王五只有六岁，他就会认为赵六是他的表哥。 王五认为或者赵六是洪七的表哥或者洪七是赵六的表哥。 作为复合句的部分而出现的陈述句，既可以是简单句，也可以是复合句。下面几个句子中的每一个，都是其后的复合句的部分，但只有第一个才是简单句： 例 3.5 (简单句与复合句的出现) 赵六是洪七的表哥。 王五知道赵六是洪七的表哥。 王五不知道赵六是洪七的表哥。 李四相信王五不知道赵六是洪七的表哥。 张三认为李四相信王五不知道赵六是洪七的表哥。 牛二宣称张三认为李四相信王五不知道赵六是洪七的表哥。 3.1.3 复合句的子句 上面讨论复合句的部分时，我们虽然还没有用「子句」和「真子句」这些词，但已经涉及相应的概念了。既然复合句是用联结词联结某些句子而形成的句子，那么简单地说，那些被联结的句子就是它的真子句；相反，简单句不是用联结词联结某些句子而形成的，从而简单句没有真子句。 一个句子 \\(\\varphi\\) 的子句既是 \\(\\varphi\\) 的一部分又是完整的句子，但既是 \\(\\varphi\\) 的部分又是完整句子的表达式却未必是 \\(\\varphi\\) 的子句。比如复合句 例 3.6 张三想起李四的表哥是王五。 它的子句「李四的表哥是王五」既是例 3.6 的部分又是完整的句子。然而，表达式「张三想起李四」同样既是例 3.6 的部分又是完整的句子，但它不是例 3.6 的子句。例 3.6 是由联结词「张三想起」联结句子「李四的表哥是王五」而形成的，「张三想起李四」并不是用来合成例 3.6 的句子，所以它不应该是例 3.6 的子句。 其实，即使简单句中也可以有某个真部分，它本身能组成一个完整的句子。如简单句 例 3.7 张三在学校里学习很用功。 表达式「张三在学校里学习」既是例 3.7 的部分又是个完整的句子。显然，简单句的部分不能是它的真子句。假如说例 3.7 有子句「张三在学校里学习」，那就像是说「逻辑」这个词中包含了「四」「维」「车」「口」「耳」这些词。 一个词当然可以包含另一个词，组成「合成词」。如「逻辑课程」这个词包含了「逻辑」和「课程」两个词。通常我们可以说「逻辑」的笔划中包含了「四」「维」「车」「口」「耳」这些字的笔划，但这不同于说「逻辑」这个词包含了「四」「维」「车」「口」「耳」这些词。如同「category」这个词，它并没有包含「cat」「a」「at」「ate」等词，尽管拼法（spelling）中有这些字母组合。 通常人们说，复合句是「包含其他句子的句子」，简单句是「不包含其他句子的句子」。从以上讨论可知，这只是大概的说法。易见，按这种说法，「张三在学校里学习」也不是简单句，因为它包含了「张三在学校」这样的句子。有些教科书的确把复合句定义为「包含其他句子的句子」，把简单句定义为「不包含其他句子的句子」，同样也只是大概的说法，不能太当真。自然，假如对「包含」做出足够的限制，关于复合句和简单句的这种说法也许能说通。不过那些书中并没有这种限制。 那么，应该如何把握复合句的子句和真子句呢？设 \\(\\varphi\\) 和 \\(\\psi\\) 都是完整的句子。\\(\\psi\\) 是 \\(\\varphi\\) 的真子句（proper subsentence），如果以空格替换 \\(\\varphi\\) 中的 \\(\\psi\\)，其结果是一个联结词；\\(\\psi\\) 是 \\(\\varphi\\) 的子句（subsentence），如果 \\(\\psi\\) 是 \\(\\varphi\\) 的真子句或者 \\(\\psi=\\varphi\\). 直观地，说 \\(\\psi\\) 是 \\(\\varphi\\) 的真子句，是说 \\(\\psi\\) 是 \\(\\varphi\\) 的一个（真）部分，并且如果将 \\(\\varphi\\) 中的这一部分换成任何其他句子，其结果都还是完整的句子。 根据这个说明，「张三想起李四」不是例 3.6 的真子句。因为「张三和李四是好朋友」是句子，用它替换例 3.6 中的「张三想起李四」，其结果是「张三和李四是好朋友的表哥是王五」，这结果显然不是一个句子。显然，「张三想起李四」也不是例 3.6 的子句。 类似地，将「张三和李四是好朋友」替换例 3.7 中的「张三在学校里学习」，其结果是「张三和李四是好朋友很用功」，这个结果也不是句子。所以「张三在学校里学习」不是例 3.7 的（真）子句。 复合句的（真）子句当然是它的（真）部分。如果觉得真子句从「部分」的角度容易理解，那么请记住：它是该复合句的一部分，并在句中被某联结词联结。 3.1.4 主联结词和直接子句 3.1.4.1 主联结词 借助直观，我们可以明白什么是一个联结词在某复合句中的一个出现。简单地说，它是指该联结词及其在句中所处的一个位置。这个概念显然可以精确化。比如，我们可以用自然数表示句子中的位置。余下的就简单了。一个联结词在同一复合句中可以出现多次。下面例句中都有同一联结词多次岀现的情况： 例 3.8 (联结词的出现) 李四知道有理数和自然数一样多，然而他不知道实数比有理数多。 例 3.9 (联结词的出现) 如果张三听说过无穷集是分大小的，那么他大概也听说过实数比有理数多；但是如果他没听说过无穷集有可数无穷集和不可数无穷集，那么他很可能认为无穷是不可比的。 一个联结词被称为一个复合句的主联结词（major connective, main operator），如果它在该句中的某个出现不是在该句子的任何真子句中，并且它不是由多元联结词经用句子（或联结词）填入其空格得到的联结词。如果我们把一个复合句看作是由简单句经联结词一步步构造起来的，那么，在构造过程的最后一步，我们使用的联结词就是这个复合句的主联结词。比如「李四知道有理数和自然数一样多」「李四不知道实数比有理数多」是例 3.8 复合句的真子句，并且例 3.8 的其他真子句都出现在这两个句中；然而，例 3.8 中的「然而」（唯一一次出现）却没有出现在这些句子中。所以，「然而」是例 3.8 的主联结词。类似地，「但是」是例 3.9 的主联结词。 例 3.10 (联结词的出现) 王五相信，如果老师能给出足够的理由说明实数比有理数多，他也会相信实数比有理数多。 例 3.11 (联结词的出现) 如果实数比自然数多，那么，如果有理数又和自然数一样多，则实数就比有理数多。 例 3.10 中「王五相信」的第一个出现决定了它是该句的主联结词，而第二个出现（「他相信」）与它是主联结词无关。类似地，例 3.11中「如果」的第一个出现决定了它是该句的主联结词，而其第二个出现与它是主联结词无关。 不难看出，对每一个（没有歧义的）复合句，都有唯一的联结词，它在该句中的某个出现使得它成为该句的主联结词。一个句子中的主联结词决定了该句子的基本（命题）结构或基本（命题）形式。 3.1.4.2 直接子句 不仅同一个联结词在一个复合句中可以出现多次，同一个句子也可以作为子句在一个复合句中出现多次。易见，我们可以精确地刻画任何表达式（联结词、子句、词和字等）在一复合句中的出现。 例 3.12 (直接子句) 实数比有理数多，但是张三不相信实数比有理数多。 设 \\(\\psi\\) 为 \\(\\varphi\\) 的真子句。 \\(\\psi\\) 被称为 \\(\\varphi\\) 的一个直接子句（direct subsentence），如果 \\(\\psi\\) 在 \\(\\varphi\\) 中的某个出现不是在 \\(\\varphi\\) 的任何其他真子句中的出现。简单地说，\\(\\varphi\\) 的直接子句就是 \\(\\varphi\\) 的主联结词联结的那些子句。像例 3.12 中的「实数比有理数多」，它是例句的真子句，而且它的第一个（左侧的）出现不在例句的任何其他真子句中，所以它是例 3.12 的一个直接子句。类似地，「张三不相信实数比有理数多」也是例 3.12 的一个直接子句。注意：「实数比有理数多」之所以是例句的直接子句，是因为它的第一个出现；它的第二个出现（右侧的）是在例句的真子句「张三不相信实数比有理数多」中的出现，与它是例句的直接子句无关。 自然，如果一个复合句的直接子句本身也是复合句，它也会有自己的主联结词和自己的直接子句。 例 3.13 (直接子句) 李四相信实数比有理数多，但是张三不相信实数比有理数多。 「李四相信实数比有理数多」「张三不相信实数比有理数多」都是例 3.13 的直接子句，而「实数比有理数多」不再是例 3.13 的直接子句。显然，例 3.13 的上述直接子句都是复合句，它们又都有自己的直接子句：「实数比有理数多」是「李四相信实数比有理数多」的直接子句，而「张三相信实数比有理数多」是「张三不相信实数比有理数多」的直接子句。 复合句的主联结词和直接子句密切相关。一个复合句的主联结词，虽然可能在该复合句中出现多次，但使它成为该句主联结词的那个出现，一定联结了该句的全部直接子句。 3.2 真值、非真值函数联结词 3.2.1 真值函数联结词 对任意的联结词，如果以它为主联结词的复合句的真值完全由该句的直接子句的真值来决定，那么这个联结词就是真值函数联结词（truth-functional connective）。 例 3.14 (真值函数联结词) 并非\\(\\underline{\\hspace{2em}}\\) 如果\\(\\underline{\\hspace{2em}}\\)，那么\\(\\underline{\\hspace{2em}}\\) \\(\\underline{\\hspace{2em}}\\)并且\\(\\underline{\\hspace{2em}}\\) （或者）\\(\\underline{\\hspace{2em}}\\)或者\\(\\underline{\\hspace{2em}}\\) \\(\\underline{\\hspace{2em}}\\)当且仅当\\(\\underline{\\hspace{2em}}\\) it is not the case that \\(\\underline{\\hspace{2em}}\\) if \\(\\underline{\\hspace{2em}}\\), then \\(\\underline{\\hspace{2em}}\\) \\(\\underline{\\hspace{2em}}\\) and \\(\\underline{\\hspace{2em}}\\) (either)\\(\\underline{\\hspace{2em}}\\) or \\(\\underline{\\hspace{2em}}\\) \\(\\underline{\\hspace{2em}}\\) if and onIy if \\(\\underline{\\hspace{2em}}\\) 3.2.2 非真值函数联结词 如果一个联结词不是真值函数联结词，它就是一个非真值函数联结词（non-truth-functional connective）；换言之，如果以它为主联结词的复合句的真值不能完全由该复合句的直接子句的真值来决定，那么它就是一个非真值函数联结词。 例 3.15 (非真值函数联结词) 因为\\(\\underline{\\hspace{2em}}\\)，所以\\(\\underline{\\hspace{2em}}\\)。 之所以\\(\\underline{\\hspace{2em}}\\)，是因为\\(\\underline{\\hspace{2em}}\\)。 可以想像\\(\\underline{\\hspace{2em}}\\)。 张三相信\\(\\underline{\\hspace{2em}}\\)。 李四认为\\(\\underline{\\hspace{2em}}\\)。 王五知道\\(\\underline{\\hspace{2em}}\\)。 政客们喜欢说\\(\\underline{\\hspace{2em}}\\)。 从平民的角度看，\\(\\underline{\\hspace{2em}}\\)。 要说明一个联结词不是真值函数联结词，可以去构造以它为主联结词且满足下列条件的两个复合句： 这两个复合句的真值不同； 这两个复合句中对应的直接子句的真值相同。 例 3.16 「张三相信」不是真值函数联结词： 张三相信地球围绕着太阳转。 张三相信 \\(2+2=4\\)。 假定张三生活在天文学极不普及而简单的加减法已普及的年代或地区。那么，他会相信 \\(2+2=4\\) 而不相信地球围绕着太阳转，也就是说，上述两个复合句一真一假。但是，这两个复合句中对应的直接子句（「地球围绕着太阳转」和「\\(2+2=4\\)」）却具有相同的真值（都是真的）。 为什么这样做就可以说明给定的联结词不是真值函数联结词？要说明给定的联结词不是真值函数联结词，只需要说明它不满足真值函数联结词的定义。在例 2.15 中，两个复合句中对应的直接子句（「地球围绕着太阳转」和「\\(2+2=4\\)」）真值相同，但经「张三相信」联结而分别形成的两个复合句却有不同的真值。这说明两个复合句的直接子句的真值不能完全决定复合句的真值，那么根据真值函数联结词的定义，联结直接子句而构成复合句的主联结词「张三相信」就不是真值函数联结词。 例 3.17 「自从\\(\\underline{\\hspace{2em}}\\)，\\(\\underline{\\hspace{2em}}\\)」不是真值函数联结词： 自从爱因斯坦提出相对论，科学家对宇宙的看法较牛顿时期有很大变化。 自从刘邦打败了项羽，很多中国人喜欢看足球。 凭借直观，我们会认为例 3.17 第一个句子是真的，而第二个句子是假的；但是这两个复合句的所有直接子句都是真的。这就是说，以「自从」为主联结词的复合句的真值不能完全由其直接子句的真值决定。所以，「自从」不是真值函数联结词。 从现在起，除非有特别说明，我们讨论的联结词将只限于真值函数联结词。 3.2.3 常用的真值函数联结词符号 参见上表，我们用下述符号表示本课程讨论的真值函数联结词： \\(\\neg\\)：否定，并非\\(\\underline{\\hspace{2em}}\\) \\(\\wedge\\)：合取 ，并且\\(\\underline{\\hspace{2em}}\\) \\(\\vee\\)：析取， \\(\\underline{\\hspace{2em}}\\)或者\\(\\underline{\\hspace{2em}}\\) \\(\\rightarrow\\)：蕴涵 ，如果\\(\\underline{\\hspace{2em}}\\)那么\\(\\underline{\\hspace{2em}}\\) \\(\\leftrightarrow\\)：等值 ， \\(\\underline{\\hspace{2em}}\\)当且仅当\\(\\underline{\\hspace{2em}}\\) 称 \\(\\neg\\) 为否定号，称主联结词为 \\(\\neg\\) 的复合句为否定句；其余类推。 文科学生可能不太熟悉「当且仅当」这个词，它相当于「等价于」。「\\(\\varphi\\) 当且仅当 \\(\\psi\\) 」的意思是：如果 \\(\\varphi\\) 那么 \\(\\psi\\) 并且如果 \\(\\psi\\) 那么 \\(\\varphi\\)。「\\(\\varphi\\) if and only if \\(\\psi\\)」的意思就是：\\(\\varphi\\) if \\(\\psi\\)，and \\(\\varphi\\) only if \\(\\psi\\)（其中「\\(\\varphi\\) only if \\(\\psi\\)」和「if \\(\\varphi\\) then \\(\\psi\\)」意思相同）。 3.3 符号化 无论读者是否对命题逻辑层次的符号化（symbolization）已有了解，这种符号化毕竟是相当简单的，所以我们只简略地说说。 3.3.1 联结词对应符号 学习符号化的目的之一，就是要通过分析自然语言的句子，把握这些句子的逻辑结构。在这一学习过程中，学生需要通过自己的练习，逐步弄清哪些联结词与哪些联结词的意义相当或相近。下面这个列表当然是不完全的。其实，完全的列表也不是必要的。 \\(\\neg\\) ：并非，并不，不，…… \\(\\wedge\\) ： 并且，但是，可是，然而，且，而，却，不是–而是，…… \\(\\vee\\)：或，或者，或者–或者，要么–要么，不是–就是，（除非），…… \\(\\rightarrow\\)：如果，如果–那么，若–则，只要，一旦，（否则，除非），…… \\(\\leftrightarrow\\)：当且仅当，（等价于），…… 3.3.2 符号化的基本操作过程 相对于真值函数联结词简单的句子，是指那些没有主联结词或没有使用真值函数联结词做主联结词的句子，包括简单句、以非真值函数联结词为主联结词的句子以及由（隐蔽的）量词决定了其基本结构的句子等等。（量词将在谓词逻辑章节中讨论。关于相对于真值函数联结词简单的句子，上述说明只是一种直观的说法，并不是定义。）由于我们现在不讨论非真值函数联结词和量词等的符号化，遇到有这种结构的句子就只能和简单句一样处理。从现在起，除非有特别说明，简单句都指相对于真值函数联结词简单的句子。 以下是命题逻辑符号化的基本步骤： 确认所有简单的句子及其否定。 如果需要，对句子进行复述，即在不改变句子意思的前提下对句子表面结构做小的改动。 用小写的英文字母代换简单句，或者用给出的「辞典」中的字母来代换它们。（用不同的字母代换不同的简单句。如果有同一个简单句的多次出现，确保用相同字母代换相同简单句的所有出现。） 确认所有的联结词，并「由内至外」或「由外至内」逐步把句子符号化。 这里用「辞典」这个词只是为了方便。这里的辞典解释的不是词，而是一个个命题变号。倘若用「原子句典」倒是可以避免误会，但这个词太怪了，只好还是用「辞典」。 例 3.18 如果张三或李四惹怒了王五，那么，赵六不会替王五打抱不平而洪七会高兴地大吃大喝。 解剖层次嵌套，例 3.18 的「辞典」或「原子句典（集）」为： \\(p\\)：张三惹怒了王五。 \\(q\\)：李四惹怒了王五。 \\(r\\)：赵六会替王五打抱不平。 \\(s\\)：洪七会高兴地大吃大喝。 例 3.19 例 3.18 由内至外符号化： 如果 \\(p\\) 或者 \\(q\\)，那么，\\(\\neg r\\) 而 \\(s\\). 如果 \\((p \\lor q)\\)，那么 \\((\\neg r \\land s)\\). \\((p \\lor q) \\rightarrow (\\neg r \\land s)\\). 例 3.18 由外至内符号化： 如果 \\(p\\) 或者 \\(q\\)，那么，\\(\\neg r\\) 而 \\(s\\). （\\(p\\) 或者 \\(q\\)），\\(\\rightarrow\\)（\\(\\neg r\\) 而 \\(s\\)）. \\((p \\lor q) \\rightarrow (\\neg r \\land s)\\) 自然语言由于种种因素在表达上不很「规范」，有些表达式（词的组合）单独拿出来不是句子，但可以被复述成句子。比如例 3.3 中有「从来不在该用的地方用」这一表达式。如果把它从例 3.3 中抽岀来看，并不能说它是完整的句子；但我们知道，它可以被复述成「张三从来不在该用『但是』的地方用『但是』。」例 3.3 经这样复述后可以表达为： 张三喜欢用「但是」，但是张三从来 不在该用「但是」的地方用「但是」。 虽然略显繁琐，但只是修辞问题而不是语法问题，还能忍受。 3.3.3 几种特殊情况 有些复合句的字面结构甚至更难处理。如 例 3.20 张三只有加倍努力学习，才能通过下次考试。 句中的「只有\\(\\underline{\\hspace{2em}}\\)才（有）\\(\\underline{\\hspace{2em}}\\)」表达了某种条件句的结构，应该是个联结词。（「只有–才」在很多情况下是量词，这将在 §13.6（P.234）中讨论。）如果我们在「只有\\(\\underline{\\hspace{2em}}\\)才（有）\\(\\underline{\\hspace{2em}}\\)」的空格中填入陈述句，得到的结果有时很怪，比如：「只有张三加倍努力，才有张三能通过下次考试」。这就需要分析句子的各部分及其关系，甚至需要用文字上与原句相差较大的复述来显示句子的结构。像例 3.20 是说「张三加倍努力学习」是「张三能通过下次考试」的必要条件，所以它可以复述成「如果张三不加倍努力学习，他就不能通过下次考试」。当然，也可以复述成「如果张三能通过下次考试，那么他加倍努力学习了」。 「只有 \\(p\\) 才（有）\\(q\\)」的符号化结果是「\\(\\neg p \\rightarrow \\neg q\\)」或「\\(q \\rightarrow p\\)」。 「只有–才」作联结词时很像英文的 “only if.” “\\(p\\) only if \\(q\\),”only if \\(q\\), \\(p\\)\" 和 “if \\(p\\) then \\(q\\)” 意思相同。 另一个常见而又有点特殊的联结词是「除非」。比如 例 3.21 李四下午不会去听讲座，除非他学过数理逻辑。 例 3.21 可以复述成： 如果李四没有学过数理逻辑，他下午不会去听讲座。（\\(\\neg q \\rightarrow \\neg p;~~ p \\rightarrow q\\) ） 或者李四下午不会去听讲座，或者他学过数理逻辑。（\\(\\neg p \\lor q\\) ） 所以，「除非」的符号化可以和「或者」一样，也可以和「如果不」一样。这就是说， 「\\(p\\) 除非 \\(q\\)」的符号化结果是「\\(p \\lor q\\)」或「\\(\\neg q \\rightarrow p\\)」。 例 3.21 本质与「今天要军训，除非今天下雨」的结构相同，但它是「\\(\\neg p\\) 除非 \\(q\\)」的结构。所以，不应死记「\\(p\\) 除非 \\(q\\)」的符号化结果，而应理解并掌握「\\(\\underline{\\hspace{1.5em}}\\)除非\\(\\underline{\\hspace{1.5em}}\\)」这种句子结构的复述方式。「除非」大致与英文中的联结词「unless」相仿。 3.3.4 论说的符号化 因为论说由句子组成，所以，只要明白如何将论说中各个句子符号化，那么整个论说的符号化应是水到渠成的事。不过，有一点要注意：对同一个论说中所有句子的符号化，都必须根据同一个「辞典」来进行。 例 3.22 将下列论说符号化： 如果蓷蒂是企鹅，那么蓷蒂是鸟。\\(\\hspace{2em}\\) \\(p \\rightarrow q\\) 蓷蒂不是鸟。\\(\\hspace{2em}\\) \\(\\neg q\\) \\(\\therefore\\) 蓷蒂不是企鹅。\\(\\hspace{2em}\\) \\(\\therefore \\neg p\\) 3.3.5 形式 我们说过一个论说的好坏在于它的形式的好坏，但对论说的形式是什么却说的很少。事实上，要想确切地说出论说的形式甚至命题的形式是什么，并不是一件容易的事。这里我们可以说一点点。 在我们把一个论说符号化之后，虽然使用的符号在符号化过程中被赋予了意义，但我们很容易赋予它们别的意义（联结词和 “\\(\\therefore\\)” 除外），甚至很自然地把例 3.22 的符号化结果读作「如果 \\(p\\) 那么 \\(q\\),…」，而不读作「如果蓷蒂是企鹅那么蓷蒂是鸟，……」。这就是说，我们可以把例 3.22 中的 \\(p\\) 和 \\(q\\) 看作能取不同句子为值的变元，而当我们这样做时，我们就是把例 3.22 右列看作例 3.22 左列的形式。通常，人们把一个论说的符号化结果称作该论说的形式（form），而事实上符号化也常被称作形式化（formalization）。 在把命题或论说的符号化结果看作它们的形式时，我们要注意几点： 虽然此时 \\(p\\) 和 \\(q\\) 等符号是可以取任意句子为值的变元，但 \\(\\neg\\), \\(\\land\\), \\(\\lor\\), \\(\\rightarrow\\), \\(\\leftrightarrow\\) 却不是变元，他们固定地表示否定、合取、析取等联结词。 这里说的形式，不是根据自然语言句子中的字的排列，直接用符号替换组成句子和联结词的「字段」而得到的。这里又有两层意思： 句子的形式不是通过机械的「字段/符号」替换就能得到的。（符号化过程中时常要做的复述已经说明了这一点。） 符号化依赖于某种逻辑分析的理论。 上述第二层意思需要一点解释。我们现在使用的逻辑分析理论是非常简单的，它只有表示简单句的符号和一些表示真值函数联结词的符号，而且所谓简单句是指相对于真值函数联结词简单的句子。基于这样一个简单理论，所谓形式当然是粗线条的。比如，按本章现有理论对下面的句子做符号化， 所有的企鹅都是不会飞的鸟。 张三相信，如果所有的企鹅都是不会飞的鸟，那么他的家乡就有不会飞的鸟。 其结果只是两个表示简单句的符号，但是这些句子的内部结构暗示着某种形式上的不同和联系。在§13.4.1（P.225）等章节中，我们会使用一个更丰富的逻辑分析理论来讨论命题与论说的形式问题。 3.3.6 形式化的波兰学派记法 如果一个形式语言的联结词用的是波兰学派记法（见表 2.0），那么这个语言就不需要括号。波兰学派记法中一元联结词 \\(N\\) 的使用规则和我们的 \\(\\neg\\) 一样，但二元联结词 \\(K, A, C, E\\) 的使用规则不同，它们都位于由它们联结的两个直接子公式的左侧。具体地说，当我们使用波兰学派记法时，公式的形成规则是下面这几条（对比 §2.3.0（P.79）中的形成规则和例子）： 所有的命题变号都是公式； 如果 \\(\\varphi\\) 是公式，那么 \\(N \\varphi\\) 也是公式； 如果 \\(\\varphi\\) 和 \\(\\psi\\) 是公式，那么 \\(K\\varphi\\psi, A\\varphi\\psi, C\\varphi\\psi, E\\varphi\\psi\\) 也是公式； 只有这些是公式。 例 3.23 下面编号的都是公式而无编号的则都不是公式： \\(p_{156}\\) \\(KNp_{75}p_{21}\\) \\(Cp_9Ap_{57}Ep_{23}p_{601}\\) \\(CCCCCp_{28}p_{28}p_{28}p_{28}p_{28}p_{28}\\) \\(Kp_{13}\\) \\(p_{822}Np_{822}\\) \\(p_{69}CNp_{801}\\) \\(Np_{28}Cp_{782}\\) 3.4 命题逻辑的基本语法 3.4.1 形式语言 \\(\\mathscr{L_0}\\) 从这一节开始，我们要使用形式语言这一概念。命题逻辑的形式语言通常由两部分组成：一是「初始符号」（primitive symbols），即无定义的符号；二是由这些符号根据一定的「形成规则」（formation rules）而形成的「公式」（formulas, formulae）。我们引入的第一个形式语言是 \\(\\mathscr{L}_0.\\) 我们称 \\(\\mathscr{L}_0\\) 的初始符号为 \\(\\mathscr{L}_0\\)-符号。\\(\\mathscr{L}_0\\)-符号有三种： 命题变号：\\(p_0\\), \\(p_1\\), \\(p_2, \\cdots\\); 联结词：\\(\\neg\\), \\(\\wedge\\), \\(\\vee\\), \\(\\rightarrow\\), \\(\\leftrightarrow\\)（\\(\\neg\\) 为一元联结词，其余为二元联结词）； 左右括号：(\\(\\hspace{2em}\\)). \\(\\mathscr{L}_0\\)-符号中，联结词 \\(\\neg\\), \\(\\wedge\\), \\(\\vee\\), \\(\\rightarrow\\), \\(\\leftrightarrow\\) 称为逻辑符号，命题变号称为非逻辑符号。命题变号也叫「命题变项」或「命题变元」。左右括号对于一个形式语言来说并不是必要的，但为了方便，我们仍把它们作为形式语言的初始符号，并称它们为「辅助符号」。 我们称 \\(\\mathscr{L}_0\\) 的公式为 \\(\\mathscr{L}_0\\)-公式，它们是由 \\(\\mathscr{L}_0\\)-符号根据下列形成规则形成的符号串： \\(\\mathscr{L}_0\\) 的所有命题变号都是 \\(\\mathscr{L}_0\\)-公式； 如果 \\(\\varphi\\) 是 \\(\\mathscr{L}_0\\)-公式，则 \\(\\neg \\varphi\\) 也是 \\(\\mathscr{L}_0\\)-公式； 若 \\(\\varphi\\) 和 \\(\\psi\\) 是 \\(\\mathscr{L}_0\\)-公式，则 \\((\\varphi \\land \\psi), (\\varphi \\lor \\psi), (\\varphi \\rightarrow \\psi), (\\varphi \\rightarrow \\psi)\\) 都是 \\(\\mathscr{L}_0\\)-公式； 只有这些是 \\(\\mathscr{L}_0\\)-公式。 很多作者在我们用「公式」的地方用「合式公式」这个词（“well-formed formula” 或 “wff”）。这里用「公式」，是因为这里没有不合式的公式。 根据上述定义，下列 \\(\\mathscr{L}_0\\)-符号串都是 \\(\\mathscr{L}_0\\)-公式： \\(p_{156}\\) \\((\\neg p_{75} \\land p_{21})\\) \\((p_9 \\rightarrow (p_{57} \\lor (p_{23} \\rightarrow p_{601})))\\) \\((((((p_{28} \\rightarrow p_{28})\\rightarrow p_{28})\\rightarrow p_{28})\\rightarrow p_{28})\\rightarrow p_{28})\\) 下列 \\(\\mathscr{L}_0\\)-符号串都不是 \\(\\mathscr{L}_0\\)-公式： \\(p_{13} \\land\\) \\(p_{822} \\neg p_{822}\\) \\((p_{69} \\rightarrow \\neg p_{801}))\\) \\((p_{28} \\neg \\rightarrow p_{782}))\\) 为了讨论的方便，我们用 \\(p, q, r, s\\) 等表示 \\(p_{0}, p_{1}, p_{2},...\\) 中的前几个（如果不对它们做限制），必要时可再用 \\(^\\prime\\), \\(^{\\prime\\prime}\\) 或上下标来区分不同的命题变号。我们将用 \\(\\varphi, \\psi, \\chi, \\theta, \\lambda\\) 等小写的希腊字母（加 \\(^\\prime\\), \\(^{\\prime\\prime}\\) 或上下标）表示 \\(\\mathscr{L}_0\\)-公式，用 \\(\\Gamma, \\Delta\\) 等大写的希腊字母表示 \\(\\mathscr{L}_0\\)-公式集合。 3.4.2 对象语言和元语言 初学者要学会分清「对象语言」和「元语言」。所谓对象语言（object Ianguage），是作为我们讨论对象的语言；所谓元语言（metalanguage），是我们讨论中使用的语言。比如，在一本英文教科书里，英文是对象语言。如果这本书是初级教科书，那么很可能中文就是元语言；而如果这本书是高级教科书，那么它的元语言很可能也是英文。在本书中，元语言是中文加上一些符号（偶尔还有一点英文），对象语言到目前为止就是 \\(\\mathscr{L}_0\\)。 注意：我们可以用 \\(\\varphi\\)（或别的什么符号）表示对象语言里的某个公式（\\(\\mathscr{L}_0\\)-公式），但那并不是说希腊字母 “\\(\\varphi\\)” 是对象语言里的符号或公式。“\\(\\varphi\\)” 是我们元语言里的符号，我们只是用它来表示某个 \\(\\mathscr{L}_0\\)-公式。关于对象语言和元语言，现在只谈这些，进一步的讨论还会在§3.0.0（P.99）中出现。 这一章涉及的对象语言只有 \\(\\mathscr{L}_0\\)，所以在提到 \\(\\mathscr{L}_0\\)-公式或 \\(\\mathscr{L}_0\\)-公式集时，我们将尽可能省略前缀 “\\(\\mathscr{L}_0\\)”，只说公式或公式集。 3.4.3 子公式和主联结词 公式的子公式（subformula）是出现在该公式中的公式（包括它自己）。如果 \\(\\psi\\) 是 \\(\\varphi\\) 的子公式，且 \\(\\psi \\neq \\varphi\\)，那么 \\(\\psi\\) 是 \\(\\varphi\\) 的真子公式（proper subformuIa）。一个公式的主联结词是该公式构造过程最后一步中使用的那个联结词，而它的直接子公式就是在这一步中主联结词联结的公式。严格地说， 对每个命题变号 \\(p\\)，\\(p\\) 是 \\(p\\) 的子公式； \\(\\varphi\\) 的所有子公式和 \\(\\neg \\varphi\\) 都是 \\(\\neg \\varphi\\) 的子公式，\\(\\varphi\\) 是 \\(\\neg \\varphi\\) 的直接子公式，且 \\(\\neg\\) 是 \\(\\neg \\varphi\\) 的主联结词； \\(\\varphi\\) 和 \\(\\psi\\) 的所有子公式和 \\((\\varphi \\lor \\psi)\\) 都是 \\((\\varphi \\lor \\psi)\\) 的子公式，\\(\\varphi\\) 和 \\(\\psi\\) 是 \\((\\varphi \\lor \\psi)\\) 的直接子公式，且 \\(\\vee\\) 是 \\((\\varphi \\lor \\psi)\\) 的主联结词； \\(\\varphi\\) 和 \\(\\psi\\) 的所有子公式和 \\((\\varphi \\land \\psi)\\) 都是 \\((\\varphi \\land \\psi)\\) 的子公式，\\(\\varphi\\) 和 \\(\\psi\\) 是 \\((\\varphi \\land \\psi)\\) 的直接子公式，且 \\(\\wedge\\) 是 \\((\\varphi \\land \\psi)\\) 的主联结词； \\(\\varphi\\) 和 \\(\\psi\\) 的所有子公式和 \\((\\varphi \\rightarrow \\psi)\\) 都是 \\((\\varphi \\rightarrow \\psi)\\) 的子公式，\\(\\varphi\\) 和 \\(\\psi\\) 是 \\((\\varphi \\rightarrow \\psi)\\) 的直接子公式，且 \\(\\rightarrow\\) 是 \\((\\varphi \\rightarrow \\psi)\\) 的主联结词； \\(\\varphi\\) 和 \\(\\psi\\) 的所有子公式和 \\((\\varphi \\leftrightarrow \\psi)\\) 都是 \\((\\varphi \\leftrightarrow \\psi)\\) 的子公式，\\(\\varphi\\) 和 \\(\\psi\\) 是 \\((\\varphi \\leftrightarrow \\psi)\\) 的直接子公式，且 \\(\\leftrightarrow\\) 是 \\((\\varphi \\leftrightarrow \\psi)\\) 的主联结词； 以相同主联结词为公式分类，我们有公式的下列类名称： 命题变号称为 \\(\\mathscr{L}_0\\)-原子公式（atomic formula）； 形如 \\(\\neg \\varphi\\) 的公式（即以 \\(\\neg\\) 为主联结词的公式）称为否定式（negation），俗称「\\(\\varphi\\) 的否定」； 形如 \\((\\varphi \\lor \\psi)\\) 的公式称为析取式（disjunction），俗称「\\(\\varphi\\) 和 \\(\\psi\\) 的析取」，\\(\\varphi\\) 和 \\(\\psi\\) 称为它的析取支（disjuncts）； 形如 \\((\\varphi \\land \\psi)\\) 的公式称为合取式（conjunction），俗称「\\(\\varphi\\) 和 \\(\\psi\\) 的合取」。\\(\\varphi\\) 和 \\(\\psi\\) 称为它的合取支（conjuncts）； 形如 \\((\\varphi \\rightarrow \\psi)\\) 的公式称为蕴涵式（implication）或条件句（conditional），\\(\\varphi\\) 称为它的前件（antecedent），\\(\\psi\\) 称为它的后件（consequent）； 形如 \\((\\varphi \\leftrightarrow \\psi)\\) 的公式称为等值式（equivalence），亦称双（向）蕴涵式（bi-implication）或双（向）条件句（biconditional）。 3.4.4 括号的省略 为书写和阅读的方便，我们根据以下两条规则省略公式中的一些括号： 最外层的括号可以省略； 假定 \\(\\vee\\) 和 \\(\\wedge\\) 的联结比 \\(\\rightarrow\\) 和 \\(\\leftrightarrow\\) 优先，就像在做算术题时 \\(\\times\\) 和 \\(\\div\\) 比 \\(+\\) 和 \\(-\\) 优先（或者说 \\(\\rightarrow\\) 和 \\(\\leftrightarrow\\) 在做公式主联结词方面比 \\(\\vee\\) 和 \\(\\wedge\\) 优先）。 例 3.24 下列符号串不是省略了括号的公式： \\(p \\land q \\lor r\\) \\(p \\rightarrow q \\rightarrow r\\) \\(p \\rightarrow q \\lor r \\rightarrow s\\) \\(p \\rightarrow (q \\lor r) \\rightarrow s\\) \\(p \\rightarrow q \\rightarrow r \\lor s\\) 例 3.25 以下编号者为省略括号的公式，未编号者为对应未省略括号的公式： \\((p \\rightarrow q) \\land r\\) \\(p \\land q \\rightarrow \\neg r \\land s\\) \\(p \\lor q \\rightarrow \\neg(p \\land q)\\) \\((p \\lor q) \\land r \\rightarrow s\\) \\(((p \\rightarrow q) \\rightarrow r) \\rightarrow s\\) \\(((p \\rightarrow q) \\land r)\\) \\(((p \\land q) \\rightarrow (\\neg r \\land s))\\) \\(((p \\lor q) \\rightarrow \\neg(p \\land q))\\) \\((((p \\lor q) \\land r) \\rightarrow s)\\) \\((((p \\rightarrow q) \\rightarrow r) \\rightarrow s)\\) 注意：一个符号串是否为省略了括号的公式，取决于特定作者或特定书籍对省略括号的约定。根据本书的约定，例 3.25 中（编号者）的符号串是公式而例 3.24 中的不是。但若按照其他约定，例 3.25 中的有可能不是公式而例 3.24 中的倒有可能是公式。比如，有的作者喜欢「右结合原则」，即同一种联结词连续出现时，右边的联结词比左边的优先。在这一约定下，例 3.24 中的第二个符号串就成了公式 \\((p \\rightarrow (q \\rightarrow r))\\) 的省略括号的写法。如果在我们上述约定的基础上再加「右结合原则」，那么例 3.24 中的第三个符号串也就成了公式 \\((p \\rightarrow ((q \\lor r) \\rightarrow s))\\) 省略括号的写法。当然，还有很多不同的约定方法，这里就不一一介绍了。 3.4.5 语法和语义 语法（syntax）和语义（semantics）的区别对学习当代逻辑至关重要。语法理论有时叫语形理论，它涉及符号组合和公式的结构，以及公式在结构或形式方面的各种关系，唯独不涉及这些符号和公式的意义。讨论符号和公式意义的理论称为语义理论。本节的上述内容和以后将讨论的公式的变换、公式序列（依规则）的生成等，都属于语法理论。 有时人们谈论有意义的符号和无意义的符号。在逻辑学家们的笔下，「符号」多数时候是指没有被赋予意义的东西。比如，前面讨论的符号本身都是没有意义的。一旦赋予这些符号意义，我们就进入了语义理论。针对符号和公式的意义的讨论，包括公式的真假，统称为语义讨论。 为理解语法和语义的区别，我们来看下面几个表达式： \\(1+1=2\\) One pIus one is (equal to) two. 一加一等于二。 这些是不同语言中的句子，而不同语言有不同的符号和形成规则。（自然语言很难说有严格的形成规则，但大体上是有规则的。）所以，这些句子从语法上说是不同的。但是，根据通常的解释，它们的意思是相同的，或者说在语义上是相同的。再来看同一个语言中的例子： 张三打了李四一拳。 李四被张三打了一拳。 显然这两个句子的意思相同，即在语义方面相同。但是，第一句有八个字，而第二句却有九个字；第一句的前两个字是「张三」，而第二句的前两个字却是「李四」。所以，这两个句子在语法方面是不同的。 3.5 基本真值表和真值的计算 在这一节里，我们介绍真值表和公式真值的计算方法，然后在下一节用这种方法来讨论命题逻辑的一些基本语义概念。 3.5.1 联结词的语义解释 命题逻辑不涉及命题中不能由联结词表现出来的内部结构，所以在某种意义上说，命题逻辑是研究联结词的。 从语法角度看，联结词自然是「公式函数」，即从公式集合到公式集合的函数。这就是说，对每个联结词，每当给出公式作为「输入」，这个联结词确定了唯一的公式作为「输出」，即以该联结词为主联结词并以给定公式为直接子公式的公式。那么，诸如「并非」「并且」这样的联结词的意义（meaning）又是什么呢？我们说过，这些联结词是真值函数联结词。什么是真值函数（truth function）？真值函数是从真值集到真值集的函数。我们用 T 或 1 表示真，用 F 或 0 表示假。根据我们对真值的「二值」预设，真值函数就是从 \\(\\lbrace 1, 0\\rbrace\\) 到 \\(\\lbrace 1, 0\\rbrace\\) 的函数。真值函数联结词之所以叫「真值函数联结词」，是因为从语义角度看，它们是真值函数。换句话说，真值函数联结词就是以真值函数为其解释的联结词。关于这一点，我们在 §3.3.0（P.115）和 §3.5（P.122）中还会讨论。 现在，我们先用比较直观的真值表（truth table）来讨论真值函数联结词。表 3.1 是关于五个真值函数联结词的基本真值表。 Table: (#tab:truthtable) 基本真值表 \\[ \\begin{array}{cc|ccccc} \\hline \\hline \\varphi &amp; \\psi &amp; \\varphi \\wedge \\psi &amp; \\varphi \\vee \\psi &amp; \\varphi \\rightarrow \\psi &amp; \\varphi \\leftrightarrow \\psi &amp; \\neg \\varphi \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \\\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; \\\\ \\hline \\hline \\end{array} \\] 根据表 3.1，无论 \\(\\varphi\\) 是怎样的公式，如果 \\(\\varphi\\) 是真的， \\(\\neg \\varphi\\) 就是假的；如果 \\(\\varphi\\) 是假的，\\(\\neg \\varphi\\) 就是真的。这就是说，\\(\\neg \\varphi\\) 的真值完全取决于 \\(\\varphi\\) 的真值。类似地，无论 \\(\\varphi\\) 和 \\(\\psi\\) 是什么公式，如果 \\(\\varphi\\) 和 \\(\\psi\\) 都是真的，\\(\\varphi \\rightarrow \\psi\\) 就是真的；如果 \\(\\varphi\\) 是真的而 \\(\\psi\\) 是假的，\\(\\varphi \\rightarrow \\psi\\) 是假的；……用 \\(\\land, \\lor, \\leftrightarrow\\) 做主联结词的情况依此类推。 因为每个公式 \\(\\varphi\\) 都是由命题变号经五个真值函数联结词构造出来的，所以，一旦 \\(\\varphi\\) 中命题变号的真值确定了，\\(\\varphi\\) 的真值就可以按照上述基本真值表一步步计算出来。 在计算公式的真值前，先把基本真值表 3.1 记住，就像做乘法运算前要先记住乘法口诀那样。记真值表时要记住这些组合情况与右侧真值的对应，仅仅简单地记住「合取：1, 0, 0, 0；析取：1, 1, 1, 0；…」并不是好办法，甚至可能导致误解。尝试记住下列命题： 一个否定式是真的，当且仅当它否定的公式是假的； 一个合取式是真的，当且仅当它的合取支都是真的； 一个析取式是真的，当且仅当它的析取支中至少有一个是真的； 一个蕴涵式是真的，当且仅当它的前件是假的或后件是真的； 一个等值式是真的，当且仅当它的两个直接子公式的真值相同。 由此，可以对应地得岀命题「一个否定式是假的，当且仅当它否定的公式是真的」等等。读者应试着把余下的几个对应命题找出来，见练习 2.3。 3.5.2 公式真值的计算 公式真值的计算方法分两类，一是用子公式的给定真值来计算公式的真值，二是用公式的真值表计算公式在各种可能情况下的真值。 3.5.2.1 以子公式的给定真值计算 我们先看如何用命题变号的给定真值来计算公式的真值。 例 3.26 设 \\(p\\) 的真值为 1，\\(q\\) 的真值为 0 并且 \\(r\\) 的真值为 1. 计算公式 \\((p \\rightarrow \\neg q \\land r) \\rightarrow (p \\lor r)\\) 的真值。 Solution: 依据基本真值表 3.1 层层运算即可。先根据假设把命题变号的真值写在相应的命题变号下方，然后逐层推得结果。 \\[ \\begin{array}{c|ccc|c|c} \\text{步骤} &amp; (p &amp; \\rightarrow &amp; \\neg q \\land r) &amp; \\rightarrow &amp; (p \\lor r)\\\\ \\hline 0 &amp; ~1 &amp; &amp; ~~0~~~~1 &amp; &amp;1~~~~1 \\\\ 1 &amp; &amp; &amp; 1~~~~~~~~~~ &amp; &amp; ~1 \\\\ 2 &amp; &amp; &amp; ~1 &amp; &amp; \\\\ 3 &amp; &amp; 1 &amp; &amp; &amp; \\\\ 4 &amp; &amp; &amp; &amp; 1 &amp; \\end{array} \\] 一个公式的真值的计算未必要从它的原子子公式开始——计算可以从它的其他子公式开始。比如， 例 3.27 设 \\(\\varphi\\) 的真值为 1，\\(\\psi\\) 的真值为 0 并且 \\(\\chi\\) 的真值为 0. 计算公式 \\((\\varphi \\rightarrow \\neg \\psi \\land \\chi) \\rightarrow (\\varphi \\lor \\chi)\\) 的真值。 Solution: 与例 3.26 解法相同，易知其真值为 1. 例 3.26, 3.27 使我们明白：要计算出一个公式的真值，我们只需知道它的所有直接子公式的真值，而不一定要知道它的所有原子子公式的真值。其实，要计算出一个公式的真值，也未必要事先知道它的所有直接子公式的真值。 例 3.28 设 \\(\\varphi\\) 的真值为 1 且 \\(\\psi\\) 的真值为 0. 那么对任意公式 \\(\\chi\\)，根据（真值）表 2.1，以下结论是显然的： \\(\\varphi \\lor \\chi\\) 的真值为 1， \\(\\chi \\rightarrow \\varphi\\) 的真值为 1， \\(\\chi \\land \\psi\\) 的真值为 0， \\(\\psi \\rightarrow \\chi\\) 的真值为 1. 例 3.29 设 \\(\\varphi\\) 的真值为 1 且 \\(\\psi\\) 的真值为 0. 计算公式 \\(\\varphi \\rightarrow(\\varphi \\rightarrow(\\varphi \\rightarrow(\\varphi \\vee(\\chi \\wedge \\xi) \\rightarrow \\psi)))\\) 的真值。 Solution: 与前几例并无区别。易知其真值为 0. \\[ \\underbrace{\\underset{1}{\\varphi} \\mathpunct{\\smash{\\underset{\\mathbf{\\underset{0}{\\big\\uparrow}}}{\\rightarrow}}} \\underbrace{(\\underset{1}{\\varphi} \\mathpunct{\\smash{\\underset{\\mathbf{\\underset{0}{\\big\\uparrow}}}{\\rightarrow}}} \\underbrace{(\\underset{1}{\\varphi} \\mathpunct{\\smash{\\underset{\\mathbf{\\underset{0}{\\big\\uparrow}}}{\\rightarrow}}} \\underbrace{\\underbrace{(\\underset{1}{\\varphi} \\mathpunct{\\smash{\\underset{\\mathbf{\\underset{1}{\\big\\uparrow}}}{\\lor}}}\\underbrace{(\\underset{?}{\\chi}\\mathpunct{\\smash{\\underset{\\mathbf{\\underset{?}{\\uparrow}}}{\\land}}} \\underset{?}{\\xi})}_{?}}_{1} \\mathpunct{\\smash{\\underset{\\mathbf{\\underset{0}{\\big\\uparrow}}}{\\rightarrow}}} \\underset{0}{\\psi})}_{0})}_{0})}_{0}}_{0} \\] 例 3.30 设 \\(\\psi\\) 真值为 0. 计算公式 \\(\\psi_{0} \\rightarrow\\left(\\psi_{1} \\rightarrow\\left(\\psi_{2} \\rightarrow(\\chi \\wedge \\psi \\rightarrow \\xi)\\right)\\right)\\) 的真值。 Solution: 原理与方法与前几例并无区别。易知 \\(\\chi \\wedge \\psi\\) 真值为 0，则 \\(\\chi \\wedge \\psi \\rightarrow \\xi\\) 真值为 1，那么无论前件真值为 1 或 0，公式真值始终为 1. 3.5.2.2 以公式的真值表计算 一旦会用子公式的真值来计算公式的真值，构造公式的真值表是件很简单的事——它不过是列出给定公式中的全部命题变号的所有「可能取值组合」，并根据它们计算和列出该公式在每一种可能情况下的真值。 对给定公式中的每个命题变号指定一个固定的真值，这样指定的结果称为这些命题变号的一个「可能取值组合」。若干命题变号的一个可能取值组合是从这些命题变号到 \\(\\lbrace 1,0\\rbrace\\) 的一个函数。因为每个命题变号的真值或为 1 或为 0，则 \\(n\\) 个命题变号的可能取值组合为 \\(2^n\\) 个。一个公式的真值表一定要包含该公式中命题变号的所有可能取值组合。在构造公式 \\(\\varphi\\) 的真值表时，按惯例先在表的左侧排出 \\(\\varphi\\) 中出现的所有命题变号，然后排列出它们的全部可能取值组合（的值），再把 \\(\\varphi\\) 的各个子公式的真值从简单到复杂一步步计算出来。 公式的真值表通常有两种画法，第一种是在表的上方排出该公式的所有子公式，通过计算将这些子公式的真值列在它们的下方。 例 3.31 计算公式 \\(p \\wedge \\neg q \\rightarrow \\neg p \\vee q\\) 在各种情况下的真值。 Solution: \\[ \\begin{array}{cc||l|l|l|c||c} \\hline\\hline p &amp; q &amp; \\neg q &amp; p \\wedge \\neg q &amp; \\neg p &amp; \\neg p \\vee q &amp; p \\wedge \\neg q \\rightarrow \\neg p \\vee q\\\\ \\hline 1 &amp; 1 &amp; 0 &amp; ~~~0 &amp; 0 &amp; ~~~1 &amp; \\mathbf{1} \\\\[.7ex] 1 &amp; 0 &amp; 1 &amp; ~~~1 &amp; 0 &amp; ~~~0 &amp; \\mathbf{0} \\\\[.7ex] 0 &amp; 1 &amp; 0 &amp; ~~~0 &amp; 1 &amp; ~~~1 &amp; \\mathbf{1} \\\\[.7ex] 0 &amp; 0 &amp; 1 &amp; ~~~0 &amp; 1 &amp; ~~~1 &amp; \\mathbf{1} \\\\ \\hline\\hline \\end{array} \\] 公式的真值表的第二种画法是在表上方只列出该公式（及其原子子公式），而把它的（非原子）子公式的值列在该子公式的主联结词之下。 例 3.32 计算公式 \\((p \\vee q) \\wedge \\neg r \\rightarrow p \\wedge (\\neg q \\vee r)\\) 在各种情况下的真值。 Solution: \\[ \\begin{array}{ccc|ccl|c|ccccccc} \\hline\\hline p &amp; q &amp; r &amp; (p \\vee q) &amp; \\wedge &amp; \\neg r &amp; \\rightarrow &amp; p &amp; \\wedge &amp; (\\neg q &amp; \\vee &amp; r) \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\mathbf{1} &amp; &amp; 1 &amp; 0 &amp; 1 &amp; \\\\[.7ex] 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; \\mathbf{0} &amp; &amp; 0 &amp; 0 &amp; 0 &amp; \\\\[.7ex] 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\mathbf{1} &amp; &amp; 1 &amp; 1 &amp; 1 &amp; \\\\[.7ex] 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; \\mathbf{1} &amp; &amp; 1 &amp; 1 &amp; 1 &amp; \\\\[.7ex] 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\mathbf{1} &amp; &amp; 0 &amp; 0 &amp; 1 &amp; \\\\[.7ex] 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; \\mathbf{0} &amp; &amp; 0 &amp; 0 &amp; 0 &amp; \\\\[.7ex] 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\mathbf{1} &amp; &amp; 0 &amp; 1 &amp; 1 &amp; \\\\[.7ex] 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; \\mathbf{1} &amp; &amp; 0 &amp; 1 &amp; 1 &amp; \\\\ \\hline\\hline \\end{array} \\] 例 3.32 有意将公式中符号间的距离加大，以使读者清楚地看出：每个子公式的真值都列在该子公式的主联结词的下方。特别地，例 3.32 中「\\(\\rightarrow\\)」之下那列真值，是公式 \\((p \\vee q) \\wedge \\neg r \\rightarrow p \\wedge (\\neg q \\vee r)\\) 在各种情况下的真值。我们将一贯地将子公式的真值列于该子公式的主联结词之下，但不再加大公式中符号间的距离。从现在起，将只釆用公式真值表的第二种画法。 我们约定：凡谈到真值表中的真值时，我们用「行」表示该表中从左到右的真值序列，用「列」表示该表中从上到下的真值序列。 3.6 若干基本语义概念的真值表刻画 这一节里，我们用真值表方法介绍和讨论一些基本语义概念：重言蕴涵（重言后承）、重言等值、可满足性、重言式、矛盾式和或然式。我们对这些概念所做的真值表刻画，在某些教科书中就称为这些概念的定义。之所以我们不称这些刻画为定义，是因为这里的讨论不够严格。在 §3.1（P.101）中，我们要用真值指派给出这些概念的严格定义。 为了比较和讨论不同公式的真值情况，我们可以把不同的公式放到同一个真值表中。这样的真值表称为联合真值表。在公式 \\(\\varphi_0,...\\varphi_n\\) 的联合真值表中，我们要列出这些公式的所有原子子公式和它们的可能取值组合（的值），并且根据这些组合计算 \\(\\varphi_0,...\\varphi_n\\) 各自的真值。 3.6.1 论说形式的有效性 一个论说形式的前提和结论的联合真值表称为该论说形式的真值表。有了论说形式的真值表，引言中讨论的论说形式的好坏可以有更清楚的定义（下面的「有效」对应于「好」，「无效」对应于「坏」；参见§0.0（P.2）和§2.2（P.76）中的有关形式好坏的讨论。） 在一个论说形式的真值表中，前提都真而结论假的每一行，都称为该论说形式的反例。 对任何一个论说形式，如果其真值表的任何一行都不是该论说形式的反例，那么这个论说形式是有效的（valid）；否则，这个论说形式是无效的（invalid）。 例 3.33 用真值表检验论说形式 \\(p \\rightarrow q, \\neg q ~/\\therefore \\neg p\\) 的有效性。 Solution: 这个论说形式的真值表中结论 \\(\\neg p\\) 为假的只有第一行和第二行，但这两行中，前提里也总有一个是假的。所以，上述论说形式没有反例，是有效的论说形式。此例为最基本的蕴涵式否定后件推理，应用归谬赋值或自然演绎法同理可证。（对比例 3.37） \\[ \\begin{array}{cc|cl|l} p &amp; q &amp; p \\rightarrow q, &amp; \\neg q &amp; \\neg p \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 \\end{array} \\] 例 3.34 用真值表检验论说形式 \\(p \\rightarrow (q \\rightarrow r), p \\rightarrow q ~/\\therefore p \\rightarrow r\\) 的有效性。 Solution: 根据下表，前提都真的每一行里结论也都真；所以，上述论说形式是有效的。 \\[ \\begin{array}{ccc|lc|c} p &amp; q &amp; r &amp; p \\rightarrow(q \\rightarrow r), &amp; p \\rightarrow q &amp; p \\rightarrow r \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; ~~~~1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; ~~~~0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; ~~~~1 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; ~~~~1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 1 &amp; ~~~~1 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 &amp; ~~~~1 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; ~~~~1 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; ~~~~1 &amp; 1 &amp; 1 \\end{array} \\] 例 3.35 用真值表检验论说形式 \\(p \\rightarrow q \\lor \\neg r, r \\land q \\rightarrow p ~/\\therefore r \\rightarrow \\neg q\\) 的有效性。 Solution: 这个论说形式真值表的第一行中，论说的前提都真而结论假，是该论说形式的反例；所以该论说形式是无效的。 \\[ \\begin{array}{ccc|lr|c} p &amp; q &amp; r &amp; p \\rightarrow q \\vee \\neg r, &amp; r \\wedge q \\rightarrow p &amp; r \\rightarrow \\neg q \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; ~~~~1 &amp; 1~~~~~ &amp; 0~~~ \\\\ 1 &amp; 1 &amp; 0 &amp; ~~~~1 &amp; 1~~~~~ &amp; 1~~~ \\\\ 1 &amp; 0 &amp; 1 &amp; ~~~~0 &amp; 1~~~~~ &amp; 1~~~ \\\\ 1 &amp; 0 &amp; 0 &amp; ~~~~1 &amp; 1~~~~~ &amp; 1~~~ \\\\ 0 &amp; 1 &amp; 1 &amp; ~~~~1 &amp; 0~~~~~ &amp; 0~~~ \\\\ 0 &amp; 1 &amp; 0 &amp; ~~~~1 &amp; 1~~~~~ &amp; 1~~~ \\\\ 0 &amp; 0 &amp; 1 &amp; ~~~~1 &amp; 1~~~~~ &amp; 1~~~ \\\\ 0 &amp; 0 &amp; 0 &amp; ~~~~1 &amp; 1~~~~~ &amp; 1~~~ \\end{array} \\] 读者在这里可能会有这样一个问题：我们在引言里曾说过，论说形式的好坏涉及该形式的所有特例，其数量显然无上界；而这里说的论说形式的有效性却只涉及 \\(2^n\\) 个可能的取值组合（假设其中只出现 \\(n\\) 个命题变号）。这两种说法如何能是「一回事」呢？ 可以这样来理解这个问题：假定一个论说形式中出现 \\(n\\) 个命题变号，进而该论说形式的真值表有 \\(2^n\\) 行。这个论说形式的每个特例，都可以看作是以具体命题替换那些命题变号而得到的。替换的都是具体命题，因而它们的真值都是确定的，对应于 \\(2^n\\) 个可能取值组合中的一个。（\\({\\prod_{i=1}^{n}} (C_{2}^{1})_i = 2^{n}.\\)）这样，我们就把该论说形式的所有特例分成了 \\(2^n\\) 组，而每个特例的前提和结论的真值情况，都在该论说形式真值表的某一行中。当讨论这个真值表的任一行时，假如沿用引言中的术语，那么我们就会说，讨论涉及该论说形式的一组特例而非一个特例；当我们认定真值表的某一行是给定论说形式的反例时，假如沿用引言中的术语，那么我们就会说该论说形式有一组反例。 3.6.2 重言蕴涵 设 \\(\\varphi_0,...,\\varphi_n\\) 和 \\(\\psi\\) 为任意公式。\\(\\lbrace \\varphi_0,...,\\varphi_n \\rbrace\\) 重言蕴涵（tautologically implies） \\(\\psi\\) 当且仅当在 \\(\\varphi_0,...,\\varphi_n\\) 与 \\(\\psi\\) 的联合真值表中，没有一行是 \\(\\varphi_0,...,\\varphi_n\\) 都真而 \\(\\psi\\) 假，亦即在它们的联合真值表的每一行中，如果 \\(\\varphi_0,...,\\varphi_n\\) 的真值都是 1，那么 \\(\\psi\\) 的真值也一定是 1. \\(\\psi\\) 是\\(\\lbrace \\varphi_0,...,\\varphi_n \\rbrace\\) 的重言后承（tautological consequence）当且仅当 \\(\\varphi_0,...,\\varphi_n\\) 重言蕴涵 \\(\\psi\\).（\\(\\lbrace \\varphi_0,...,\\varphi_n \\rbrace\\) tautologically implies \\(\\psi\\)） 易见，根据有效性和重言蕴涵的定义，下列两个命题等价： \\(\\lbrace \\varphi_0,...,\\varphi_n \\rbrace\\) 重言蕴涵 \\(\\psi\\)， 以 \\(\\varphi_0,...,\\varphi_n\\) 为前提并以 \\(\\psi\\) 为结论的论说形式是有效的。 在理论讨论中，「重言蕴涵」比「有效论说形式」使用得更多，尽管根据上述等价性，我们知道在命题逻辑部分，它们说的是一回事。（这里谈到的公式集合都是有穷集合，无穷集合的情况将在§3.1（P.101）中讨论。在谓词逻辑部分，重言蕴涵关系将让位于逻辑蕴涵关系，重言后承关系将让位于逻辑后承关系。） 例 3.36 \\(\\lbrace p \\rightarrow (q \\rightarrow r), p \\rightarrow q \\rbrace\\) 重言蕴涵 \\(p \\rightarrow r\\)，而 \\(r \\rightarrow \\neg q\\) 则不是 \\(\\lbrace p \\rightarrow q \\lor \\neg r, r \\land q \\rightarrow p \\rbrace\\) 的重言后承。 Solution: 分别见例 3.34 和例 3.35 中的真值表。 例 3.37 \\(p \\rightarrow q\\) 重言蕴涵 \\(\\neg q \\rightarrow \\neg p.\\) Solution: 在 \\(p \\rightarrow q\\) 和 \\(\\neg q \\rightarrow \\neg p\\) 的联合真值表中，\\(\\neg q \\rightarrow \\neg p\\) 只在第二行是假的，而 \\(p \\rightarrow q\\) 在该行也是假的。这就是说，在该表的每一行中，如果 \\(p \\rightarrow q\\) 是真的则 \\(\\neg q \\rightarrow \\neg p\\) 也是真的。根据重言蕴涵的定义，\\(p \\rightarrow q\\) 重言蕴涵 \\(\\neg q \\rightarrow \\neg p.\\)（对比例 3.33） \\[ \\begin{array}{cc|c|ccc} p &amp; q &amp; p \\rightarrow q &amp; \\neg q \\rightarrow \\neg p \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{array} \\] 例 3.38 \\(p \\rightarrow q\\) 不重言蕴涵 \\(\\neg p \\rightarrow \\neg q.\\) Solution: 在 \\(p \\rightarrow q\\) 和 \\(\\neg p \\rightarrow \\neg q\\) 的联合真值表中，\\(p \\rightarrow q\\) 在第三行是真的，但 \\(\\neg p \\rightarrow \\neg q\\) 在该行是假的。所以，根据重言蕴涵的定义 \\(p \\rightarrow q\\) 不重言蕴涵 \\(\\neg p \\rightarrow \\neg q.\\) \\[ \\begin{array}{cc|c|ccc} p &amp; q &amp; p \\rightarrow q &amp; \\neg p \\rightarrow \\neg q \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\end{array} \\] 3.6.3 重言等值 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式。\\(\\varphi\\) 与 \\(\\psi\\) 重言等值（tautologically equivalent） 当且仅当在 \\(\\varphi\\) 与 \\(\\psi\\) 联合真值表的任意一行中，\\(\\varphi\\) 与 \\(\\psi\\) 有同样的真值，亦即在它们的联合真值表的每一行中，如果 \\(\\varphi\\) 的真值是 1，则 \\(\\psi\\) 的真值也是 1；并且如果 \\(\\varphi\\) 的真值是 0，则 \\(\\psi\\) 的真值也是 0. 根据重言蕴涵和重言等值的定义，易见下列命题等价： \\(\\varphi\\) 与 \\(\\psi\\) 重言等值， \\(\\varphi\\) 与 \\(\\psi\\) 相互重言蕴涵（\\(\\varphi\\) 与 \\(\\psi\\) 各是对方的重言后承）。 例 3.39 \\(p \\rightarrow q \\land p\\) 与 \\(\\neg q \\rightarrow \\neg p\\) 重言等值。 Solution: \\(p \\rightarrow q \\land p\\) 与 \\(\\neg q \\rightarrow \\neg p\\) 在它们的联合真值表的每一行中真值都相同，因而由重言等值的定义得知两公式重言等值。 \\[ \\begin{array}{cc|c|c} p &amp; q &amp; p \\rightarrow q \\wedge p &amp; \\neg q \\rightarrow \\neg p \\\\ \\hline 1 &amp; 1 &amp; 1~~~~~~~ &amp; 1 \\\\ 1 &amp; 0 &amp; 0~~~~~~~ &amp; 0 \\\\ 0 &amp; 1 &amp; 1~~~~~~~ &amp; 1 \\\\ 0 &amp; 0 &amp; 1~~~~~~~ &amp; 1 \\end{array} \\] 例 3.40 \\(p \\land \\neg q\\) 与 \\(\\neg p \\lor q\\) 不重言等值。 Solution: 在 \\(p \\land \\neg q\\) 与 \\(\\neg p \\lor q\\) 的联合真值表中，\\(p \\land \\neg q\\) 在第一行是假的，而 \\(\\neg p \\lor q\\) 在同一行是真的。所以，根据重言等值的定义，这两个公式不是重言等值的。（事实上，在上述真值表中，\\(p \\land \\neg q\\) 与 \\(\\neg p \\lor q\\) 在每一行的真值都不同；但是，对「不重言等值」来说，两公式在一行中真值不同已经足够了。） \\[ \\begin{array}{cc|c|c} p &amp; q &amp; p \\wedge \\neg q &amp; \\neg p \\vee q \\\\ \\hline 1 &amp; 1 &amp; 0~~ &amp; ~~~1 \\\\ 1 &amp; 0 &amp; 1~~ &amp; ~~~0 \\\\ 0 &amp; 1 &amp; 0~~ &amp; ~~~1 \\\\ 0 &amp; 0 &amp; 0~~ &amp; ~~~1 \\end{array} \\] 3.6.4 可满足性 这里说的可满足性（satisfiability），就是§0.2（P.8）中说的语义一致性。设 \\(\\Gamma\\) 为任意有穷的公式集合。\\(\\Gamma\\) 是可满足的（satisfiable）当且仅当 \\(\\Gamma\\) 中公式的联合真值表中存在某一行，在该行里 \\(\\Gamma\\) 中的公式的真值都是 1. \\(\\Gamma\\) 是不可满足的当且仅当它不是可满足的。设 \\(\\varphi\\) 为任意公式。\\(\\varphi\\) 是可满足的当且仅当 \\(\\lbrace \\varphi\\rbrace\\) 是可满足的。\\(\\varphi\\) 是不可满足的当且仅当 \\(\\lbrace \\varphi\\rbrace\\) 不是可满足的。 例 3.41 \\(\\Gamma = \\lbrace p \\rightarrow p \\land q, \\neg p \\rightarrow \\neg p \\land \\neg q, p \\lor q \\rbrace\\) 是可满足的。 Solution: 下述真值表的第一行中，\\(\\Gamma\\) 中每个公式都是真的，所以由可满足性的定义知 \\(\\Gamma\\) 是可满足的。 \\[ \\begin{array}{cc|llc} p &amp; q &amp; p \\rightarrow p \\wedge q, &amp; \\neg p \\rightarrow \\neg p \\wedge \\neg q, &amp; p \\vee q \\\\ \\hline 1 &amp; 1 &amp; ~~~~1 &amp; ~~~~~~~1 &amp; 1 \\\\ 1 &amp; 0 &amp; ~~~~0 &amp; ~~~~~~~1 &amp; 1 \\\\ 0 &amp; 1 &amp; ~~~~1 &amp; ~~~~~~~0 &amp; 1 \\\\ 0 &amp; 0 &amp; ~~~~1 &amp; ~~~~~~~1 &amp; 0 \\end{array} \\] 例 3.42 \\(\\Gamma = \\lbrace p \\rightarrow p \\land q, \\neg p \\rightarrow \\neg p \\land \\neg q, \\neg (p \\rightarrow q) \\rbrace\\) 不是可满足的。 Solution: 下面是 \\(\\Gamma\\) 中公式的联合真值表。在该表的第一行中 \\(\\neg (p \\rightarrow q)\\) 是假的，第二行中 \\(p \\rightarrow p \\land q\\) 是假的，第三行中 \\(\\neg p \\rightarrow \\neg p \\land \\neg q\\) 是假的，第四行中 \\(\\neg (p \\rightarrow q)\\) 是假的。所以由定义知 \\(\\Gamma\\) 是不可满足的。 \\[ \\begin{array}{cc|lll} p &amp; q &amp; p \\rightarrow p \\wedge q, &amp; \\neg p \\rightarrow \\neg p \\wedge \\neg q, &amp; \\neg(p \\leftrightarrow q) \\\\ \\hline 1 &amp; 1 &amp; ~~~~1 &amp; ~~~~~~~1 &amp; 0 \\\\ 1 &amp; 0 &amp; ~~~~0 &amp; ~~~~~~~1 &amp; 1 \\\\ 0 &amp; 1 &amp; ~~~~1 &amp; ~~~~~~~0 &amp; 1 \\\\ 0 &amp; 0 &amp; ~~~~1 &amp; ~~~~~~~1 &amp; 0 \\end{array} \\] 我们简要地介绍一些关于可满足性的命题，部分涉及可满足性与重言蕴涵的关系。这些命题都有简单的证明，其中一部分会在 §3.1（P.101）中讨论。请读者思考这些命题成立的理由（见习题 2.17）。 设 \\(\\Gamma = \\lbrace \\varphi_0,...,\\varphi_n\\rbrace\\) 为任意有穷的公式集，\\(\\varphi\\) 为任意公式。我们有： 如果 \\(\\Gamma\\) 可满足，那么对任何公式集 \\(\\Delta\\)，\\(\\Gamma \\cap \\Delta\\) 也可满足。（注：对所有集合 \\(X\\) 和 \\(Y\\)，\\(X \\cap Y = \\lbrace x: x \\in X ~\\text{且}~ x \\in Y \\rbrace\\)，它是包含 \\(X\\) 和 \\(Y\\) 的所有公共元素的集合，称为 \\(X\\) 和 \\(Y\\) 的交（intersection）。） 如果 \\(\\Gamma\\) 不可满足，那么对任何有穷公式集 \\(\\Delta\\)，\\(\\Gamma \\cup \\Delta\\) 也不可满足。（注：对所有集合 \\(X\\) 和 \\(Y\\)，\\(X \\cup Y = \\lbrace x: x \\in X ~\\text{或}~ x \\in Y \\rbrace\\)，它是包含 \\(X\\) 的所有元素和 \\(Y\\) 的所有元素的集合，称为 \\(X\\) 和 \\(Y\\) 的并集（union）。） 设 \\(\\Gamma \\subseteq \\Delta\\)，其中 \\(\\Delta\\) 是任意有穷公式集。如果 \\(\\Delta\\) 可满足则 \\(\\Gamma\\) 可满足（如果 \\(\\Gamma\\) 不可满足则 \\(\\Delta\\) 不可满足）。（注：对所有集合 \\(X\\) 和 \\(Y\\)，\\(X \\subseteq Y\\) 当且仅当 \\(X\\) 的所有元素都是 \\(Y\\) 的元素，\\(X \\subset Y\\) 当且仅当 \\(X \\subseteq Y\\) 并且 \\(Y \\nsubseteq X\\)（并非 \\(Y \\subseteq X\\)）。当 \\(X \\subseteq Y\\)，我们称 \\(X\\) 是 \\(Y\\) 的子集（subset），也称 \\(Y\\) 是 \\(X\\) 的扩集（superset）或扩充（extension）。当 \\(X \\subset Y\\)，我们称 \\(X\\) 是 \\(Y\\) 的真子集（proper subset），也称 \\(Y\\) 是 \\(X\\) 的真扩集或真扩充。注意：「\\(X \\subseteq Y\\)」表达的是个命题，说的是 \\(X\\) 和 \\(Y\\) 之间的某种关系；而「\\(X \\cap Y\\)」「\\(X \\cup Y\\)」和下面的「\\(X - Y\\)」不表达命题，只表示 \\(X\\) 和 \\(Y\\) 在某些运算下的值——集合。） \\(\\Gamma \\cup \\lbrace \\neg \\varphi\\rbrace\\)不可满足当且仅当 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)。 对任意 \\(i \\leqslant n\\)，\\(\\Gamma\\) 不可满足当且仅当 \\(\\Gamma - \\lbrace \\psi_i\\rbrace\\) 重言蕴涵 \\(\\neg \\psi_i\\)。（注：对所有集合 \\(X\\) 和 \\(Y\\)，\\(X - Y = \\lbrace x: x \\in X ~\\text{且}~ x \\notin Y \\rbrace\\)，它是包含 \\(X\\) 的所有元素但不包含 \\(Y\\) 的任何元素的集合，称为 \\(X\\) 和 \\(Y\\) 的差（difference），也称为 \\(Y\\) 在 \\(X\\) 中的相对补（relative complement of \\(Y\\) in \\(X\\)）。） 如果 \\(\\Gamma\\) 不可满足，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)。 如果 \\(\\neg \\varphi\\) 不可满足，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)。 如果 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)，并且 \\(\\Gamma\\) 可满足，那么 \\(\\varphi\\) 也可满足。 如果 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\) 并且 \\(\\Gamma\\) 重言蕴涵 \\(\\neg \\varphi\\)，那么 \\(\\Gamma\\) 不可满足。 3.6.5 重言式、矛盾式与或然式 根据公式在其真值表各行中的真值情况，我们把公式分成三类：重言式（tautology）、矛盾式（contradiction）与或然式（偶然式，contingency）。 公式 \\(\\varphi\\) 是重言式（tautology）当且仅当在其真值表的每一行中，\\(\\varphi\\) 的真值都是 1，即 \\(\\varphi\\) 总是真的。 公式 \\(\\varphi\\) 是矛盾式（contradiction）当且仅当在其真值表的每一行中，\\(\\varphi\\) 的真值都是 0，即 \\(\\varphi\\) 总是假的。（矛盾式也称不可满足式。） 公式 \\(\\varphi\\) 是或然式（contingency）当且仅当在其真值表中，\\(\\varphi\\) 的真值在某些行中是 1，而在另一些行中是 0，即 \\(\\varphi\\) 有时真有时假。 例 3.43 \\(p \\rightarrow (q \\rightarrow p)\\) 是重言式。 Solution: 主联结词下方一列真值都是 1，所以 \\(p \\rightarrow (q \\rightarrow p)\\) 是重言式。 \\[ \\begin{array}{cc|l} p &amp; q &amp; p \\rightarrow(q \\rightarrow p) \\\\ \\hline 1 &amp; 1 &amp; ~~~~1 \\\\ 1 &amp; 0 &amp; ~~~~1 \\\\ 0 &amp; 1 &amp; ~~~~1 \\\\ 0 &amp; 0 &amp; ~~~~1 \\end{array} \\] 例 3.44 \\(p \\land (p \\rightarrow \\neg p)\\) 是矛盾式。 Solution: 主联结词下方一列真值都是 0，所以 \\(p \\land (p \\rightarrow \\neg p)\\) 是矛盾式。 \\[ \\begin{array}{c|l} p &amp; p \\wedge(p \\rightarrow \\neg p) \\\\ \\hline 1 &amp; ~~~0 \\\\ 0 &amp; ~~~0 \\end{array} \\] 例 3.45 \\(p \\rightarrow q \\land p\\) 是或然式。 Solution: 主联结词下方一列真值中有 1 也有 0，所以 \\(p \\rightarrow q \\land p\\) 是或然式。 \\[ \\begin{array}{cc|l} p &amp; q &amp; p \\rightarrow q \\wedge p \\\\ \\hline 1 &amp; 1 &amp; ~~~~1 \\\\ 1 &amp; 0 &amp; ~~~~0 \\\\ 0 &amp; 1 &amp; ~~~~1 \\\\ 0 &amp; 0 &amp; ~~~~1 \\end{array} \\] 类似于讨论可满足性与重言蕴涵时的情况，我们只简要介绍些关于重言式、矛盾式与或然式之间的关系的命题，其中一部分会在 §3.1.3（P.104）中讨论。请读者思考下列命题成立的理由（另见习题 2.6-2.9）。 重言式的否定是矛盾式。 矛盾式的否定是重言式。 或然式的否定还是或然式。 重言式与重言式的合取是重言式。 重言式与矛盾式的合取是矛盾式。 重言式与或然式的合取是或然式。 矛盾式与矛盾式的合取是矛盾式。 矛盾式与或然式的合取是矛盾式。 或然式与或然式的合取或者是或然式，或者是矛盾式。 关于上面引入的各语义概念间的关系，我们同样只简单介绍而不做证明。另一些命题将在§3.1（P.101）中讨论。 易见，对所有公式 \\(\\varphi, \\psi, \\chi\\)，%公式 \\(\\varphi \\land (\\psi \\land \\chi)\\) 与 \\((\\varphi \\land \\psi) \\land \\chi\\) 重言等值，公式 \\(\\varphi \\lor (\\psi \\lor \\chi)\\) 与 \\((\\varphi \\lor \\psi) \\lor \\chi\\) 重言等值。 \\(\\varphi \\land (\\psi \\land \\chi)\\) 与 \\((\\varphi \\land \\psi) \\land \\chi\\) 重言等值 \\(\\varphi \\lor (\\psi \\lor \\chi)\\) 与 \\((\\varphi \\lor \\psi) \\lor \\chi\\) 重言等值 以下，我们省略一连串合取和一连串析取应有的括号，用 \\(\\varphi_{0} \\wedge \\cdots \\wedge \\varphi_{n}\\) 表示 \\(\\left(\\cdots\\left(\\varphi_{0} \\wedge \\varphi_{1}\\right) \\wedge \\cdots \\wedge \\varphi_{n-1}\\right) \\wedge \\varphi_{n}\\)，用 \\(\\varphi_{0} \\vee \\cdots \\vee \\varphi_{n}\\) 表示 \\(\\left(\\cdots\\left(\\varphi_{0} \\vee \\varphi_{1}\\right) \\vee \\cdots \\vee \\varphi_{n-1}\\right) \\vee \\varphi_{n}\\)。在极限情况 \\(n=0\\) 时，\\(\\varphi_{0} \\wedge \\cdots \\wedge \\varphi_{n}= \\varphi_{0} \\vee \\cdots \\vee \\varphi_{n}=\\varphi_{0}\\)。这就是说，当 \\(\\varphi_{0} \\wedge \\cdots \\wedge \\varphi_{n}\\) 或 \\(\\varphi_{0} \\vee \\cdots \\vee \\varphi_{n}\\) 在讨论中出现而我们又要考虑主联结词时，我们可以按「左结合」的原则恢复括号。 设 \\(\\varphi, \\psi, \\varphi_{0},...,\\varphi_{n}\\) 为任意公式且 \\(\\Gamma = \\lbrace \\varphi_{0},...,\\varphi_{n}\\rbrace\\)。请思考下列命题成立的理由（见习题 2.18）： \\(\\varphi\\) 重言蕴涵 \\(\\psi\\) 当且仅当 \\(\\varphi \\rightarrow \\psi\\) 是重言式； \\(\\varphi\\) 重言等值于 \\(\\psi\\) 当且仅当 \\(\\varphi \\rightarrow \\psi\\) 是重言式，当且仅当 \\(\\psi \\rightarrow \\varphi\\) 与 \\(\\varphi \\rightarrow \\varphi\\) 都是重言式； \\(\\Gamma\\) 重言蕴涵 \\(\\psi\\) 当且仅当 \\(\\varphi_{0} \\land \\cdots \\land \\varphi_{n} \\rightarrow \\psi\\) 是重言式； \\(\\varphi_{0} \\land \\cdots \\land \\varphi_{n} \\rightarrow \\psi\\) 与 \\(\\varphi_{0} \\land \\cdots \\land \\varphi_{n-1} \\rightarrow (\\varphi_n \\rightarrow \\psi )\\) 重言等值； 如果 \\(\\varphi\\) 是重言式，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)； \\(\\Gamma\\) 可满足当且仅当 \\(\\varphi_{0} \\land \\cdots \\land \\varphi_{n}\\) 或者是或然式或者是重言式； \\(\\Gamma\\) 不可满足当且仅当 \\(\\varphi_{0} \\land \\cdots \\land \\varphi_{n}\\) 或者是或然式或者是矛盾式。 如果 \\(\\varphi\\) 是重言式，那么 \\(\\Gamma\\) 是可满足的当且仅当 \\(\\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 是可满足的； 如果 \\(\\varphi_i (i \\leqslant n)\\) 是重言式，那么 \\(\\Gamma\\) 是可满足的当且仅当 \\(\\Gamma - \\lbrace \\varphi_i\\rbrace\\) 是可满足的； 如果 \\(\\varphi\\) 是矛盾式，那么 \\(\\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 是不可满足的； 如果 \\(\\varphi_i (i \\leqslant n)\\) 是矛盾式，那么 \\(\\Gamma\\) 是不可满足的。 3.6.6 简化真值表方法 我们知道，如果对一个包含 \\(n\\) 个命题变号的公式构造完整的真值表，其真值表有 \\(2^n\\) 行。随着 \\(n\\) 的增长，\\(2^n\\) 是以「指数」增长的。借助计算机，假定以 \\(100,0000\\) 行每秒的速度生成真值表，当 \\(n=80\\) 时，那就需要 \\(2^{80} \\mu \\mathrm{s}\\) 生成真值表，这个时间是多长呢？换算成以年为单位的话，大槪是 \\(380\\) 亿年，而宇宙至今也只存在了大槪 \\(150\\) 亿年，超过了宇宙到现在的存在时间！这也是现代理论计算机科学中最著名的难题。［Enderton,2001: 25］ 所以，一旦公式（集）中出现 3 个或更多的命题变号，它们的真值表就会比较大，手工画起来常有困难。日常思维与语言中的论证，涉及的命题变号通常并不多，可以引入简化真值表方法判定一个论说形式是否有效。简化真值表方法有多种，这里只介绍其一。 用简化真值表法判别一个论说形式是否有效，通常可按以下方式来做：首先假设该论说形式的前提都真而结论假，然后根据它们的真值算出它们的直接子公式的真值，再进一步根据子公式的真值算出这些子公式的直接子公式的真值。（当遇到合取式为假或析取式为真等情况时，不能直接算出它们的直接子公式的真值而要分情况讨论。）在这一过程中，若遇到某公式既真又假，就可判定给出的论说形式是有效的；若没有遇到这种情况，则可判定该论说形式是无效的。在后一种情况下，能找到该论说形式中命题变号的一个可能取值组合，使得根据这个组合，该论说形式的前提为真而结论为假。 例 3.46 用简化真值表方法检验 \\(p \\rightarrow (q \\rightarrow r), p \\rightarrow q ~/ \\therefore p \\rightarrow r\\) 是否有效。 Solution: 这个论证形式是有效的。假定这个论说形式不是有效的，我们得到一个矛盾：\\(q\\) 既真又假。\\(q\\) 不可能同时既真又假，所以给定的论说形式一定是有效的。见下表： \\[ \\begin{array}{c|ll|c|c} \\text{步骤} &amp; p \\rightarrow(q \\rightarrow r), &amp; p \\rightarrow q &amp; /\\therefore p \\rightarrow r &amp; \\text{步骤解说} \\\\ \\hline 1 &amp; ~~~~1 &amp; ~~~~1 &amp; ~~\\quad0 &amp; \\text{假设论证形式无效}\\\\[0.4ex] 2 &amp; &amp; &amp; ~~~\\quad1~\\quad0 &amp; \\text{推得结论中}~p, r~\\text{真值}\\\\[0.4ex] 3 &amp;1~~~~~~~~~~~~1~~0 &amp; 1&amp; &amp; \\text{推得前提中}~q \\rightarrow r~\\text{真值}\\\\[0.4ex] 4 &amp;~~~~~~~~~~~\\mathbf{0} &amp; ~~~~~~~~\\mathbf{1}&amp; &amp; \\text{推得前提中}~q~\\text{亦真亦假}\\\\ \\end{array} \\] 例 3.47 用简化真值表方法检验 \\(p \\rightarrow q \\lor \\neg r, r \\land q \\rightarrow p ~/ \\therefore r \\rightarrow \\neg q\\) 是否有效。 Solution: 这个论证形式是无效的。易见我们的假设不导致任何矛盾，所以当 \\(p, q, r\\) 都为真时，上述论说形式的前提为真而结论为假。所以，该论说形式是无效的。（本例中，作为蕴涵式后件的 \\(q \\lor \\neg r\\) 为真，则蕴涵式 \\(p \\rightarrow q \\lor \\neg r\\) 一定为真，这与 \\(p\\) 的真值无关。）见下表： \\[ \\begin{array}{c|ll|c|c} \\text{步骤} &amp; p \\rightarrow q \\lor \\neg r, &amp; r \\land q \\rightarrow p &amp; /\\therefore r \\rightarrow \\neg q &amp; \\text{步骤解说} \\\\ \\hline 1 &amp; ~~~~1 &amp; ~~~~~~~~~~1 &amp; ~~~~0 &amp; \\text{假设论证形式无效}\\\\[0.4ex] 2 &amp; &amp; &amp; ~~~~~~~~1~~~~~~~~1 &amp; \\text{推得结论中} ~ r, q ~ \\text{真值}\\\\[0.4ex] 3 &amp;~~~~~~~~~~~1 &amp; &amp; &amp; \\text{推得前提中} ~q \\lor \\neg r~ \\text{真值}\\\\[0.4ex] 4 &amp; &amp; ~~~1~~~~~1~~1&amp; &amp; \\text{设} ~ p ~ \\text{真，则} ~r \\land q \\rightarrow p~ \\text{真}\\\\[0.4ex] 5 &amp;~~~~1 &amp; ~~~~~~~~~~1&amp; ~~~~0 &amp; \\text{存在前提都真而结论假}\\\\ \\end{array} \\] 由于重言蕴涵和有效论说形式是「一回事」，所以我们就不再单独讨论如何用简化真值表方法判定一个公式集是否重言蕴涵某个公式。 要说明一个公式是重言式，我们可以假设它为假，再试图说明这不可能；而一旦这个假设没有导致矛盾，那么我们就会得到命题变号的一个可能取值组合，使得给定公式为假。类似地，要说明一个公式是矛盾式，我们可以假定它是真的，再试图说明这不可能；而一旦这个假设没有导致矛盾，那么我们就会得到命题变号的一个可能取值组合，使得给定公式为真。如果假设一公式为真没有导致矛盾，并且假设它为假也没有导致矛盾，那么该公式就一定是或然式。 例 3.48 设 \\(\\varphi\\), \\(\\psi\\), \\(\\chi\\) 为任意公式。用简化真值表方法说明公式 \\((\\varphi \\rightarrow \\psi \\wedge \\chi) \\rightarrow(\\varphi \\rightarrow \\psi) \\wedge(\\varphi \\rightarrow \\chi)\\) 是重言式。 Solution: 前几个例子中，每个公式的真值都足以确定它的直接子公式的真值。本例则不同。见下表： \\[ \\begin{array}{c|l|c|c|c} \\text{步骤} &amp; (\\varphi \\rightarrow \\psi \\wedge \\chi) &amp; \\rightarrow &amp; (\\varphi \\rightarrow \\psi) \\wedge(\\varphi \\rightarrow \\chi) &amp; \\text{步骤解说} \\\\ \\hline 1 &amp; ~~~~~~\\mathbf{\\color{red}1} &amp; 0 &amp; 0 &amp; \\text{假设重言式无效}\\\\[0.4ex] 2.1 &amp;~1~~~~~~~0 &amp; &amp; ~1~~0~~0~~~~~~~~~~~~~~~~~~~~~ &amp; \\text{若} ~\\varphi \\rightarrow \\psi~ \\text{为假}\\\\[0.4ex] 2.2 &amp;~~~~~~\\mathbf{\\color{red}0} &amp; &amp;&amp; \\text{前提} ~\\varphi \\rightarrow \\psi \\wedge \\chi~ \\text{假}\\\\[0.4ex] 3.1 &amp;~1~~~~~~~~~~~~~0 &amp; &amp; ~~~~~~~~~~~~~~~~~~~~1~~0~~0 &amp; \\text{若} ~\\varphi \\rightarrow \\chi~ \\text{为假}\\\\[0.4ex] 3.2 &amp;~~~~~~\\mathbf{\\color{red}0} &amp; &amp; &amp; \\text{前提} ~\\varphi \\rightarrow \\psi \\wedge \\chi~ \\text{假}\\\\ \\end{array} \\] 如果上述蕴涵式是假的，它的前件一定是真的而后件一定是假的；然而，该前件的真不足以确定其直接子公式 \\(\\varphi\\) 和 \\(\\psi \\land \\chi\\) 的真值，并且该后件的假也不足以确定其直接子公式 \\(\\varphi \\rightarrow \\psi\\) 和 \\(\\varphi \\rightarrow \\chi\\) 的真值。所以，需要分两种情况讨论。后件是合取式，而合取式为假的情况有两种。两种情形皆导致矛盾，所以，上述公式一定是重言式。 例 3.49 用简化真值表方法说明下列公式是矛盾式： \\((\\neg(p \\rightarrow r) \\land (q \\rightarrow \\neg p)) \\land (\\neg q \\rightarrow \\neg p).\\) Solution: 有时，经验可以帮助我们避免「分情况讨论」的复杂局面。见下表： \\[ \\begin{array}{c|lcc|c|c} \\text{步骤} &amp;(\\neg(p \\rightarrow r)&amp; \\land &amp; (q \\rightarrow \\neg p)) &amp; \\land &amp; (\\neg q \\rightarrow \\neg p) \\\\ \\hline 1 &amp; &amp;1 &amp; &amp; \\mathbf{1}&amp; 1\\\\[0.4ex] 2 &amp;~1~~~~~~0 &amp; &amp;1~~~~ &amp; &amp; \\\\[0.4ex] 3 &amp; ~~~~~~1 &amp; &amp; ~~~~0 &amp; &amp;~~~~~~~~~0 \\\\[0.4ex] 4 &amp; &amp; &amp; \\mathbf{0}~~~~~~~~~~~~ &amp; &amp;\\mathbf{1}~~~~~~ \\end{array} \\] 假设上述合取式是真的，最终推得 \\(q\\) 既真又假，但这是不可能的。所以，上述公式一定是矛盾式。 在例 3.49 中，我们的思路是：在已确定 \\(\\neg(p \\rightarrow r), q \\rightarrow \\neg p, \\neg q \\rightarrow \\neg p\\) 都为真时，选择蕴涵式的否定 \\(\\neg(p \\rightarrow r)\\) 来进一步求得蕴涵式前件 \\(p\\) 的真值 1. 假如我们选择的是蕴涵式 \\(q \\rightarrow \\neg p\\) 或 \\(\\neg q \\rightarrow \\neg p\\)，那么我们就不得不分情况讨论，因为当时只能得到：或者其前件是假的或者其后件是真的。显然，选择 \\(\\neg(p \\rightarrow r)\\) 以求得 \\(p\\) 的真值 1，使我们避免了「分情况讨论」的复杂局面。这里运用了下述「经验规则」： 如果在某一步骤中得到 \\(\\neg (\\varphi \\lor \\psi)\\) 或 \\(\\neg (\\varphi \\rightarrow \\psi)\\) 的真值为 1（或得到 \\(\\varphi \\lor \\psi\\) 或 \\(\\varphi \\rightarrow \\psi\\) 的真值为 0），先用这一信息求得子公式 \\(\\varphi\\) 和 \\(\\psi\\) 的真值。这样做往往可以简化确定其他子公式真值的过程。 运用简化真值表的方法，我们同样可以说明一个公式是或然式、非重言式或者非矛盾式等。具体例子省略，请读者去做练习。 第三章开始学习写证明。简化真值表方法虽然并不就是写证明，但它们的思路有时是类似的。从现在起应注意与证明有关的问题。 3.7 本章习题 练习 3.1 (说明下列联结词不是真值函数联结词) 因为\\(\\underline{\\hspace{3em}}\\)，所以\\(\\underline{\\hspace{3em}}\\)。 可以想像\\(\\underline{\\hspace{3em}}\\)。 昨天\\(\\underline{\\hspace{3em}}\\)。 张三相信\\(\\underline{\\hspace{3em}}\\)。 李四认为\\(\\underline{\\hspace{3em}}\\)。 王五知道\\(\\underline{\\hspace{3em}}\\)。 政客们喜欢说\\(\\underline{\\hspace{3em}}\\)。 从平民的角度看\\(\\underline{\\hspace{3em}}\\)。 练习 3.2 (给出「辞典」，并将下列语句符号化) 不是所有的人都讲道理。 如果在选举时你不去投票，那么你就要忍受我选的白痴。 张三是李四的祖先当且仅当李四是张三的后代。 除非有奇迹出现，中国足球队 500 年内挤不进世界 16 强。 张三只有坚持锻炼才会有好身体；但并非只要他坚持锻炼就会有好身体。 如果张三一进大学就知道自己想做什么，那么，他大学期间不会浪费太多时间，而他的学习成绩也不会太差。 要么明天有海战，要么明天没有海战；但明天不必然有海战，而且明天也不必然没有海战。 练习 3.3 (给出「辞典」，将下列论说符号化，判断是否有效并给出理由) 如果今天是星期三，那么明天有逻辑课。因此，如果明天没有逻辑课，则今天不是星期三。 要么士兵拿破仑想当将军，要么士兵拿破仑不想当将军。如果士兵拿破仑想当将军，那么他不是一个好士兵。如果士兵拿破仑不想当将军，那么他也不是一个好士兵。所以，士兵拿破仑不是一个好士兵。 或者逻辑难学，或者没有多少学生喜欢它。如果数学容易学，那么逻辑不难学。因此，如果许多学生喜欢逻辑，那么数学并不容易学。 如果上帝死了，那么做什么坏事情都是可以的。如果做什么坏事情都是可以的，那么我考试作弊也是可以的。所以，如果上帝死了，我考试作弊是可以的。 花都是红的当且仅当李四不是色盲。花不都是红的。所以李四是色盲。 如果 \\(a\\) 是正整数，则 \\(a\\) 有唯一的后继，并且 \\(a\\) 有唯一的前驱。\\(a\\) 要么并非有唯一的后继，要么并非有唯一的前驱。所以 \\(a\\) 不是正整数。 如果我相信上帝，则如果上帝是存在的，我就有所得；如果上帝不存在，我也无所失。另一方面，如果我不相信上帝，则如果上帝存在，我有所失；如果上帝不存在，我无所得。因此，我如果相信上帝，我或者有所得，或者无所失；而如果我不相信上帝，则我或者有所失，或者无所得。 分析示例 32.1（P.427）中荆王免去士兵死罪的推理过程，并加以符号化。 练习 3.4 (填写空格，使下列命题都成立) 一个否定式是假的当且仅当\\(\\underline{\\hspace{5em}}\\)； 一个合取式是假的当且仅当\\(\\underline{\\hspace{5em}}\\)； 一个析取式是假的当且仅当\\(\\underline{\\hspace{5em}}\\)； 一个蕴涵式是假的当且仅当\\(\\underline{\\hspace{5em}}\\)； 一个等值式是假的当且仅当\\(\\underline{\\hspace{5em}}\\)。 练习 3.5 (给出下列公式的真值表) \\(\\neg \\neg p \\rightarrow p\\) \\(p \\rightarrow(\\neg p \\rightarrow q)\\) \\(p \\rightarrow p \\wedge q\\) \\(p \\wedge q \\rightarrow p \\vee q\\) \\(p \\vee q \\rightarrow p \\wedge q\\) \\(p \\vee q \\rightarrow \\neg(p \\rightarrow q\\) \\(p \\wedge q \\rightarrow \\neg(p \\rightarrow \\neg q)\\) \\((p \\rightarrow q) \\rightarrow \\neg(\\neg q \\rightarrow \\neg p)\\) \\(\\neg(p \\vee q) \\rightarrow \\neg p \\wedge \\neg q\\) \\(\\neg(p \\wedge q) \\rightarrow \\neg p \\vee \\neg q\\) \\((p \\rightarrow q) \\vee(q \\rightarrow p)\\) \\((\\neg p \\rightarrow q) \\rightarrow((\\neg p \\rightarrow \\neg q) \\rightarrow p)\\) \\((p \\rightarrow(q \\rightarrow r)) \\rightarrow((r \\rightarrow q) \\rightarrow(r \\rightarrow p))\\) \\((p \\leftrightarrow q) \\leftrightarrow \\neg(p \\wedge q) \\vee \\neg(\\neg p \\wedge \\neg q)\\) \\((p \\vee q) \\wedge(p \\vee r) \\rightarrow p \\vee(q \\wedge r)\\) 练习 3.6 (判断下列说法的对错，并说明理由) 任一公式都或者是重言式，或者是矛盾式，或者是或然式；并且只能是这三种公式中的一种。 对任意公式集 \\(\\Gamma\\) 和任意公式 \\(\\varphi\\)，\\(\\Gamma\\) 或者重言蕴涵 \\(\\varphi\\) 或者重言蕴涵 \\(\\neg \\varphi\\)。 对任意公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi\\) 或者与 \\(\\psi\\) 重言等价或者与 \\(\\neg \\psi\\) 重言等价。 对任意公式 \\(\\varphi\\)，或者 \\(\\varphi\\) 可满足或者 \\(\\neg \\varphi\\) 可满足。 练习 3.7 (判断下列说法的对错) 在每个括号中画 \\(\\checkmark\\) 或 ✗ 分别表明「可以是」和「一定不是」，并思考原因。如或然式与或然式的合取：（✗）重言式，（\\(\\checkmark\\)）矛盾式，（\\(\\checkmark\\)）或然式。它相当于说：或然式与或然式的合取可以是矛盾式，也可以是或然式，但一定不是重言式。（当然，如果正确的画法中有两个 ✗，那么第三个一定是画 \\(\\checkmark\\)，而且画 \\(\\checkmark\\) 的地方一定可以读作「一定是」。想想为什么是这样。 重言式与重言式的析取：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 重言式与矛盾式的析取：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 重言式与或然式的析取：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以重言式为前后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以重言式为前件、矛盾式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以重言式为前件、或然式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以矛盾式为前、后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以矛盾式为前件、重言式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以矛盾式为前件、或然式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以或然式为前后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以或然式为前件、重言式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 以或然式为前件、矛盾式为后件的蕴涵式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端都是重言式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端分别是重言式和矛盾式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端分别是重言式和或然式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端都是矛盾式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端分别是矛盾式和或然式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 两端都是或然式的等值式：（\\(\\underline{\\hspace{1em}}\\)）重言式，（\\(\\underline{\\hspace{1em}}\\)）矛盾式，（\\(\\underline{\\hspace{1em}}\\)）或然式。 练习 3.8 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式。判断下列命题的真假： \\(\\varphi \\land \\psi\\) 是重言式当且仅当 \\(\\varphi\\) 是重言式且 \\(\\psi\\) 是重言式。 \\(\\varphi \\lor \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 是重言式或者 \\(\\psi\\) 是重言式。 \\(\\varphi \\rightarrow \\psi\\) 是重言式当且仅当如果 \\(\\varphi\\) 是重言式那么 \\(\\psi\\) 是重言式。 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是重言式或者 \\(\\varphi\\) 和 \\(\\psi\\) 都不是重言式。 \\(\\varphi\\) 是重言式当且仅当 \\(\\neg \\varphi\\) 不是重言式。 \\(\\varphi \\land \\psi\\) 是矛盾式当且仅当 \\(\\varphi\\) 是矛盾式且 \\(\\psi\\) 是矛盾式。 \\(\\varphi \\lor \\psi\\) 是矛盾式当且仅当或者 \\(\\varphi\\) 是矛盾式或者 \\(\\psi\\) 是矛盾式。 \\(\\varphi \\rightarrow \\psi\\) 是矛盾式当且仅当如果 \\(\\varphi\\) 是矛盾式那么 \\(\\psi\\) 是矛盾式。 \\(\\varphi \\leftrightarrow \\psi\\) 是矛盾式当且仅当或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是矛盾式或者 \\(\\varphi\\) 和 \\(\\psi\\) 都不是矛盾式。 \\(\\varphi\\) 是矛盾式当且仅当 \\(\\neg \\varphi\\) 不是矛盾式。 \\(\\varphi \\land \\psi\\) 是或然式当且仅当 \\(\\varphi\\) 是或然式且 \\(\\psi\\) 是或然式。 \\(\\varphi \\lor \\psi\\) 是或然式当且仅当或者 \\(\\varphi\\) 是或然式或者 \\(\\psi\\) 是或然式。 \\(\\varphi \\rightarrow \\psi\\) 是或然式当且仅当如果 \\(\\varphi\\) 是或然式那么 \\(\\psi\\) 是或然式。 \\(\\varphi \\leftrightarrow \\psi\\) 是或然式当且仅当或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是或然式或者 \\(\\varphi\\) 和 \\(\\psi\\) 都不是或然式。 \\(\\varphi\\) 是或然式当且仅当 \\(\\neg \\varphi\\) 不是或然式。 练习 3.9 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式。在每个括号中画 \\(\\checkmark\\) 或 ✗ 表明「对」和「错」 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是重言式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是矛盾式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是或然式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是重言式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是矛盾式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是或然式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是或然式，那么。\\(\\varphi\\) 是重言式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是或然式，那么 \\(\\varphi\\) 是矛盾式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是或然式，那么 \\(\\varphi\\) 是或然式当且仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 练习 3.10 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式。在每个括号中画 \\(\\checkmark\\) 或 ✗ 表明「对」和「错」： 如果 \\(\\varphi \\rightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是重言式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是矛盾式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是重言式，那么 \\(\\varphi\\) 是或然式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是重言式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是矛盾式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是矛盾式，那么 \\(\\varphi\\) 是或然式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是或然式，那么。\\(\\varphi\\) 是重言式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是或然式，那么 \\(\\varphi\\) 是矛盾式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 如果 \\(\\varphi \\rightarrow \\psi\\) 是或然式，那么 \\(\\varphi\\) 是或然式仅当 \\(\\psi\\) 是重言式（\\(\\underline{\\hspace{1em}}\\)），矛盾式（\\(\\underline{\\hspace{1em}}\\)），或然式（\\(\\underline{\\hspace{1em}}\\)）。 练习 3.11 说明怎样用简化真值表方法证明一个公式重言蕴涵另一个公式，或重言等值于另一个公式。 在以下习题中，对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，我们以 \\(\\varphi \\vDash_0 \\psi\\) 表示 \\(\\varphi\\) 重言蕴涵 \\(\\psi\\)，以 \\(\\varphi_0,...,\\varphi_n\\) 表示 \\(\\lbrace \\varphi_0,...,\\varphi_n\\rbrace\\) 重言蕴涵 \\(\\psi\\)。 练习 3.12 设 \\(\\varphi, \\psi, \\chi\\) 为任意公式。用（简化）真值表说明下列命题都成立： \\(\\varphi \\vDash_{0} \\varphi\\) \\(\\psi \\vDash_{0} \\varphi \\vee \\psi\\) \\(\\varphi, \\psi \\vDash_{0} \\varphi \\wedge \\psi\\) \\(\\varphi \\vDash_{0} \\varphi \\rightarrow \\varphi\\) \\(\\varphi \\vDash_{0} \\psi \\rightarrow \\varphi\\) \\(\\varphi, \\varphi \\rightarrow \\psi \\vDash_{0} \\psi\\) \\(\\psi, \\neg \\psi \\vDash_{0} \\varphi\\) \\(\\varphi \\vee \\psi, \\neg \\psi \\vDash_{0} \\varphi\\) \\(\\neg(\\varphi \\rightarrow \\neg \\psi) \\vDash_{0} \\varphi\\) \\(\\neg(\\varphi \\rightarrow \\neg \\psi) \\vDash_{0} \\psi\\) \\(\\varphi \\rightarrow \\neg \\psi, \\psi \\vDash_{0} \\neg \\varphi\\) \\(\\varphi \\rightarrow \\psi, \\chi \\rightarrow \\varphi \\vDash_{0} \\chi \\rightarrow \\psi\\) \\(\\varphi \\wedge \\psi \\vDash_{0} \\psi \\wedge \\varphi\\) \\(\\varphi \\vee \\psi \\vDash_{0} \\psi \\vee \\varphi\\) \\(\\varphi \\wedge \\psi \\vDash_{0} \\varphi \\vee \\psi\\) \\((\\varphi \\rightarrow \\varphi) \\rightarrow \\psi \\vDash_{0} \\psi\\) \\(\\neg \\varphi \\wedge \\neg \\psi \\vDash_{0} \\neg(\\varphi \\vee \\psi)\\) \\(\\neg \\varphi \\vee \\neg \\psi \\vDash_{0} \\neg(\\varphi \\wedge \\psi)\\) \\(\\varphi \\leftrightarrow \\psi, \\varphi \\vDash_{0} \\psi\\) \\(\\varphi \\leftrightarrow \\psi, \\psi \\vDash_{0} \\varphi\\) 练习 3.13 设 \\(\\varphi, \\psi\\) 为任意公式。用（简化）真值表说明下列每一组中的公式都是重言等值的： \\(\\varphi \\rightarrow \\psi, \\neg \\varphi \\vee \\psi, \\neg(\\varphi \\wedge \\neg \\psi)\\) \\(\\varphi \\vee \\psi, \\neg(\\neg \\varphi \\wedge \\neg \\psi), \\neg \\varphi \\rightarrow \\psi\\) \\(\\varphi \\wedge \\psi, \\neg(\\neg \\varphi \\vee \\neg \\psi), \\neg(\\varphi \\rightarrow \\neg \\psi)\\) \\(\\varphi \\leftrightarrow \\psi,(\\varphi \\rightarrow \\psi) \\wedge(\\psi \\rightarrow \\varphi),(\\varphi \\wedge \\psi) \\vee(\\neg \\varphi \\wedge \\neg \\psi)\\) 练习 3.14 用（简化）真值表说明下列各命题都不成立： \\(p \\vDash_{0} p \\wedge q\\) \\(p \\vee q \\vDash_{0} p\\) \\(p \\rightarrow q, q \\vDash_{0} p\\) \\(p \\rightarrow q \\vDash_{0} q\\) \\(p \\wedge q \\vDash_{0}(p \\rightarrow r) \\wedge(q \\rightarrow r)\\) \\(p \\vee q \\vDash_{0}(p \\rightarrow r) \\vee(q \\rightarrow r)\\) \\(p \\leftrightarrow q \\vDash_{0} p\\) \\(p \\leftrightarrow q \\vDash_{0} q\\) 练习 3.15 用（简化）真值表说明具有下列形式的公式都是重言式： \\(\\varphi \\leftrightarrow \\neg \\neg \\varphi\\) \\(\\varphi \\rightarrow(\\psi \\rightarrow \\varphi)\\) \\(\\varphi \\rightarrow(\\neg \\varphi \\rightarrow \\psi)\\) \\(\\neg \\varphi \\rightarrow \\neg(\\varphi \\wedge \\psi)\\) \\(\\neg \\psi \\rightarrow \\neg(\\varphi \\wedge \\psi)\\) \\(\\neg(\\varphi \\vee \\psi) \\leftrightarrow \\neg \\varphi \\wedge \\neg \\psi\\) \\(\\neg(\\varphi \\wedge \\psi) \\leftrightarrow \\neg \\varphi \\vee \\neg \\psi\\) \\(\\neg(\\neg \\varphi \\rightarrow \\psi) \\rightarrow \\neg \\varphi\\) \\(\\neg(\\neg \\varphi \\rightarrow \\psi) \\rightarrow \\neg \\psi\\) \\((\\varphi \\rightarrow \\psi) \\rightarrow((\\varphi \\rightarrow \\neg \\psi) \\rightarrow \\neg \\varphi)\\) \\((\\varphi \\leftrightarrow \\psi) \\rightarrow(\\psi \\leftrightarrow \\varphi)\\) \\((\\varphi \\leftrightarrow(\\psi \\leftrightarrow \\chi)) \\leftrightarrow((\\varphi \\leftrightarrow \\psi) \\leftrightarrow \\chi)\\) \\(\\varphi \\vee\\left(\\psi_{0} \\wedge \\cdots \\wedge \\psi_{k}\\right) \\leftrightarrow\\left(\\varphi \\vee \\psi_{0}\\right) \\wedge \\cdots \\wedge\\left(\\varphi \\vee \\psi_{k}\\right)\\) \\(\\varphi \\wedge\\left(\\psi_{0} \\vee \\cdots \\vee \\psi_{k}\\right) \\leftrightarrow\\left(\\varphi \\wedge \\psi_{0}\\right) \\vee \\cdots \\vee\\left(\\varphi \\wedge \\psi_{k}\\right)\\) 练习 3.16 用（简化）真值表说明具有下列形式的公式都是矛盾式： \\(\\varphi \\wedge \\neg(\\neg \\varphi \\rightarrow \\psi)\\) \\((\\varphi \\rightarrow \\neg \\varphi) \\wedge(\\neg \\varphi \\rightarrow \\varphi)\\) \\((\\varphi \\vee \\psi) \\wedge(\\neg \\varphi \\wedge \\neg \\psi)\\) \\(\\neg(\\varphi \\rightarrow \\psi) \\wedge \\neg(\\psi \\rightarrow \\varphi)\\) \\((\\neg \\varphi \\rightarrow \\neg \\psi) \\wedge \\neg((\\neg \\varphi \\rightarrow \\psi) \\rightarrow \\varphi)\\) \\((\\varphi \\rightarrow(\\psi \\rightarrow \\chi)) \\wedge \\neg((\\varphi \\rightarrow \\psi) \\rightarrow(\\varphi \\rightarrow \\chi))\\) \\((\\varphi \\leftrightarrow \\psi) \\leftrightarrow(\\neg \\varphi \\leftrightarrow \\psi)\\) \\((\\varphi \\leftrightarrow \\psi) \\leftrightarrow(\\varphi \\leftrightarrow \\neg \\psi)\\) 练习 3.17 用（简化）真值表说明具有下列形式的公式都是或然式： \\(\\varphi \\rightarrow \\psi\\) \\(\\varphi \\rightarrow \\neg \\neg \\neg \\varphi\\) \\((\\psi \\rightarrow \\psi) \\rightarrow \\varphi\\) \\(\\neg \\varphi \\rightarrow \\neg(\\varphi \\vee \\psi)\\) \\(\\neg \\psi \\rightarrow \\neg(\\varphi \\vee \\psi)\\) \\((\\neg \\varphi \\rightarrow \\psi) \\rightarrow((\\varphi \\rightarrow \\psi) \\rightarrow \\neg \\psi)\\) \\((\\varphi \\leftrightarrow \\psi) \\rightarrow \\varphi \\wedge \\psi\\) \\((\\varphi \\leftrightarrow \\psi) \\rightarrow \\neg \\varphi \\wedge \\neg \\psi\\) 练习 3.18 设 \\(\\Gamma = \\lbrace \\varphi_0,...,\\varphi_n\\rbrace\\) 为任意的有穷公式集，\\(\\varphi\\) 为任意公式。给出下列命题成立的理由： 如果 \\(\\Gamma\\) 可满足，那么对任何公式集 \\(\\Delta\\)，\\(\\Gamma \\cap \\Delta\\)也可满足； 如果 \\(\\Gamma\\) 不可满足，那么对任何有穷公式集 \\(\\Delta\\)，\\(\\Gamma \\cup \\Delta\\)也不可满足； \\(\\Gamma \\cup \\lbrace \\neg \\varphi \\rbrace\\) 不可满足当且仅当 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)； 对任意 \\(i \\leqslant n\\)，\\(\\Gamma\\) 不可满足当且仅当 \\(\\Gamma - \\lbrace \\psi_i \\rbrace\\) 重言蕴涵\\(\\neg \\psi_i\\)； 如果 \\(\\Gamma\\) 不可满足，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)； 如果 \\(\\neg \\varphi\\) 不可满足，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)； 如果 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)，并且 \\(\\Gamma\\) 可满足，那么 \\(\\varphi\\) 也可满足； 如果 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\) 并且 \\(\\Gamma\\) 重言蕴涵 \\(\\neg \\varphi\\)，那么 \\(\\Gamma\\) 不可满足。 练习 3.19 设 \\(\\varphi, \\psi, \\varphi_0,...,\\varphi_n\\) 为任意公式且 \\(\\Gamma = \\lbrace \\varphi_0,...,\\varphi_n\\rbrace\\)。给出下列命题成立的理由： \\(\\varphi\\) 重言蕴涵 \\(\\psi\\) 当且仅当 \\(\\varphi \\rightarrow \\psi\\) 是重言式； \\(\\varphi\\) 重言等值于 \\(\\psi\\) 当且仅当 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式，当且仅当 \\(\\psi \\rightarrow \\varphi\\) 与 \\(\\varphi \\rightarrow \\psi\\) 都是重言式； \\(\\Gamma\\) 重言蕴涵 \\(\\psi\\) 当且仅当 \\(\\varphi_0 \\land \\cdots \\land \\varphi_n \\rightarrow \\psi\\) 是重言式； \\(\\varphi_0 \\land \\cdots \\land \\varphi_n \\rightarrow \\psi\\) 与 \\(\\varphi_0 \\land \\cdots \\land \\varphi_{n-1} \\rightarrow (\\varphi_n \\rightarrow \\psi)\\) 重言等值；（\\(n \\geqslant 1\\)） 如果 \\(\\varphi\\) 是重言式，那么 \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)； \\(\\Gamma\\) 可满足当且仅当 \\(\\varphi_0 \\land \\cdots \\land \\varphi_n\\) 或者是或然式或者是重言式； \\(\\Gamma\\) 不可满足当且仅当 \\(\\varphi_0 \\land \\cdots \\land \\varphi_n\\) 是矛盾式； 如果 \\(\\varphi\\) 是重言式，那么 \\(\\Gamma\\) 是可满足的当且仅当 \\(\\Gamma \\cup \\lbrace \\varphi \\rbrace\\) 是可满足的； 如果 \\(\\varphi_i (i \\leqslant n)\\) 是重言式，那么 \\(\\Gamma\\) 是可满足的当且仅当 \\(\\Gamma - \\lbrace \\varphi_i \\rbrace\\) 是可满足的； 如果 \\(\\varphi\\) 是矛盾式，那么 \\(\\Gamma \\cup \\lbrace \\varphi \\rbrace\\) 是不可满足的； 如果 \\(\\varphi_i (i \\leqslant n)\\) 是矛盾式，那么 \\(\\Gamma\\) 是不可满足的。 练习 3.20 将下列公式改写为使用波兰学派记法的公式。完成后，不看下列公式，把那些使用波兰学派记法的公式再改写成我们这个语言的公式，然后再和下列公式对照： \\(p \\rightarrow q \\vee p\\) \\(p \\rightarrow((p \\rightarrow q) \\rightarrow q)\\) \\(p \\wedge \\neg(\\neg p \\rightarrow q)\\) \\((p \\rightarrow \\neg p) \\wedge(\\neg p \\rightarrow p)\\) \\((p \\vee q) \\wedge(\\neg p \\wedge \\neg q)\\) \\(\\neg(p \\rightarrow q) \\wedge \\neg(q \\rightarrow p)\\) \\((q \\rightarrow q) \\rightarrow p\\) \\(q \\wedge \\neg q \\rightarrow p\\) \\((p \\vee q) \\wedge \\neg q \\rightarrow p\\) \\((q \\rightarrow \\neg p) \\rightarrow(p \\rightarrow \\neg q)\\) \\((r \\rightarrow(p \\rightarrow q)) \\rightarrow((r \\rightarrow p) \\rightarrow(r \\rightarrow q))\\) \\(\\neg p \\wedge \\neg q \\rightarrow \\neg(p \\vee q)\\) \\(\\neg p \\vee \\neg q \\rightarrow \\neg(p \\wedge q)\\) \\((\\neg p \\rightarrow \\neg q) \\wedge \\neg((\\neg p \\rightarrow q) \\rightarrow p)\\) \\((p \\rightarrow(q \\rightarrow r)) \\wedge \\neg((p \\wedge q) \\rightarrow(p \\vee r))\\) \\((p \\leftrightarrow q) \\rightarrow(\\neg p \\vee \\neg q)\\) \\((\\neg p \\vee q) \\rightarrow(p \\wedge q \\rightarrow \\neg q)\\) \\((p \\leftrightarrow q) \\rightarrow \\neg q \\wedge \\neg p\\) Editorial comments 有屁请在此处放，看看谁的屁更响。 "],["plsematics.html", " 4 语义概念的严格刻画 4.1 真值指派和公式的真值 4.2 重言蕴涵、重言等值与可满足性 4.3 代入 4.4 真值指派与真值表 4.5 范式 4.6 函数完全性 4.7 本章习题", " 4 语义概念的严格刻画 … in mathematics a mere moral conviction, supported by a mass of successful applications, is not good enough.Gottlob Frege, The Foundations of Arithmetic, 1884. Trans. by J. I. Austin 在这一章里，我们对命题逻辑的基本概念给出严格的表述，并对这些概念做进一步的讨论和说明。 离开了证明就没有当代逻辑。读者从这一章起开始学习写证明。无论读者原来对证明是否陌生，也无论读者是否认为证明全不足道，若要想真懂点逻辑而不只是侃点逻辑，那就不能绕过一个个定理及其证明。 4.1 真值指派和公式的真值 4.1.1 对象语言里的符号和公式 逻辑学家们常喜欢不把对象语言明明白白地写下来，而只是用我们熟悉的语言来描述它们。在§2.3.0（P.79）中介绍 \\(\\mathscr{L}_0\\)-符号时，我们说 \\(\\mathscr{L}_0\\)-符号有命题变号 \\(p_0, p_1,\\cdots\\) 和联结词 \\(\\neg, \\land, \\lor, \\rightarrow, \\leftrightarrow\\) 等。这并不等于说，对象语言里的命题变号看上去都是某种字体的英文字母表中第 16 个字母的小写形式，而且还有自然数下标。对象语言的命题变号到底什么样不是我们关心的问题，而这个语言中是否有表达自然数的符号更不是我们关心的问题——我们只是用我们的语言符号来表示那些命题变号，只是在我们的语言中把它们排成这样一个序列。类似地，对象语言中的否定号、蕴涵号是什么样子之类的问题都不是我们关心的问题。我们只是用 \\(\\neg\\) 和 \\(\\rightarrow\\) 等分别表示它们。 虽然我们熟悉的语言都有文字符号，但毕竟不是所有的语言都一定要有文字符号。我们至少可以想像：在某个遥远的与世隔绝的地方，生活着一个非常原始的部落，这个部落的人们还没有发明文字语言，他们之间的交流只是通过口头语言、动作和表情等进行。如果我们要学习、谈论或研究他们的语言，那么我们就是把他们的语言当作对象语言，因而自然地不能强求对象语言必须有文字符号。明白了这一点，即使我们使用的所有符号都是元语言符号也没有什么难以理解的。 我们把 \\(\\mathscr{L}_0\\) 的所有命题变号的集合记作 \\(\\mathbf{Pr}\\)，并把命题变号依下标排出的序 \\(p_0, p_1, p_2,\\cdots\\) 称为 \\(\\mathbf{Pr}\\) 上的（或命题变号的）「字典顺序」或「字母表」。 4.1.2 赋值、真、满足关系 语言 \\(\\mathscr{L}_{0}\\) 的解释叫做「真值指派」（truth valuation, truth assignment）。 （\\(\\mathbf{Pr}\\) 中 \\(n\\) 个命题的真值指派组合类型共 \\({\\prod_{i=1}^{n}} (C_{2}^{1})_i = 2^{n}\\) 种。） 定义 4.1 (赋值) 一个赋值（或真值指派）是从 \\(\\mathbf{Pr}\\) 到 \\(\\lbrace 0, 1\\rbrace\\) 的函数 \\(\\sigma\\)，它对每个命题变号 \\(p\\) 指派一个真值 \\(\\sigma(p).\\) 定义 4.2 (真) 对所有的 \\(\\mathscr{L}_0\\)-公式 \\(\\varphi\\)，我们用 \\(\\varphi^\\sigma\\) 表示 \\(\\varphi\\) 在 \\(\\sigma\\) 下的值。\\(\\varphi^\\sigma\\) 递归地定义如下（我们用「iff」表示「当且仅当」）： \\[ \\begin{array}{rcl} p_{n}^{\\sigma}=1 &amp; \\text{iff} &amp; \\sigma(p_{n})= 1 ~(n \\geqslant 0)\\\\ (\\neg \\psi)^{\\sigma}=1 &amp; \\text{iff} &amp; \\psi^{\\sigma} \\neq 1 ~(\\text {即}~ \\psi^{\\sigma}=0 ) \\\\ (\\psi \\vee \\chi)^{\\sigma}=1 &amp; \\text{iff} &amp; \\text {或者 }~ \\psi^{\\sigma}=1 \\text { 或者 }~ \\chi^{\\sigma}=1 \\\\ (\\psi \\wedge \\chi)^{\\sigma}=1 &amp; \\text{iff} &amp; \\psi^{\\sigma}=1 \\text{ 并且 }~ \\chi^{\\sigma}=1 \\\\ (\\psi \\rightarrow \\chi)^{\\sigma}=1 &amp; \\text{iff} &amp; \\text {或者 }~ \\psi^{\\sigma} \\neq 1 \\text{ 或者 }~ \\chi^{\\sigma}=1 \\\\ (\\psi \\leftrightarrow \\chi)^{\\sigma}=1 &amp; \\text{iff} &amp; \\psi^{\\sigma}=\\chi^{\\sigma} \\end{array} \\] 确定公式真值的这类定义通常被称作「真之定义（真理定义）」（truth definition）。对上述真理定义，我们有几点说明： 关于 \\(\\varphi^\\sigma\\) 的另一种等价的说法是把真值指派 \\(\\sigma\\) 扩充成一个满足上述条件的从 \\(\\mathscr{L}_0\\)-公式集到 \\(\\lbrace 0, 1\\rbrace\\) 的函数。 因真值指派就像是被指派为真的命题变号集合的特征函数（注：对任意集合 \\(X\\) 及其任意子集 \\(Y\\)，从 \\(X\\) 到 \\(\\lbrace 0, 1\\rbrace\\) 的函数 \\(f\\) 是 \\(Y\\) 的特征函数当且仅当对每个 \\(x \\in X\\)，如果 \\(x \\in Y\\) 则 \\(f(x) = 1\\)，并且如果 \\(x \\notin Y\\) 则 \\(f(x) = 0.\\) 在这种情况下，真值指派就成了真命题变号集合的特征函数。），人们常常把真值指派 \\(\\sigma\\) 直接定义为 \\(\\mathbf{Pr}\\) 的一个子集，亦即 \\(\\sigma \\subseteq \\mathbf{Pr}\\) （或者 \\(\\sigma \\in \\mathscr{P}(\\mathbf{Pr})\\)）（注：对任意集合 \\(X\\)，\\(\\mathscr{P}(X)\\) 表示 \\(X\\) 的幂集，即包含 \\(X\\) 的所有子集的集合 \\(\\lbrace Y: Y \\subseteq X\\rbrace\\)。），而把 \\(\\varphi^\\sigma\\) 递归定义的第一行也相应改为「\\(p_{n}^{\\sigma}=1~\\text{iff}~p_{n} \\in \\sigma (n \\geqslant 0)\\)」。 很多作者喜欢用「如果 \\(\\psi^{\\sigma} = 1\\) 那么 \\(\\chi^{\\sigma} = 1\\)」来替代上述递归定义第五行中的「或者 \\(\\psi^{\\sigma} \\neq 1\\) 或者 \\(\\chi^{\\sigma} = 1\\)」。 对照基本真值表 2.1 和定义 3.1 中第二至第六行，易见两者在真值计算方面表达的内容是一样的。定义 3.1 确定了一个真值指派下各个公式的值，而下述「满足」定义说的是一个真值指派满足一个公式集当且仅当它使该集合中所有公式的值为 1. 定义 4.3 (满足) 令 \\(\\Gamma\\) 为任意 \\(\\mathscr{L}_0\\)-公式集（可以是无穷集），并令 \\(\\sigma\\) 为任意真值指派。 \\(\\sigma\\) 满足 \\(~\\Gamma\\)（符号表示：\\(\\sigma \\vDash \\Gamma\\)）当且仅当对每个 \\(\\varphi \\in \\Gamma\\)，\\(\\varphi^\\sigma = 1.\\) 我们用 \\(\\sigma \\vDash \\varphi\\) 表示 \\(\\sigma \\vDash \\lbrace \\varphi\\rbrace\\)，并用 \\(\\sigma \\nvDash \\Gamma\\) 和 \\(\\sigma \\nvDash \\varphi\\) 分别表示 \\(\\sigma \\vDash \\Gamma\\) 和 \\(\\sigma \\vDash \\varphi\\) 不成立。 由上述定义可知下列等值式成立： \\(\\sigma \\vDash \\varphi\\) 当且仅当 \\(\\varphi^\\sigma = 1;\\) （「\\(\\vDash\\)」读作 “double-turnstile.”） \\(\\sigma \\nvDash \\varphi\\) 当且仅当 \\(\\varphi^\\sigma = 0;\\) \\(\\sigma \\vDash \\Gamma\\) 当且仅当对所有 \\(\\varphi \\in \\Gamma, \\sigma \\vDash \\varphi;\\) \\(\\sigma \\nvDash \\Gamma\\) 当且仅当对某些 \\(\\varphi \\in \\Gamma, \\sigma \\nvDash \\varphi.\\) 当 \\(\\Gamma = \\varnothing\\)（空集）时，\\(\\Gamma\\) 是否被一真值指派满足是一种「极限」情况。事实上，对每个真值指派 \\(\\sigma\\) 都有 \\(\\sigma \\vDash \\varnothing.\\) 这是因为，既然 \\(\\varnothing\\) 是空集，那么就不存在 \\(\\varnothing\\) 中的公式 \\(\\varphi\\) 使得 \\(\\sigma \\nvDash \\varphi,\\) 也就是说对每一个 \\(\\varphi \\in \\Gamma, \\sigma \\vDash \\varphi.\\) 3.6 中引入的一些基本语义概念，都是用真值表刻画的。真值表刻画在某种程度上依赖于读者对图形的直观。下面我们不借助这种直观，仅仅运用真值指派和满足关系这些概念，对 3.6 中引入的基本语义概念进行严格的定义。 4.2 重言蕴涵、重言等值与可满足性 「逻辑蕴涵」是逻辑学的核心观念之一，我们将在后续章节中讨论它，这里先讨论它在命题逻辑中的简单形式——「重言蕴涵」。在不产生歧义时，我们将省略前缀 「\\(\\mathscr{L}_0\\)-」。 4.2.1 重言蕴涵 在 3.6 中，\\(\\lbrace \\varphi_0,\\cdots,\\varphi_n \\rbrace\\) 重言蕴涵（tautologically implies） \\(\\psi\\) 当且仅当在 \\(\\varphi_0,\\cdots,\\varphi_n\\) 与 \\(\\psi\\) 的联合真值表中，没有一行是 \\(\\varphi_0,\\cdots,\\varphi_n\\) 都真而 \\(\\psi\\) 假。这是其联合真值表角度的定义。下面我们从赋值与满足出发，重新严格刻画重言蕴涵。 定义 4.4 (重言蕴涵) 令 \\(\\Gamma\\) 为任意公式集（可以是无穷的），并且 \\(\\varphi\\) 为任意公式。 \\(\\Gamma \\vDash_{0} \\varphi\\)（ \\(\\Gamma\\) 重言蕴涵 \\(\\varphi\\)）当且仅当对每一个真值指派 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\Gamma\\) 则 \\(\\sigma \\vDash \\varphi.\\) \\(\\varphi\\) 是 \\(\\Gamma\\) 的重言后承当且仅当 \\(\\Gamma \\vDash_{0} \\varphi.\\) （皆指 \\(\\mathscr{L}_{0}\\) 中） 当 \\(\\Delta=\\lbrace \\varphi_0,\\cdots,\\varphi_n\\rbrace\\) 时，用 \\(\\varphi_0,\\cdots,\\varphi_n \\vDash_{0} \\varphi\\) 表示 \\(\\Delta \\vDash_{0} \\varphi\\)，用 \\(\\Gamma, \\varphi_0,\\cdots,\\varphi_n \\vDash_{0} \\varphi\\) 表示 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\varphi\\)。当 \\(\\Delta=\\varnothing\\) 时，我们用 \\(\\vDash_{0} \\varphi\\) 表 示 \\(\\Delta \\vDash_{0} \\varphi.\\) Remark: 定义 4.4 和 3.6 中重言蕴涵的真值表刻画有所不同。不同之处有以下两点： \\(\\Gamma\\) 在这里可以是无穷集合，而在重言蕴涵等概念的真值表刻画中，\\(\\Gamma\\) 被限定为有穷集合。 真值指派要对所有命题变号给出真值，并且在定义重言蕴涵等语义概念时，定义涉及的真值指派显然有无穷多个；而用真值表刻画这些基本语义概念时，只需考虑给定公式中出现的有穷多个命题变号的真假，而且这些命题变号的可能取值组合也只有有穷多个。 从现在起，读者要学习证明。我们先证明一些简单的命题，且给出的证明也尽量详细。读者应对照定义来阅读以下的例子、命题及其证明，同时不要忽略本章后面的证明练习。 例 4.1 对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi \\vee \\psi, \\neg \\varphi \\vDash_{0} \\psi.\\) Proof: 令 \\(\\sigma\\) 为任意真值指派。假设 \\(\\sigma \\vDash \\varphi \\lor \\psi\\) 且 \\(\\sigma \\vDash \\neg \\varphi\\)（以下证明 \\(\\sigma \\vDash \\psi\\)）根据真之定义，由假设 \\(\\sigma \\vDash \\varphi \\lor \\psi\\) 得知或者 $$或者 \\(\\sigma \\vDash \\psi\\)，再由假设 \\(\\sigma \\vDash \\neg \\varphi\\) 得知 \\(\\sigma \\nvDash \\varphi\\)，从而有 \\(\\sigma \\vDash \\psi\\) 所以，对每个真值指派 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\varphi \\lor \\psi\\) 且 \\(\\sigma \\vDash \\neg \\varphi\\)，那么 \\(\\sigma \\vDash \\psi.\\) 根据重言蕴涵的定义，\\(\\varphi \\vee \\psi, \\neg \\varphi \\vDash_{0} \\psi.\\) 例 4.2 对所有公式 \\(\\varphi, \\psi\\) 和 \\(\\chi\\)，\\(\\varphi \\rightarrow \\psi, \\psi \\rightarrow \\chi \\vDash_{0} \\varphi \\rightarrow \\chi.\\) Proof: 令 \\(\\sigma\\) 为任意真值指派。假设（i）\\(\\sigma \\vDash \\varphi \\rightarrow \\psi\\) 且（ii）\\(\\sigma \\vDash \\psi \\rightarrow \\chi\\)（以下证明 \\(\\varphi \\rightarrow \\chi\\)）如果 \\(\\sigma \\nvDash \\varphi\\)，则 \\(\\varphi^\\sigma \\ne 1\\)，那么根据真理定义，\\(\\sigma \\vDash \\varphi \\rightarrow \\chi.\\) 所以，假设（ii）\\(\\sigma \\vDash \\varphi.\\) 根据真理定义和（iii），由（i）得到 \\(\\sigma \\vDash \\psi\\)，再由（ii）得到 \\(\\sigma \\vDash \\chi\\)，从而有 \\(\\sigma \\vDash \\varphi \\rightarrow \\chi.\\)由此可知，对每个 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\varphi \\rightarrow \\psi\\) 且 \\(\\sigma \\vDash \\psi \\rightarrow \\chi\\)，那么 \\(\\sigma \\vDash \\varphi \\rightarrow \\chi.\\) 根据重言蕴涵的定义，\\(\\varphi \\rightarrow \\psi, \\psi \\rightarrow \\chi \\vDash_{0} \\varphi \\rightarrow \\chi.\\) 命题 4.1 对所有公式集 \\(\\Gamma\\) 和所有公式 \\(\\varphi\\)，如果 \\(\\varphi \\in \\Gamma\\) 则 \\(\\Gamma \\vDash_{0} \\varphi.\\) Proof: 对每个真值指派 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\Gamma\\)，那么根据定义 3.2，\\(\\sigma\\) 满足 \\(\\Gamma\\) 中所有公式，由 \\(\\varphi \\in \\Gamma\\) 得到 \\(\\sigma \\vDash \\varphi.\\) 所以，根据重言蕴涵的定义，\\(\\Gamma \\vDash_{0} \\varphi.\\) 命题 4.2 对所有公式集 \\(\\Gamma\\) 和所有公式 \\(\\varphi, \\psi\\)，\\(\\Gamma, \\varphi \\vDash_{0} \\psi\\) 当且仅当 \\(\\Gamma \\vDash_{0} \\varphi \\rightarrow \\psi.\\) Proof: 假设 \\(\\Gamma \\nvDash_{0} \\varphi \\rightarrow \\psi.\\) 根据重言蕴涵的定义，存在真值指派 \\(\\sigma\\) 使得 \\(\\sigma \\vDash \\Gamma\\) 并且 \\(\\sigma \\nvDash \\varphi \\rightarrow \\psi\\)，亦即 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\nvDash \\psi\\)，从而得到 \\(\\sigma \\vDash \\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 且 \\(\\sigma \\nvDash_{0} \\psi.\\) 再根据重言蕴涵的定义得知 \\(\\Gamma, \\varphi \\nvDash_{0} \\psi.\\) 假设 \\(\\Gamma \\vDash_{0} \\varphi \\rightarrow \\psi.\\) 令 \\(\\sigma\\) 为任意真值指派。如果 \\(\\sigma \\vDash \\Gamma \\cup\\lbrace \\varphi\\rbrace\\)，则 \\(\\sigma \\vDash \\Gamma\\) 且 \\(\\sigma \\vDash \\varphi\\)，于是由假设和重言蕴涵的定义得知 \\(\\sigma \\vDash \\varphi \\rightarrow \\psi\\) 且 \\(\\sigma \\vDash \\varphi\\)，进而再由真理定义得到 \\(\\sigma \\vDash \\psi.\\) 所以，根据重言蕴涵的定义，\\(\\Gamma, \\varphi \\vDash_{0} \\psi.\\)（「当且仅当」证法之例） 命题 4.3 对所有公式集 \\(\\Gamma, \\varphi_0,\\cdots,\\varphi_n \\vDash_{0} \\psi\\) 并且对所有 \\(i \\leqslant n\\)，\\(\\Delta \\vDash_{0} \\varphi_i.\\) 我们有 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\psi.\\) Proof: 令 \\(\\sigma\\) 为任意真值指派，并设 \\(\\sigma \\vDash \\Gamma \\cup \\Delta.\\) 根据满足的定义，对所有的 \\(\\varphi \\in \\Gamma \\cup \\Delta\\) 都有 \\(\\sigma \\vDash \\varphi\\)，因而对所有的 \\(\\varphi \\in \\Gamma\\) 都有 \\(\\sigma \\vDash \\varphi\\)，并且对所有的 \\(\\varphi \\in \\Delta\\) 都有 \\(\\sigma \\vDash \\varphi.\\) 所以（i）\\(\\sigma \\vDash \\Gamma\\)，（ii）\\(\\sigma \\vDash \\Delta.\\) 令 \\(i \\leqslant n.\\) 根据题设，\\(\\Delta \\vDash_{0} \\varphi_i;\\) 再根据（ii）和重言蕴涵的定义， \\(\\sigma \\vDash \\varphi_i.\\) 因为这对 \\(i = 0,\\cdots,n\\) 都成立，所以由（i）和满足定义得到 \\(\\sigma \\vDash \\Gamma \\cup \\lbrace \\varphi_0,\\cdots,\\varphi_n\\rbrace\\)，再运用题设和重言蕴涵的定义，我们得到 \\(\\sigma \\vDash \\psi.\\) 所以，由重言蕴涵的定义得知 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\psi.\\) 4.2.2 重言等值 在§2.5.2（P.87）中，任意公式 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值（tautologically equivalent） 当且仅当在 \\(\\varphi\\) 与 \\(\\psi\\) 联合真值表的任意一行中，\\(\\varphi\\) 与 \\(\\psi\\) 有同样的真值。其赋值视角的定义如下： {{% dtpc title=“☯定义 3.4【重言等值】” %}} \\(\\mathscr{L}_{0}\\)-公式 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当对每个真值指派 \\(\\sigma\\)，\\(\\varphi^\\sigma = \\psi^\\sigma.\\) {{% /dtpc %}} 易见：如果 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值，那么对每个真值指派 \\(\\sigma\\)，\\(\\sigma \\vDash \\varphi\\) 当且仅当 \\(\\sigma \\vDash \\psi;\\) 反之亦然。 例 3.2 对任意公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi \\rightarrow \\psi\\) 与 \\(\\neg\\varphi \\lor \\psi\\) 重言等值。 证明：令 \\(\\sigma\\) 为任意真值指派。根据真理定义，\\(\\sigma \\vDash \\varphi \\rightarrow \\psi\\) 当且仅当 \\(\\sigma \\nvDash \\varphi\\) 或者 \\(\\sigma \\vDash \\psi\\)，当且仅当 \\(\\sigma \\vDash \\neg \\varphi\\) 或者 \\(\\sigma \\vDash \\psi\\)，当且仅当 \\(\\sigma \\vDash \\neg \\varphi \\lor \\sigma \\psi\\)。根据重言等值定义，\\(\\varphi \\rightarrow \\psi\\) 与\\(\\neg\\varphi \\lor \\psi\\) 重言等值。▗ 例 3.3 对任意公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi \\leftrightarrow \\psi\\) 与 \\((\\varphi \\land \\psi) \\lor (\\neg\\varphi \\land \\neg\\psi)\\) 重言等值。 证明：令 \\(\\sigma\\) 为任意真值指派。根据真理定义，\\(\\sigma \\vDash \\varphi \\leftrightarrow \\psi\\) 当且仅当：或者 \\(\\varphi^\\sigma = \\psi^\\sigma = 1\\)，或者 \\(\\varphi^\\sigma = \\psi^\\sigma = 0;\\) 当且仅当 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\vDash \\psi\\)，或者 \\(\\sigma \\nvDash \\varphi\\) 且 \\(\\sigma \\nvDash \\psi.\\) 于是由真理定义得到 \\[ \\begin{array}{rcl} \\sigma \\vDash \\varphi \\leftrightarrow \\psi &amp; \\text{iff} &amp; \\text{或者}~ \\sigma \\vDash \\varphi \\land \\psi ~\\text{或者}~ \\sigma \\vDash \\neg\\varphi \\land \\neg\\psi \\\\ &amp; \\text{iff} &amp; \\sigma \\vDash (\\varphi \\land \\psi) \\lor (\\neg\\varphi \\land \\neg\\psi) \\end{array} \\] 所以由重言等值的定义，\\(\\varphi \\leftrightarrow \\psi\\) 与 \\((\\varphi \\land \\psi) \\lor (\\neg\\varphi \\land \\neg\\psi)\\) 重言等值。 ▗ {{% dtpc title=“☯命题 3.3” %}} 对所有公式集 \\(\\Gamma\\) 以及所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，如果 \\(\\Gamma \\vDash_{0} \\varphi\\) 并且 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值，那么 \\(\\Gamma \\vDash_{0} \\psi.\\) {{% /dtpc %}} 命题 3.3 之证明：设 \\(\\Gamma \\vDash_{0} \\varphi\\) 并且 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值。令 \\(\\sigma\\) 为任意真值指派。如果 \\(\\sigma \\vDash \\Gamma\\)，那么由 \\(\\Gamma \\vDash_{0} \\varphi\\) 和重言蕴涵的定义得知 \\(\\sigma \\vDash \\varphi\\)，再由重言等值的定义得到 \\(\\sigma \\vDash \\psi.\\) 所以，再根据重言蕴涵定义，\\(\\Gamma \\vDash_{0} \\psi.\\) ▗ {{% dtpc title=“☯命题 3.4” %}} 对所有所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当 \\(\\varphi \\vDash_{0} \\psi\\) 并且 \\(\\psi \\vDash_{0} \\varphi.\\) {{% /dtpc %}} 命题 3.4 之证明：设 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值。对每一个真值指派 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\varphi\\)，那么由于 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值，可知 \\(\\sigma \\vDash \\psi.\\) 这就是说，\\(\\varphi \\vDash_{0} \\psi.\\) 同理可证 \\(\\psi \\vDash_{0} \\varphi.\\) 设 \\(\\varphi \\vDash_{0} \\psi\\) 且 \\(\\psi \\vDash_{0} \\varphi.\\) 根据此假设和重言蕴涵的定义， （i）对每个真值指派 \\(\\sigma_1\\)，如果 \\(\\sigma_1 \\vDash \\varphi\\) 则 \\(\\sigma_1 \\vDash \\psi.\\) （ii）对每个真值指派 \\(\\sigma_2\\)，如果 \\(\\sigma_2 \\vDash \\psi\\) 则 \\(\\sigma_2 \\vDash \\varphi.\\) 令 \\(\\sigma\\) 为任意真值指派。由（i）知：如果如果 \\(\\sigma \\vDash \\varphi\\) 则 \\(\\sigma \\vDash \\psi;\\) 由（ii）知：如果 \\(\\sigma \\vDash \\psi\\) 则 \\(\\sigma \\vDash \\varphi.\\) 从而 \\(\\sigma \\vDash \\varphi\\) 当且仅当 \\(\\sigma \\vDash \\psi.\\) 根据重言等值的定义，\\(\\varphi\\) 与 \\(\\psi\\) 重言等值。▗ 4.2.3 可满足性 在§2.5.3（P.88）中，从联合真值表角度看，任意有穷公式集 \\(\\Gamma\\) 可满足（satisfiable）当且仅当 \\(\\Gamma\\) 中公式的联合真值表中存在某一行，在该行里 \\(\\Gamma\\) 中的公式的真值都是 1. 下面我们从赋值与满足出发，重新严格刻画重言蕴涵。 {{% dtpc title=“☯定义 3.5【可满足】” %}} 令 \\(\\Gamma\\) 为任意公式集（可以是无穷集），\\(\\varphi\\) 为任意 \\(\\mathscr{L}_{0}\\)-公式。\\(\\Gamma\\) 是可满足的当且仅当存在一个真值指派 \\(\\sigma\\) 使得 \\(\\sigma \\vDash \\Gamma;\\) \\(\\varphi\\) 是可满足的当且仅当 \\(\\lbrace \\varphi\\rbrace\\) 是可满足的。\\(\\Gamma\\)（或 \\(\\varphi\\)）是不可满足的当且仅当它不是可满足的。 {{% /dtpc %}} Note 3.1 与注 3.0（P.101）中提到的情况类似，定义 3.4 和定义 3.5 不同于§2.5.2（P.87）和§2.5.3（P.88）中重言等值和可满足性的真值表刻画。关于重言等值，其定义和真值表刻画的不同是注 3.0 中讲的第二点；而关于可满足性，其定义和真值表刻画的不同是注 3.0 中讲的两点。 例 3.4 设 \\(\\Gamma=\\left\\lbrace p \\vee q, r \\wedge s, p \\rightarrow r \\wedge r^{\\prime}, s^{\\prime} \\leftrightarrow(\\neg q \\rightarrow \\neg s)\\right\\rbrace.\\) 我们有： \\(\\Gamma\\) 可满足。 证明：令 \\(\\sigma\\) 为如下定义的真值指派： （i） \\(\\sigma(p)=\\sigma(r)=\\sigma(s)=\\sigma(r^{\\prime})=1\\) （ii）\\(\\sigma(q)=\\sigma(s^{\\prime})=0\\) （iii）对所有与 \\(p, q, r, s, r^{\\prime}\\)， \\(s^{\\prime}\\) 不同的命题变号 \\(p^{\\prime}\\)， \\(\\sigma(p^{\\prime})=0.\\) 由真理定义和（i）知，\\(\\sigma \\vDash p \\vee q\\) 且 \\(\\sigma \\vDash r \\wedge s.\\) 类似地， \\(\\sigma \\vDash r \\wedge r^{\\prime}\\) 进而 \\(\\sigma \\vDash p \\rightarrow r \\wedge r^{\\prime}.\\) 由真理定义和（i）知 \\(\\sigma \\not=\\neg s\\)， 并由（ii）知 \\(\\sigma \\vDash \\neg q\\)，进而 \\(\\sigma \\nvDash \\neg q \\rightarrow \\neg s;\\) 再由（ii）知 \\(\\sigma \\nvDash s^{\\prime}.\\) 所以 $ s^{} (q s).$ 综上所述， \\(\\sigma \\vDash \\Gamma.\\) ▗ 例 3.5 设 \\(q_{0}, q_{1},\\cdots\\) 为任意命题变号，满足对所有 \\(i, j \\geqslant 0\\)，如果 \\(i \\neq j\\) 则 \\(q_{i} \\neq q_{j};\\) 并设 \\(\\Gamma=\\left\\lbrace q_{2k} \\rightarrow \\neg q_{2k+1}: k \\geqslant 0\\right\\rbrace\\) 且 \\(\\Delta=\\left\\lbrace \\neg q_{2k+1} \\rightarrow q_{2k+2}: k \\geqslant 0\\right\\rbrace\\)。我们有：\\(\\left\\lbrace q_{0}\\right\\rbrace \\cup \\Gamma \\cup \\Delta\\) 可满足。 证明：令 \\(\\sigma\\) 为下列真值指派：对每个命题变号 \\(p\\)， \\[ \\sigma(p)= \\left\\lbrace \\begin{array}{ll} 1 &amp; \\text{如果存在}~ k \\geqslant 0 ~\\text{使得}~ p=q_{2 k} \\\\ 0 &amp; \\text{否则} \\end{array} \\right. \\] 显然，\\(\\sigma \\vDash q_{0}.\\) 对任意 \\(k \\geqslant 0\\)，由上述定义知 \\(\\sigma \\nvDash q_{2k+1}\\) 且 \\(\\sigma \\vDash q_{2k+2}\\)，从而根据真理定义，\\(\\sigma \\vDash \\neg q_{2k+1}\\) 进而 \\(\\sigma \\vDash q_{2k} \\rightarrow \\neg q_{2k+1}\\) 且 \\(\\sigma \\vDash \\neg q_{2k+1} \\rightarrow q_{2k+2}.\\) 所以，\\(\\sigma \\vDash\\left\\lbrace q_{0}\\right\\rbrace \\cup \\Gamma \\cup \\Delta.\\) ▗ {{% dtpc title=“☯命题 3.5” %}} 对所有公式集 \\(\\Gamma\\)，如果 \\(\\Gamma\\) 不可满足，那么对每个公式 \\(\\varphi\\)，\\(\\Gamma \\vDash_{0} \\varphi.\\) {{% /dtpc %}} 命题 3.5 之证明：假设 \\(\\Gamma\\) 不可满足且令 \\(\\varphi\\) 为任意公式。假如 \\(\\Gamma \\nvDash_{0} \\varphi\\)，那么就存在真值指派 \\(\\sigma\\) 使得 \\(\\sigma \\vDash \\Gamma\\) 且 \\(\\sigma \\nvDash \\varphi\\)，但这是不可能的，因为 \\(\\Gamma\\) 不可满足。▗ {{% dtpc title=“☯命题 3.6” %}} 对所有公式集 \\(\\Gamma\\) 和所有公式 \\(\\varphi\\)，\\(\\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 不可满足当且仅当 \\(\\Gamma \\vDash_{0} \\neg \\varphi\\)，并且 \\(\\Gamma \\cup \\lbrace \\neg \\varphi\\rbrace\\) 不可满足当且仅当 \\(\\Gamma \\vDash_{0} \\varphi.\\) {{% /dtpc %}} 命题 3.6 之证明：只证第一部分。设 \\(\\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 不可满足并令 \\(\\sigma\\) 为任意真值指派。因为 \\(\\sigma \\nvDash \\Gamma \\cup \\lbrace \\varphi\\rbrace\\) ，所以，如果 \\(\\sigma \\vDash \\Gamma\\) 则 \\(\\sigma \\nvDash \\varphi\\)，由真理定义得知，如果 \\(\\sigma \\vDash \\Gamma\\) 则 \\(\\sigma \\vDash \\neg \\varphi\\)，进而由重言蕴涵定义得知 \\(\\Gamma \\vDash_{0} \\neg \\varphi.\\) 设 \\(\\Gamma \\vDash_{0} \\neg \\varphi\\)，令 \\(\\sigma\\) 为任意真值指派。易见，如果 \\(\\sigma \\vDash \\Gamma\\)，则由重言蕴涵的定义知 \\(\\sigma \\vDash \\neg \\varphi\\)，从而 \\(\\sigma \\nvDash \\varphi\\)，这就是说，\\(\\sigma \\nvDash \\Gamma \\cup \\lbrace \\varphi\\rbrace.\\) 即 \\(\\Gamma \\cup \\lbrace \\varphi\\rbrace\\) 不可满足。 ▗ 4.2.4 重言式、矛盾式与或然式 在§2.5.4（P.88）中，重言式、矛盾式与或然式曾被以真值表的方式刻画，下面从赋值角度严格刻画这组概念。 {{% dtpc title=“☯定义 3.6【重言式】” %}} 对任意 \\(\\mathscr{L}_{0}\\)-公式 \\(\\varphi\\)，\\(\\varphi\\) 是重言式当且仅当对每一个真值指派 \\(\\sigma\\)，\\(\\sigma \\vDash \\varphi.\\) {{% /dtpc %}} {{% dtpc title=“☯定义 3.7【矛盾式】” %}} 对任意 \\(\\mathscr{L}_{0}\\)-公式 \\(\\varphi\\)，\\(\\varphi\\) 矛盾式（或不可满足式）当且仅当对每一个真值指派 \\(\\sigma\\)，\\(\\sigma \\nvDash \\varphi.\\) {{% /dtpc %}} {{% dtpc title=“☯定义 3.8【或然式】” %}} 对任意 \\(\\mathscr{L}_{0}\\)-公式 \\(\\varphi\\)，\\(\\varphi\\) 或然式当且仅当对每一个真值指派 \\(\\sigma\\) 使得 \\(\\sigma \\vDash \\varphi\\)，\\(\\sigma \\nvDash \\varphi\\)，并且存在一个真值指派 \\(\\sigma^\\prime\\)，使得 \\(\\sigma^\\prime \\nvDash \\varphi.\\) {{% /dtpc %}} Note 3.2 与重言蕴涵、重言等值和可满足性等概念的情况类似，定义 3.6-3.8 有别于§2.5.4（P.88）中对重言式等概念的真值表刻画：真值指派要对所有命题变号给出真值，并且重言式等的定义涉及的真值指派显然有无穷多个；这些概念的真值表刻画却不同，它们只考虑公式中出现的有穷多个命题变号的真假，而这些命题变号的可能取值组合也只有有穷多个。 例 3.6 对任意公式 \\(\\varphi\\)，\\(\\varphi \\lor \\varphi \\rightarrow \\varphi\\) 是重言式。 证明：令 \\(\\sigma\\) 为任意真值指派。如果 \\(\\sigma \\vDash \\varphi \\lor \\varphi\\)，那么根据真理定义，\\(\\sigma \\vDash \\varphi\\)，进而 \\(\\sigma \\vDash \\varphi \\lor \\varphi \\rightarrow \\varphi.\\) 由重言式的定义知，\\(\\varphi \\lor \\varphi \\rightarrow \\varphi\\) 是重言式。▗ 例 3.7 对任意公式 \\(\\varphi, \\psi\\)，\\(\\neg(\\varphi \\rightarrow \\psi) \\rightarrow \\varphi \\land \\neg \\psi\\) 是重言式。 证明：令 \\(\\sigma\\) 为任意真值指派。假设 \\(\\sigma \\vDash \\neg(\\varphi \\rightarrow \\psi).\\) 根据真理定义，\\(\\sigma \\nvDash \\varphi \\rightarrow \\psi\\)，从而有 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\nvDash \\psi.\\) 于是，\\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\vDash \\neg\\psi\\)，进而 \\(\\sigma \\vDash \\varphi \\land \\neg \\psi.\\) 由此得知，对任意真值指派 \\(\\sigma\\)，\\(\\sigma \\vDash \\neg(\\varphi \\rightarrow \\psi) \\rightarrow \\varphi \\land \\neg \\psi.\\) 根据重言式的定义，\\(\\neg(\\varphi \\rightarrow \\psi) \\rightarrow \\varphi \\land \\neg \\psi\\) 是重言式。▗ 例 3.8 对任意公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\varphi \\land \\neg (\\varphi \\lor \\psi)\\) 是矛盾式。 证明：令 \\(\\sigma\\) 为任意真值指派。根据真理定义，如果 \\(\\sigma \\vDash \\varphi \\land \\neg (\\varphi \\lor \\psi)\\)，那么 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\vDash \\neg (\\varphi \\lor \\psi)\\)，从而 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\nvDash \\varphi\\)，但这是不可能的。所以，\\(\\sigma \\nvDash \\varphi \\land \\neg (\\varphi \\lor \\psi).\\) 根据矛盾式的定义，\\(\\varphi \\land \\neg (\\varphi \\lor \\psi)\\) 是矛盾式。▗ 例 3.9 对任意公式 \\(\\varphi\\)，\\(\\neg(\\varphi \\rightarrow \\neg (\\varphi \\rightarrow \\neg\\varphi))\\) 是矛盾式。 证明：令 \\(\\sigma\\) 为任意真值指派。假设 \\(\\sigma \\vDash \\neg(\\varphi \\rightarrow \\neg (\\varphi \\rightarrow \\neg\\varphi)).\\) 根据真理定义，我们有 \\(\\sigma \\nvDash \\varphi \\rightarrow \\neg (\\varphi \\rightarrow \\neg\\varphi)\\)，从而 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\nvDash \\neg (\\varphi \\rightarrow \\neg\\varphi)\\)，进而 \\(\\sigma \\vDash \\varphi \\rightarrow \\neg\\varphi.\\) 易见 \\(\\sigma \\vDash \\varphi\\) 并且 \\(\\sigma \\vDash \\neg \\varphi\\)，亦即 \\(\\sigma \\vDash \\varphi\\) 并且 \\(\\sigma \\nvDash \\varphi\\)，但这是不可能的。所以，\\(\\sigma \\nvDash \\neg(\\varphi \\rightarrow \\neg (\\varphi \\rightarrow \\neg\\varphi)).\\) 根据矛盾式的定义，\\(\\neg(\\varphi \\rightarrow \\neg (\\varphi \\rightarrow \\neg\\varphi))\\) 是矛盾式。▗ 例 3.10 对所有不同的命题变号 \\(p\\) 和 \\(q\\)，\\(p \\land \\neg q\\) 是或然式。 证明：令 \\(p\\) 和 \\(q\\) 为不同的命题变号。并且令 \\(\\sigma\\) 为任意真值指派，满足 \\(\\sigma(p)=1\\) 且 \\(\\sigma(q)=0.\\) 根据真理定义，\\(\\sigma \\vDash p \\land \\neg q.\\) 令 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足 \\(\\sigma^{\\prime}(p)=0.\\) 由于 \\(\\sigma^{\\prime} \\nvDash p\\)，所以根据真理定义，\\(\\sigma^{\\prime} \\nvDash p \\land \\neg q.\\) 由或然式定义得知，\\(p \\land \\neg q\\) 是或然式。 ▗ 例 3.11 对所有不同的命题变号 \\(p\\) 和 \\(q\\)，\\(p \\rightarrow \\neg q\\) 是或然式。 证明：令 \\(p\\) 和 \\(q\\) 为不同的命题变号。并且令 \\(\\sigma\\) 和 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足 \\(\\sigma(p)=0\\) 且 \\(\\sigma^{\\prime}(p)=\\sigma^{\\prime}(q)=1.\\) 根据真理定义，易见 \\(\\sigma \\vDash p \\rightarrow \\neg q\\) 并且 \\(\\sigma^{\\prime} \\nvDash p \\rightarrow \\neg q.\\) 由或然式定义得知，\\(p \\rightarrow \\neg q\\) 是或然式。 ▗ 下列命题是对上述概念的简单运用。以下仅列出部分命题的证明，剩余的命题证明留作习题。 {{% dtpc title=“☯命题 3.7” %}} 令 \\(\\varphi\\) 和 \\(\\varphi\\) 为任意公式。我们有： 1. \\(\\varphi \\land \\psi\\) 是重言式当且仅当 \\(\\varphi\\) 是重言式并且 \\(\\varphi\\) 是重言式。 证明：设 \\(\\varphi \\land \\psi\\) 是重言式。对每个真值指派 \\(\\sigma\\)，由假设和重言式的定义得知 \\(\\sigma \\vDash \\varphi \\land \\psi\\)，进而根据真理定义，\\(\\sigma \\vDash \\varphi.\\) 所以 \\(\\varphi\\) 是重言式。同理可证 \\(\\psi\\) 是重言式。另一方面，设 \\(\\varphi\\) 和 \\(\\psi\\) 都是重言式。对每个真值指派 \\(\\sigma\\)，由假设和重言式定义知 \\(\\sigma \\vDash \\varphi\\) 且 \\(\\sigma \\vDash \\psi\\)，再由真理定义知 \\(\\sigma \\vDash \\varphi \\land \\psi.\\) 所以 \\(\\varphi \\land \\psi\\) 是重言式。▗ 1. 如果 \\(\\varphi\\) 或 \\(\\psi\\) 是重言式，那么 \\(\\varphi \\lor \\psi\\) 是重言式；但逆命题不成立。 证明： 设 \\(\\varphi\\) 或 \\(\\psi\\) 是重言式。第一种情况：\\(\\varphi\\) 是重言式。对每个真值指派 \\(\\sigma\\)，既然 \\(\\varphi\\) 是重言式，我们有 \\(\\sigma \\vDash \\varphi\\)，再由真理定义知 \\(\\sigma \\vDash \\varphi \\lor \\psi.\\) 所以 \\(\\varphi \\lor \\psi\\) 是重言式。第二种情况类似。逆命题不成立：当 \\(\\varphi = p\\) 且 \\(\\psi = \\neg p\\) 时，\\(\\varphi \\lor \\psi\\) 是重言式，但 \\(\\varphi\\) 和 \\(\\psi\\) 都不是重言式。▗ 1. 如果 \\(\\varphi \\rightarrow \\psi\\) 是重言式，那么，或者 \\(\\varphi\\) 不是重言式或者 \\(\\psi\\) 是重言式；但逆命题不成立。 证明：设 \\(\\varphi \\rightarrow \\psi\\) 是重言式。如果 \\(\\varphi\\) 是重言式，那么，对每个真值指派 \\(\\sigma\\)，\\(\\sigma \\vDash \\varphi \\rightarrow \\psi\\) 并且 \\(\\sigma \\vDash \\varphi\\)，从而由真理定义知 \\(\\sigma \\vDash \\psi\\)。所以，或者 \\(\\varphi\\) 不是重言式或者 \\(\\psi\\) 是重言式。逆命题不成立：令 \\(\\varphi = p\\) 且 \\(\\psi = \\neg p\\) 。显然，\\(\\varphi\\) 不是重言式，所以或者 \\(\\varphi\\) 不是重言式或者 \\(\\psi\\) 是重言式，但 \\(\\varphi \\rightarrow \\psi\\) 却不是重言式。▗ 1. 如果 \\(\\varphi\\) 是矛盾式或者 \\(\\psi\\) 是重言式，那么 \\(\\varphi \\rightarrow \\psi\\) 是重言式；但逆命题不成立。 证明：由真理定义易见，如果 \\(\\varphi\\) 是矛盾式则 \\(\\varphi \\rightarrow \\psi\\) 是重言式，并且如果 \\(\\psi\\) 是重言式则 \\(\\varphi \\rightarrow \\psi\\) 也是重言式。所以，如果 \\(\\varphi\\) 是矛盾式或者 \\(\\psi\\) 是重言式，那么 \\(\\varphi \\rightarrow \\psi\\) 是重言式。逆命题不成立：令 \\(\\varphi=\\psi=p.\\) 显然，\\(\\varphi \\rightarrow \\psi\\) 是重言式，但 \\(\\varphi\\) 不是矛盾式， \\(\\psi\\) 也不是重言式。▗ 1. \\(\\varphi \\leftrightarrow \\psi\\) 是重言式当且仅当 \\(\\varphi \\rightarrow \\psi\\) 和 \\(\\psi \\rightarrow \\varphi\\) 都是重言式。 证明：设 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式。对每个真值指派 \\(\\sigma\\)，如果 \\(\\sigma \\vDash \\varphi\\)，那么根据假设和真理定义， \\(\\sigma \\vDash \\psi.\\) 所以，\\(\\varphi \\rightarrow \\psi\\) 是重言式。同理可证，\\(\\psi \\rightarrow \\varphi\\) 也是重言式。另一方面，设 \\(\\varphi \\rightarrow \\psi\\) 和 \\(\\psi \\rightarrow \\varphi\\) 都是重言式。令 \\(\\sigma\\) 为任意真值指派。根据假设和真理定义，如果 \\(\\sigma \\vDash \\varphi\\) 则 \\(\\sigma \\vDash \\psi\\)，并且如果 \\(\\sigma \\nvDash \\varphi\\) 则 \\(\\sigma \\nvDash \\psi;\\) 于是有 \\(\\varphi^\\sigma = \\psi^\\sigma\\)，再由真理定义得到 \\(\\varphi \\leftrightarrow \\psi.\\) 所以，\\(\\varphi \\leftrightarrow \\psi\\) 是重言式。 ▗ 1. 如果 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式，那么，\\(\\varphi\\) 是重言式当且仅当 \\(\\psi\\) 是重言式；但逆命题不成立。 1. \\(\\varphi \\lor \\psi\\) 是矛盾式当且仅当 \\(\\varphi\\) 是矛盾式并且 \\(\\psi\\) 都是矛盾式。 1. 如果 \\(\\varphi\\) 或 \\(\\psi\\) 是矛盾式，那么 \\(\\varphi \\land \\psi\\) 是矛盾式；但逆命题不成立。 1. \\(\\varphi \\rightarrow \\psi\\) 是矛盾式当且仅当 \\(\\varphi\\) 是重言式并且 \\(\\psi\\) 是矛盾式。 1. 如果 \\(\\varphi\\) 和 \\(\\psi\\) 中一个是重言式另一个是矛盾式，那么 \\(\\varphi \\leftrightarrow \\psi\\) 是矛盾式；但逆命题不成立。 {{% /dtpc %}} {{% dtpc title=“☯命题 3.8” %}} 令 \\(\\varphi, \\psi\\) 和 \\(\\varphi_0,\\cdots,\\varphi_n\\) 为任意公式。我们有： 1. \\(\\varphi\\) 是重言式当且仅当 \\(\\nvDash_{0} \\varphi\\)（即 \\(\\varnothing \\nvDash_{0} \\varphi\\)）。 证明：设 \\(\\varphi\\) 是重言式。因为对所有真值指派 \\(\\sigma\\) 都有 \\(\\sigma \\vDash \\varphi\\)，所以根据重言蕴涵的定义，\\(\\nvDash_{0} \\varphi.\\) 设 \\(\\nvDash_{0} \\varphi.\\) 令 \\(\\sigma\\) 为任意真值指派。我们知道 \\(\\sigma \\nvDash_{0} \\varnothing\\)（见定义 3.2 之解说），因而由假设 \\(\\varnothing \\nvDash_{0} \\varphi\\) 和重言蕴涵定义得知 \\(\\sigma \\vDash \\varphi.\\) 所以 \\(\\varphi\\) 是重言式。▗ 1. \\(\\varphi \\nvDash_{0} \\psi\\) 当且仅当 \\(\\varphi \\rightarrow \\psi\\) 是重言式。 证明：由命题 可知，\\(\\varphi \\vDash_{0} \\psi\\) 当且仅当 \\(\\vDash_{0} \\varphi \\rightarrow \\psi\\)，再运用上一条结论得知，\\(\\varphi \\vDash_{0} \\psi\\) 当且仅当 \\(\\varphi \\rightarrow \\psi\\) 是重言式。▗ 1. \\(\\varphi_0,\\cdots,\\varphi_n \\nvDash_{0} \\psi\\) 当且仅当 \\(\\nvDash_{0} \\varphi_0 \\rightarrow (\\cdots\\rightarrow(\\varphi_n \\rightarrow \\psi)\\cdots).\\) 证明：施归纳于 \\(n.\\) 当 \\(n=0\\) 时，由上条结论知本命题成立。假设当 \\(n=k\\) 时本条命题成立。由命题 3.1 知，\\(\\varphi_{0}, \\cdots, \\varphi_{k}, \\varphi_{k+1} \\vDash_{0} \\psi\\) 当且仅当 \\(\\varphi_{0}, \\cdots, \\varphi_{k} \\vDash_{0} \\varphi_{k+1} \\rightarrow \\psi\\)，再根据归纳假设，\\(\\varphi_{0}, \\cdots, \\varphi_{k} \\vDash_{0} \\varphi_{k+1} \\rightarrow \\psi\\) 当且仅当 \\(\\vDash_{0} \\varphi_{0} \\rightarrow(\\cdots \\rightarrow(\\varphi_{k} \\rightarrow(\\varphi_{k+1} \\rightarrow \\psi)) \\cdots).\\) 所以，\\(\\varphi_{0}, \\cdots, \\varphi_{k}, \\varphi_{k+1} \\vDash_{0} \\psi\\) 当且仅当 \\(\\vDash_{0} \\varphi_{0} \\rightarrow(\\cdots \\rightarrow(\\varphi_{k} \\rightarrow(\\varphi_{k+1} \\rightarrow \\psi)) \\cdots).\\)▗ 1. \\(\\varphi \\leftrightarrow \\psi\\) 是重言式当且仅当 \\(\\varphi\\) 重言等值于 \\(\\psi.\\) 证明：根据命题 3.4，\\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当 \\(\\varphi \\vDash_{0} \\psi\\) 并且 \\(\\psi \\vDash_{0} \\varphi\\)，再根据上述第一条，\\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当 \\(\\varphi \\rightarrow \\psi\\) 和 \\(\\psi \\rightarrow \\varphi\\) 都是重言式。最后，根据命题 3.7 第四条，\\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式。▗ {{% /dtpc %}} 命题 3.8 第二条的归纳证明中，归纳假设是： 对所有的 \\(\\varphi_{0}, \\cdots, \\varphi_{k}\\) 和 \\(\\psi\\)，\\(\\varphi_{0}, \\cdots, \\varphi_{k} \\vDash_{0} \\psi\\) 当且仅当 \\(\\vDash_{0} \\varphi_{0} \\rightarrow(\\cdots \\rightarrow(\\varphi_{k} \\rightarrow \\psi) \\cdots).\\) 其中「对所有的…」来自命题 3.8 的题设「令… 为任意公式」。既然归纳假设中的 \\(\\psi\\) 可以是任意公式（如果愿意，可以把上述 \\(\\psi\\) 都改写成 \\(\\chi\\)），所以也可以是 \\(\\varphi_{k+1} \\rightarrow \\psi\\) 这样的公式。于是我们由归纳假设得到 \\(\\varphi_{0}, \\cdots, \\varphi_{k} \\vDash_{0} \\varphi_{k+1} \\rightarrow \\psi\\) 当且仅当 \\(\\vDash_{0} \\varphi_{0} \\rightarrow(\\cdots \\rightarrow(\\varphi_{k} \\rightarrow(\\varphi_{k+1} \\rightarrow \\psi)) \\cdots).\\) 基本语义概念的简单应用就讲这些，希望读者完成本章后面的证明练习。做证明可帮助读者准确地理解和掌握上述基本语义概念，更可以帮助培养准确表达思想和仔细推敲论据的习惯。 4.3 代入 代入（substitution）是对公式做变形处理的一种方式。在本书的命题逻辑范围内，「代入」总是指对命题变号的代入。 4.3.1 关于代入的直观说明 令 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式，\\(p\\) 为任意命题变项。所谓用 \\(\\psi\\) 代入 \\(\\varphi\\) 中的 \\(p\\)，是指用 \\(\\psi\\) 替换 \\(p\\) 在 \\(\\varphi\\) 中的每一处出现，其结果记为 \\(\\varphi(\\psi/p).\\) 例 3.12 令 ${0}=q r, {1}=p r $ 且 \\(\\varphi_{2}=p \\rightarrow \\neg p \\vee q.\\) 则有： 1. \\(\\varphi_{0}(q / p)=q \\rightarrow r\\) 1. \\(\\varphi_{1}(q / p)=q \\vee r\\) 1. \\(\\varphi_{2}(q / p)=q \\rightarrow \\neg q \\vee q\\) 1. \\(\\varphi_{2}(\\neg p / p)=\\neg p \\rightarrow \\neg \\neg p \\vee q\\) 1. \\(\\varphi_{2}(p \\vee q / p)=p \\vee q \\rightarrow \\neg(p \\vee q) \\vee q\\) 如果我们同时用 \\(\\psi_0,\\cdots,\\psi_n\\) 分别代入 \\(\\varphi\\) 中的 \\(p_0,\\cdots,p_n\\)，其结果就记为 \\(\\varphi(\\psi_0/p_0,\\cdots,\\psi_n/p_n).\\) 例 3.13 令 \\(\\varphi\\) 为 \\(p \\rightarrow \\neg p \\land q.\\) 则有： 1. \\(\\varphi(q / p, p / q)=q \\rightarrow \\neg q \\wedge p\\) 1. \\(\\varphi(p \\wedge q / p, p / q)=p \\wedge q \\rightarrow \\neg(p \\wedge q) \\wedge p\\) 1. \\(\\varphi(p \\wedge q / p)(p / q)=(p \\wedge q \\rightarrow \\neg(p \\wedge q) \\wedge q)(p / q)=p \\wedge p \\rightarrow \\neg(p \\wedge p) \\wedge p\\) 注意例 3.13 公式二和公式一的差别。公式二是先用 \\(p \\wedge q\\) 代入 \\(\\varphi\\) 中的 \\(p\\) 而得到 \\(\\varphi(p \\wedge q / p)\\)，再用 \\(p\\) 代入 \\(\\varphi(p \\wedge q / p)\\) 中的 \\(q\\) 而得到的；而公式一是用 \\(p \\wedge q\\) 代入 \\(\\varphi\\) 中的 \\(p\\)，同时用 \\(p\\) 代入 \\(\\varphi\\) 中的 \\(q\\)（不是 \\(\\varphi(p \\wedge q / p)\\) 中的 \\(q\\)）而得到的。可见，同时代入的结果和先后代入的结果是不同的。 4.3.2 代入的定义 如果我们只考虑具体的代入操作，那么关于代入的上述说明差不多已经够了，但这个说明显然不够严格。我们约定：在无特别说明时，我们用不同的符号表示不同的命题变号。代入的严格定义如下： {{% dtpc title=“☯定义 3.9【代入】” %}} 是从命题变号集到公式集的函数。我们用 \\(\\mathfrak{s}, \\mathfrak{s}^{\\prime}\\) 等表示代入。设 \\(\\mathfrak{s}\\) 是一个代入。对所有公式 \\(\\chi\\)，公式 \\(\\chi(\\mathfrak{s})\\)（「对 \\(\\chi\\) 做代入 \\(\\mathfrak{s}\\) 的结果」）递归地定义如下： &gt; 1. 所有命题变号 \\(p\\)，\\(p(\\mathfrak{s})=\\mathfrak{s}(p);\\) &gt; 1. 对所有公式 \\(\\varphi\\)，\\((\\neg \\varphi)(\\mathfrak{s})=\\neg(\\varphi(\\mathfrak{s}));\\) &gt; 1. 对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\((\\varphi \\odot \\psi)(\\mathfrak{s})=\\varphi(\\mathfrak{s}) \\odot \\psi(\\mathfrak{s})\\)，其中 \\(\\odot \\in\\lbrace \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\rbrace.\\) {{% /dtpc %}} 为简化敍述，定义 3.9 引入「\\(\\color{red}\\odot\\)」符号。它指的是：对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\((\\varphi \\wedge \\psi)(\\mathfrak{s})=\\varphi(\\mathfrak{s}) \\wedge \\psi(\\mathfrak{s})\\)，\\((\\varphi \\vee \\psi)(\\mathfrak{s})= \\varphi(\\mathfrak{s}) \\vee \\psi(\\mathfrak{s})\\)，\\((\\varphi \\rightarrow \\psi)(\\mathfrak{s})=\\varphi(\\mathfrak{s}) \\rightarrow \\psi(\\mathfrak{s})\\) 并且 \\((\\varphi \\leftrightarrow \\psi)(\\mathfrak{s})=\\varphi(\\mathfrak{s}) \\leftrightarrow \\psi(\\mathfrak{s}).\\) {{% dtpc title=“☯定义 3.10【有穷代入】” %}} 设代入 \\(\\mathfrak{s}\\) 满足 \\(\\mathfrak{s}(q_{0})=\\psi_{0}, \\cdots, \\mathfrak{s}(q_{n})=\\psi_{n}\\)，并且 \\(\\mathfrak{s}(r)=r\\) 对所有不是 \\(q_{0}, \\cdots, q_{n}\\) 的命题变号 \\(r\\) 都成立。我们用 \\(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n}\\) 表示这个 \\(\\mathfrak{s}\\)，用 \\(\\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n})\\) 来表示 \\(\\varphi(\\mathfrak{s})\\)，并且称 \\(\\mathfrak{s}\\) 为有穷代入。 {{% /dtpc %}} 如果换个方式来讲定义 3.9 的内容，那就是：每个代入 \\(\\mathfrak{s}\\) 都可以唯一地扩充为一个满足下列（对应于定义 3.9 中）条件的公式集上的函数 \\(\\mathfrak{s}^{+}\\)： 所有命题变号 \\(p\\)，\\(\\mathfrak{s}^{+}(p)=\\mathfrak{s}(p);\\) 对所有公式 \\(\\varphi\\)，\\(\\mathfrak{s}^{+}(\\neg \\varphi)=\\neg\\mathfrak{s}^{+}(\\varphi);\\) 对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\mathfrak{s}^{+}(\\varphi \\odot \\psi)=\\mathfrak{s}^{+}(\\varphi) \\odot \\mathfrak{s}^{+}(\\psi)\\)，\\(\\odot \\in\\lbrace \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\rbrace.\\) 我们之所以采用「\\(\\varphi(\\mathfrak{s})\\)」式的记法而非「\\(\\mathfrak{s}^{+}(\\varphi)\\)」式的记法，是因为前者通过定义 3.10 可以和代入的直观说明在记法上保持一致。 为了帮助读者理解定义 3.9-3.10，我们在下面两个例子中（大体上）一步步地计算代入结果。注意：我们将尽量省略括号。\\(\\theta \\vee \\lambda / p, \\theta \\wedge \\neg \\lambda / q\\) 等就是 \\((\\theta \\vee \\lambda) / p,(\\theta \\wedge \\neg \\lambda) / q\\) 等。 例 3.14 令 \\(\\varphi_{0}=q \\rightarrow r, \\varphi_{1}=p \\vee r\\)，且 \\(\\varphi_{2}=p \\rightarrow \\neg p \\vee q;\\) 并令 \\(\\mathfrak{s}_{0}\\) 为 \\(q / p\\)，\\(\\mathfrak{s}_{1}\\) 为 \\(p / p\\) 且 \\(\\mathfrak{s}_{2}\\) 为 \\(p \\vee q / p.\\) 我们有： \\[\\begin{align*} \\checkmark \\varphi_{0}\\left(\\mathfrak{s}_{0}\\right) &amp;=(q \\rightarrow r)\\left(\\mathfrak{s}_{0}\\right)=q\\left(\\mathfrak{s}_{0}\\right) \\rightarrow r\\left(\\mathfrak{s}_{0}\\right)=q(q / p) \\rightarrow r(q / p)=q \\rightarrow r \\\\ \\checkmark \\varphi_{1}\\left(\\mathfrak{s}_{0}\\right) &amp;=(p \\vee r)\\left(\\mathfrak{s}_{0}\\right)=p\\left(\\mathfrak{s}_{0}\\right) \\vee r\\left(\\mathfrak{s}_{0}\\right)=p(q / p) \\vee r(q / p)=q \\vee r \\\\ \\checkmark \\varphi_{2}\\left(\\mathfrak{s}_{0}\\right) &amp;=(p \\rightarrow \\neg p \\vee q)\\left(\\mathfrak{s}_{0}\\right)=p\\left(\\mathfrak{s}_{0}\\right) \\rightarrow(\\neg p \\vee q)\\left(\\mathfrak{s}_{0}\\right) \\\\ &amp;=p\\left(\\mathfrak{s}_{0}\\right) \\rightarrow(\\neg p)\\left(\\mathfrak{s}_{0}\\right) \\vee q\\left(\\mathfrak{s}_{0}\\right)=p\\left(\\mathfrak{s}_{0}\\right) \\rightarrow \\neg p\\left(\\mathfrak{s}_{0}\\right) \\vee q\\left(\\mathfrak{s}_{0}\\right) \\\\ &amp;=p(q / p) \\rightarrow \\neg p(q / p) \\vee q(q / p)=q \\rightarrow \\neg q \\vee q \\\\ \\checkmark \\varphi_{2}\\left(\\mathfrak{s}_{1}\\right) &amp;=(p \\rightarrow \\neg p \\vee q)\\left(\\mathfrak{s}_{1}\\right)=p\\left(\\mathfrak{s}_{1}\\right) \\rightarrow \\neg p\\left(\\mathfrak{s}_{1}\\right) \\vee q\\left(\\mathfrak{s}_{1}\\right) \\\\ &amp;=p(\\neg p / p) \\rightarrow \\neg p(\\neg p / p) \\vee q(\\neg p / p)=\\neg p \\rightarrow \\neg \\neg p \\vee q \\\\ \\checkmark \\varphi_{2}\\left(\\mathfrak{s}_{2}\\right) &amp;=(p \\rightarrow \\neg p \\vee q)\\left(\\mathfrak{s}_{2}\\right)=p\\left(\\mathfrak{s}_{2}\\right) \\rightarrow \\neg p\\left(\\mathfrak{s}_{2}\\right) \\vee q\\left(\\mathfrak{s}_{2}\\right) \\\\ &amp;=p(p \\vee q / p) \\rightarrow \\neg p(p \\vee q / p) \\vee q(p \\vee q / p)\\\\ &amp;=p \\vee q \\rightarrow \\neg (p \\vee q) \\vee q \\end{align*}\\] 根据定义 3.9，例 3.14 得到的 ${0}({0}), {1}({0}), {2}({0}), {2}({1}) $ 和 \\(\\varphi_{2}(\\mathfrak{s}_{2})\\)，与例 3.12 根据代入的直观说明得到的 \\(\\varphi_{0}(q / p), \\varphi_{1}(q / p), \\varphi_{2}(q / p), \\varphi_{2}(\\neg p / p)\\) 和 \\(\\varphi_{2}(p \\vee q / p)\\)，是完全相同的。 例 3.15 令 \\(\\varphi\\) 为 \\(p \\rightarrow \\neg p \\wedge q\\)，并令 \\(\\mathfrak{s}_{3}\\) 为 \\(q/p, p/q\\)， \\(\\mathfrak{s}_{4}\\) 为 \\(p \\wedge q/ p, p/q\\)， \\(\\mathfrak{s}_{5}\\) 为 \\(p \\wedge q/p\\) 且 \\(\\mathfrak{s}_{6}\\) 为 \\(p/q.\\) 我们有： \\[\\begin{align*} \\checkmark \\varphi(\\mathfrak{s}_{3}) &amp;=(p \\rightarrow \\neg p \\wedge q)(\\mathfrak{s}_{3})=p(\\mathfrak{s}_{3}) \\rightarrow(\\neg p \\wedge q)(\\mathfrak{s}_{3}) \\\\ &amp;=p(\\mathfrak{s}_{3}) \\rightarrow \\neg p(\\mathfrak{s}_{3}) \\wedge q(\\mathfrak{s}_{3}) \\\\ &amp;=p(q / p, p / q) \\rightarrow \\neg p(q / p, p / q) \\wedge q(q / p, p / q) \\\\ &amp;=q \\rightarrow \\neg q \\wedge p \\\\ \\checkmark \\varphi(\\mathfrak{s}_{4}) &amp;=(p \\rightarrow \\neg p \\wedge q)(\\mathfrak{s}_{4})=p(\\mathfrak{s}_{4}) \\rightarrow \\neg p(\\mathfrak{s}_{4}) \\wedge q(\\mathfrak{s}_{4}) \\\\ &amp;=p(p \\wedge q / p, p / q) \\rightarrow \\neg p(p \\wedge q / p, p / q) \\wedge q(p \\wedge q / p, p / q) \\\\ &amp;=p \\wedge q \\rightarrow \\neg(p \\wedge q) \\wedge p\\\\ \\checkmark \\varphi(\\mathfrak{s}_{5})(\\mathfrak{s}_{6}) &amp;=(p \\rightarrow \\neg p \\wedge q)(\\mathfrak{s}_{5})(\\mathfrak{s}_{6})=\\left[p(\\mathfrak{s}_{5}) \\rightarrow \\neg p(\\mathfrak{s}_{5}) \\wedge q(\\mathfrak{s}_{5})\\right](\\mathfrak{s}_{6}) \\\\ &amp;=[p(p \\wedge q / p) \\rightarrow \\neg p(p \\wedge q / p) \\wedge q(p \\wedge q / p)](\\mathfrak{s}_{6}) \\\\ &amp;=(p \\wedge q \\rightarrow \\neg(p \\wedge q) \\wedge q)(\\mathfrak{s}_{6}) \\\\ &amp;=(p \\wedge q)(\\mathfrak{s}_{6}) \\rightarrow(\\neg(p \\wedge q) \\wedge q)(\\mathfrak{s}_{6}) \\\\ &amp;=p(\\mathfrak{s}_{6}) \\wedge q(\\mathfrak{s}_{6}) \\rightarrow \\neg(p(\\mathfrak{s}_{6}) \\wedge q(\\mathfrak{s}_{6})) \\wedge q(\\mathfrak{s}_{6}) \\\\ &amp;=p(p / q) \\wedge q(p / q) \\rightarrow \\neg(p(p / q) \\wedge q(p / q)) \\wedge q(p / q) \\\\ &amp;=p \\wedge p \\rightarrow \\neg(p \\wedge p) \\wedge p \\end{align*}\\] 注意：对所有公式 \\(\\varphi\\)，以及所有代入 \\(\\mathfrak{s}\\) 和 \\(\\mathfrak{s}^{\\prime}\\)，因为 \\(\\varphi(\\mathrm{s})\\) 是对 \\(\\varphi\\) 做代入 \\(\\mathfrak{s}\\) 的结果，所以 \\(\\varphi(\\mathfrak{s})(\\mathfrak{s}^{\\prime})\\) 就是 \\((\\varphi(\\mathfrak{s}))(\\mathfrak{s}^{\\prime}).\\) 这可推广至更一般的情况。 易见，根据定义 3.9，例 3.15 得到的部分结果，与根据代入的直观说明在例 3.13 中得到的 \\(\\varphi(q / p, p / q), \\varphi(p \\wedge q / p, p / q)\\) 和 \\(\\varphi(p \\wedge q / p)(p / q)\\)，是完全相同的。 如果 \\(q\\) 不在 \\(\\varphi\\) 中出现，那么对任何代入 \\(\\mathfrak{s}\\)，无论 \\(\\mathfrak{s}(q)\\) 是什么公式，似乎都应与 \\(\\varphi(\\mathfrak{s})\\) 无关。一般地，下述说法也似乎应该是对的： 对一个公式 \\(\\varphi\\) 做代入 \\(\\mathfrak{s}\\)，其结 \\(\\varphi(\\mathfrak{s})\\) 应只与 \\(\\mathfrak{s}\\) 指派给 \\(\\varphi\\) 中出现的命题变号的值有关，或者说，与 \\(\\mathfrak{s}\\) 指派给其他命题变号的值无关。 命题 3.9 正是对这种直观说法的一个准确表述。 {{% dtpc title=“☯命题 3.9” %}} 令 \\(\\varphi\\) 为任意公式，并令 \\(\\mathfrak{s}\\) 和 \\(\\mathfrak{s}^{\\prime}\\) 为任意代入。设 \\(\\varphi\\) 中出现的命题变号是在 \\(q_{0}, \\cdots, q_{n}\\) 之中，并且 \\(\\mathfrak{s}(q_{0})=\\mathfrak{s}^{\\prime}(q_{0}), \\cdots, \\mathfrak{s}(q_{n})=\\mathfrak{s}^{\\prime}(q_{n}).\\) 我们 有：\\(\\varphi(\\mathfrak{s})=\\varphi(\\mathfrak{s}^{\\prime}).\\) {{% /dtpc %}} 命题 3.9 之证明： 施归纳于公式的复杂度，我们证明：对每个只含命题变号 \\(q_{0}, \\cdots, q_{n}\\)的公式\\(\\varphi\\)，\\(\\varphi(\\mathfrak{s})=\\varphi(\\mathfrak{s}^{\\prime}).\\) 归纳基始：\\(\\varphi=q_{i}(i \\leqslant n).\\) 由题设知 \\(\\mathfrak{s}(q_{i})=\\mathfrak{s}^{\\prime}(q_{i})\\)，即 \\(\\varphi(\\mathfrak{s})=\\varphi(\\mathfrak{s}^{\\prime}).\\) 归纳步骤：设 \\(\\varphi=\\neg \\psi.\\) 根据归纳假设，\\(\\psi(\\mathfrak{s})=\\psi(\\mathfrak{s}^{\\prime})\\)，再由定义 3.9 得到 \\((\\neg \\psi)(\\mathfrak{s})=\\neg(\\psi(\\mathfrak{s}))=\\neg(\\psi(\\mathfrak{s}^{\\prime}))=(\\neg \\psi)(\\mathfrak{s}^{\\prime}).\\) 设 \\(\\varphi=\\psi \\odot \\chi\\)，其中 \\(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace.\\) 由归纳假设，\\(\\psi(\\mathfrak{s})=\\psi(\\mathfrak{s}^{\\prime})\\) 且 \\(\\chi(\\mathfrak{s})=\\chi(\\mathfrak{s}^{\\prime})\\)，因而有 \\(\\psi(\\mathfrak{s}) \\odot \\chi(\\mathfrak{s})=\\psi(\\mathfrak{s}^{\\prime}) \\odot \\chi(\\mathfrak{s}^{\\prime})\\)，再由定义 3.9 得到 \\((\\psi \\odot \\chi)(\\mathfrak{s})=(\\psi \\odot \\chi)(\\mathfrak{s}^{\\prime}).\\)（命题 3.9 是如何把「有关」和「无关」这种模糊说法改进为准确的说法的？注意这类问题一定有好处。）▗ 上述证明中用到了基于公式复杂度的归纳证明方法。 要想说明上面那个直观想法的正确性，前提是对「有关」「无关」等做出清楚而准确的刻画。很多学生善于联想和发挥，却不善于清楚和准确。清楚和准确往往不易做到，有时甚至不必要。但如果想把能讲好的道理讲好，首先要有把想法讲清楚讲准确的本领。倘若一个理论中的每个命题都「本身就是说不清的」，那它也就没什么道理好讲。当然，清楚和准确只是做好理论工作的必要条件，不是充分条件。 4.3.3 代入的复合 {{% dtpc title=“☯定义 3.11【代入的复合】” %}} 设 \\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime\\prime}\\) 为任意代入，我们用 \\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime}\\) 来表示它们的复合，即满足下列条件的代入 \\(\\mathfrak{s}\\)： 1. 对任意命题变号 \\(p\\)，\\(\\mathfrak{s}(p)=p(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})\\)，即 \\(\\mathfrak{s}(p)=(\\mathfrak{s}^{\\prime}(p))(\\mathfrak{s}^{\\prime \\prime}).\\) 1. 并且我们用 \\(\\varphi(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime})\\) 来表示 \\(\\varphi(\\mathfrak{s}).\\) {{% /dtpc %}} 这里的名称和记法（稍有改动）来自 Chagrov, Zakharyaschev［1997］。虽然 \\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime\\prime}\\) 都是函数，而且我们也用「代入的复合」来称呼 \\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime}\\)，但 \\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime}\\) 与通常数学中讨论的关系或函数的复合（composition）有所不同。\\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime}\\) 既不是通常数学中的 \\(\\mathfrak{s}^{\\prime}\\circ \\mathfrak{s}^{\\prime\\prime}\\) 也不是 \\(\\mathfrak{s}^{\\prime\\prime}\\circ \\mathfrak{s}^{\\prime}.\\) 这是因为：\\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime\\prime}\\) 的定义域都是命题变号集且其值域都是比命题变号集更大的公式集，而在数学中，要使 \\(\\mathfrak{s}^{\\prime} \\circ \\mathfrak{s}^{\\prime\\prime}\\) 或 \\(\\mathfrak{s}^{\\prime\\prime} \\circ \\mathfrak{s}^{\\prime}\\) 成为函数的复合，\\(\\mathfrak{s}^{\\prime}\\) 或 \\(\\mathfrak{s}^{\\prime\\prime}\\) 的值域须是对方定义域的子集。 易见，如果 \\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime\\prime}\\) 都是有穷代入，那么 \\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime\\prime}\\) 也是有穷代入（见习题 3.10）。 根据各种各样的例子，人们自然地会猜想： 如果对一个公式 \\(\\varphi\\) 做代入得到 \\(\\psi\\)，再对 \\(\\psi\\) 做代入得到 \\(\\chi\\)，那么对 \\(\\varphi\\) 做一次代入就可以得到 \\(\\chi\\)，而这个代入正是前两个代入的复合。 这个猜想的确是真的。 {{% dtpc title=“☯命题 3.10” %}} 对任意代入 \\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime \\prime}\\)，对任意公式 \\(\\varphi\\)，\\(\\varphi\\left(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}\\right)=\\varphi\\left(\\mathfrak{s}^{\\prime}\\right)\\left(\\mathfrak{s}^{\\prime \\prime}\\right).\\) 证明：施归纳于公式 \\(\\varphi\\) 的复杂度。 归纳基始：设 \\(\\varphi\\) 是命题变项 \\(p.\\) 根据定义 3.9 和定义 3.11, \\(\\varphi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=p(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})(p)=p(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})=\\varphi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}).\\) 归纳步聚 1：设 \\(\\varphi\\) 是 \\(\\neg \\psi.\\) 根据定义 3.9，\\((\\neg \\psi)(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\neg(\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}))\\)。由归纳假设知，\\(\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\psi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})\\)，进而 \\(\\neg(\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}))=\\neg(\\psi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}))\\)，再由定义 3.9 得到 \\(\\neg(\\psi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}))=(\\neg(\\psi(\\mathfrak{s}^{\\prime}))(\\mathfrak{s}^{\\prime \\prime}))=(\\neg \\psi)(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}).\\) 所以，\\((\\neg \\psi)(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})= (\\neg \\psi)(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}).\\) 归纳步骤 2-5: 设 \\(\\varphi\\) 为 \\(\\psi \\odot \\chi\\), 其中 \\(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace.\\) 按定义 3.9，\\((\\psi \\odot \\chi)(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}) \\odot \\chi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}).\\) 根据归纳假设，\\(\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\psi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})\\) 并且 \\(\\chi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\chi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})\\)，从而 \\(\\psi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime}) \\odot \\chi(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=\\psi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}) \\odot \\chi(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime})\\)，再由定义 3.9 得到 \\[\\begin{align} \\psi\\left(\\mathfrak{s}^{\\prime}\\right)\\left(\\mathfrak{s}^{\\prime \\prime}\\right) \\odot \\chi\\left(\\mathfrak{s}^{\\prime}\\right)\\left(\\mathfrak{s}^{\\prime \\prime}\\right) &amp;= \\left(\\psi\\left(\\mathfrak{s}^{\\prime}\\right) \\odot \\chi\\left(\\mathfrak{s}^{\\prime}\\right)\\right)\\left(\\mathfrak{s}^{\\prime \\prime}\\right)\\\\ &amp;= (\\psi \\odot \\chi)\\left(\\mathfrak{s}^{\\prime}\\right)\\left(\\mathfrak{s}^{\\prime \\prime}\\right) \\end{align}\\] 所以，\\((\\psi \\odot \\chi)(\\mathfrak{s}^{\\prime} \\mathfrak{s}^{\\prime \\prime})=(\\psi \\odot \\chi)(\\mathfrak{s}^{\\prime})(\\mathfrak{s}^{\\prime \\prime}).\\) ▗ {{% /dtpc %}} 读过「关于代入的直观说明」（§3.2.0（P.107）），一般人就明白如何做代入，即「会做」了。为什么还要谈代入的严格定义甚至代入的复合呢？千万不要因为这些是「末节」或「小技」就不屑一顾。正是这种「末节」和「小技」的积累，使人们能超越「会做」而进入对深层问题的讨论。试想：假如对代入的理解仅停留在「会做」的水平，那么我们如何证明「多次代入的结果都可通过一次代入得到」这个猜想呢？现在用「末节」和「小技」得到的这个结论，以后可以用于解决更深更难的问题。 4.3.4 代入的语义性质 这里我们讨论公式的不同代入结果在真值指派下的值，比如说，\\(\\varphi(\\psi / p)\\) 和 \\(\\varphi(\\chi/p)\\) 在 \\(\\sigma\\) 下的值。不难猜测：如果 \\(\\psi^{\\sigma}=p^{\\sigma}\\) 则 \\(\\varphi^{\\sigma}=(\\varphi(\\psi / p))^{\\sigma}\\)，亦即在 \\(\\sigma\\) 下，如果 \\(\\psi\\) 和 \\(p\\) 的值相同，那么无论对 \\(\\varphi\\) 是否做代入\\(\\psi / p\\), 其结果的值应该是一样的。一般地，公式 \\(\\varphi(\\psi / p)\\) 在 \\(\\sigma\\) 下的值与 \\(\\psi\\) 在 \\(\\sigma\\) 下的值有关，但与 \\(\\psi\\) 具体是哪个公式无关，也就是说，只要 \\(\\psi\\) 和 \\(\\chi\\) 在 \\(\\sigma\\) 下的值相同, 那么无论是对 \\(\\varphi\\) 做代入 \\(\\psi / p\\) 还是做代入 \\(\\chi / p\\)，其结果在 \\(\\sigma\\) 下的值都是一样的 (见推论 3.2)。下面几个命题说的正是这类事，不过比这更一般。 {{% dtpc title=“☯定理 3.0” %}} 设 \\(\\varphi\\) 为任意公式，其中出现的命题变号只有 \\(q_{0}, \\cdots, q_{n}\\)，并设 \\(\\sigma\\) 和 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足 \\(\\psi_{0}^{\\sigma}=\\chi_{0}^{\\sigma^{\\prime}}, \\cdots, \\psi_{n}^{\\sigma}=\\chi_{n}^{\\sigma^{\\prime}}.\\) 我们有：\\(\\sigma \\vDash \\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\varphi(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}).\\) {{% /dtpc %}} 证明：令 \\(\\mathfrak{s}\\) 为 \\(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n}\\) 且 \\(\\mathfrak{s}^{\\prime}\\) 为 \\(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}.\\) 施归纳于公式的复杂度。 归纳基始：\\(\\varphi=q_{i}(i \\leqslant n).\\) 显然有 \\(\\varphi(\\mathfrak{s})=\\psi_{i}\\) 且 $(^{})=_{i} $，而根据题设 \\(\\psi_{i}^{\\sigma}=\\chi_{i}^{\\sigma^{\\prime}}\\)，我们有 \\(\\sigma \\vDash \\psi_{i}\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\chi_{i}.\\) 归纳步骤：设 \\(\\varphi=\\neg \\theta_{\\circ}\\) 根据归纳假设，\\(\\sigma \\vDash \\theta(\\mathrm{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\theta(\\mathrm{s}^{\\prime})\\)，因而根据真理定义，\\(\\sigma \\vDash \\neg \\theta(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\neg \\theta(\\mathfrak{s}^{\\prime})\\)，再由定义 3.9 知，\\(\\sigma \\vDash(\\neg \\theta)(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash(\\neg \\theta)(\\mathfrak{s}^{\\prime}).\\) 设 \\(\\varphi=\\theta \\odot \\lambda\\)，其中 \\(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace.\\) 由归纳假设，\\(\\sigma \\vDash \\theta(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\theta(\\mathfrak{s}^{\\prime})\\)，并且$ ()$ 当且仅当 \\(\\sigma^{\\prime} \\vDash \\lambda(\\mathfrak{s}^{\\prime});\\) 所以根据真理定义，\\(\\sigma \\vDash \\theta(\\mathfrak{s}) \\odot \\lambda(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\theta(\\mathfrak{s}^{\\prime}) \\odot \\lambda(\\mathfrak{s}^{\\prime})\\)，再由定义 3.9 知，\\(\\sigma \\vDash(\\theta \\odot \\lambda)(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash(\\theta \\odot \\lambda)(\\mathfrak{s}^{\\prime}).\\) ▗ {{% dtpc title=“☯定理 3.1” %}} 令 \\(\\varphi\\) 为任意公式，其中出现的命题变号都在 \\(q_{0}, \\cdots, q_{n}\\) 之中。设 \\(\\sigma\\) 和 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足 \\(\\sigma^{\\prime}\\left(q_{0}\\right) = \\psi_{0}^{\\sigma}, \\cdots, \\sigma^{\\prime}\\left(q_{n}\\right) = \\psi_{n}^{\\sigma}.\\) 我们有：对任意代入 \\(\\mathfrak{s}\\)，如果 \\(\\mathfrak{s}\\left(q_{0}\\right) = \\psi_{0}, \\cdots, \\mathfrak{s}\\left(q_{n}\\right) = \\psi_{n}\\)，那么 \\(\\sigma \\vDash \\varphi(\\mathfrak{s})\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\varphi.\\) {{% /dtpc %}} 证明：设 \\(\\mathfrak{s}\\) 为任意代入，满足 \\(\\mathfrak{s}\\left(q_{0}\\right) = \\psi_{0}, \\cdots, \\mathfrak{s}\\left(q_{n}\\right) = \\psi_{n};\\) 并令 \\(\\mathfrak{s}^{*}\\) 为代入 \\(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n}.\\) 根据定理 3.0，\\(\\sigma \\vDash \\varphi\\left(\\mathfrak{s}^{*}\\right)\\) 当且仅当 \\(\\sigma^{\\prime} \\vDash \\varphi\\)，再由命题 3.9 得知 \\(\\varphi(\\mathfrak{s}) = \\varphi\\left(\\mathfrak{s}^{*}\\right).\\) 所以，$() $ 当且仅当 \\(\\sigma^{\\prime} \\vDash \\varphi.\\) ▗ 定理 3.1 的一个推论是：对每个公式 \\(\\varphi\\) 和每个代入 \\(\\mathfrak{s}\\)，如果 \\(\\varphi\\) 是重言式，那么 \\(\\varphi(\\mathfrak{s})\\) 一定也是重言式。（见习题 3.17） 注意：定理 3.0 和定理 3.1 都要求 \\(\\varphi\\) 中岀现的命题变号在 \\(q_{0}, \\cdots, q_{n}\\) 之中，但下面的推论 3.2 并不这样要求。之所以推论 3.2 允许 \\(\\varphi\\) 中出现不同于 \\(q_{0}, \\cdots, q_{n}\\) 的命题变号，是因为它涉及的真值指派只有一个。 {{% dtpc title=“☯推论 3.2” %}} 设 \\(\\sigma\\) 为任意真值指派，且对每个 \\(i=0, \\cdots, n\\) 都有 \\(\\psi_{i}^{\\sigma}=\\chi_{i}^{\\sigma}.\\) 我们有：对所有公式 \\(\\varphi\\) 和所有命题变号 \\(q_{0}, \\cdots, q_{n}, \\sigma \\vDash \\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n})\\) 当且仅当 \\(\\sigma \\vDash \\varphi(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}).\\) {{% /dtpc %}} 证明：设 \\(\\varphi\\) 为任意公式，\\(q_{0}, \\cdots, q_{n}\\) 为任意命题变号，并设 $r_{1}, , r_{m}(m ) $ 为 \\(\\varphi\\) 中出现的所有与 \\(q_{0}, \\cdots, q_{n}\\) 不同的命题变号。根据题设和定理 3.0 \\[ \\begin{array}{rl} &amp; \\sigma \\vDash \\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n}, r_{1} / r_{1}, \\cdots, r_{m} / r_{m}) \\\\ \\text{iff} &amp; \\sigma \\vDash \\varphi(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}, r_{1} / r_{1}, \\cdots, r_{m} / r_{m}) \\end{array} \\] 同时易见 \\(\\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n}, r_{1} / r_{1}, \\cdots, r_{m} / r_{m})\\) 就是 \\(\\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n})\\) 而 $({0} / q{0}, , {n} / q{n}, r_{1} / r_{1}, , r_{m} / r_{m}) $ 就是 \\(\\varphi(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}).\\) 所以 \\(\\sigma \\vDash \\varphi(\\psi_{0} / q_{0}, \\cdots, \\psi_{n} / q_{n})\\) 当且仅当 \\(\\sigma \\vDash \\varphi(\\chi_{0} / q_{0}, \\cdots, \\chi_{n} / q_{n}).\\) ▗ 最后，我们来看关于「置换」的语义定理。 {{% dtpc title=“☯推论 3.3” %}} 设 \\(\\Gamma \\vDash_{0} \\psi \\leftrightarrow \\chi.\\) 我们有：对每个公式 \\(\\varphi\\) 和每个命题变号 \\(p\\)，\\(\\Gamma \\vDash_{0} \\varphi(\\psi / p) \\leftrightarrow \\varphi(\\chi / p).\\) {{% /dtpc %}} 证明：设 \\(\\varphi\\) 为任意公式，\\(p\\) 为任意命题变号。令 \\(\\sigma\\) 为任意真值指派，满足 \\(\\sigma \\vDash \\Gamma.\\) 由题设和重言蕴涵的定义知 \\(\\sigma \\vDash \\psi \\leftrightarrow \\chi.\\) 从而有 \\(\\psi^{\\sigma}=\\chi^{\\sigma}.\\) 根据推论 3.2，\\(\\sigma \\vDash \\varphi(\\psi / p)\\) 当且仅当 \\(\\sigma \\vDash \\varphi(\\chi / p)\\)，进而 \\(\\sigma \\vDash \\varphi(\\psi / p) \\leftrightarrow \\varphi(\\chi / p).\\) 由此 可知，\\(\\Gamma \\vDash_{0} \\varphi(\\psi / p) \\leftrightarrow \\varphi(\\chi / p).\\) ▗ 用 \\(\\chi\\) 置换 \\(\\varphi\\) 中的 \\(\\psi\\)，是指用 \\(\\chi\\) 替换 \\(\\psi\\) 在 \\(\\varphi\\) 中的有穷多个出现，而这样得到的所有公式都称为 \\(\\varphi\\) 的 \\(\\chi/\\psi\\)-置换结果（简称置换结果）。推论 3.3 有时以下述形式出现，容易证明两者是等价的（见习题 3.16）: {{% dtpc title=“☯推论 3.4” %}} 设 \\(\\Gamma \\vDash_{0} \\psi \\leftrightarrow \\chi.\\) 我们有：对 \\(\\varphi\\) 的每个 \\(\\chi / \\psi\\)-置换结果 \\(\\varphi^{\\prime}, \\Gamma \\vDash_{0} \\varphi \\leftrightarrow \\varphi^{\\prime}.\\) {{% /dtpc %}} 当 \\(\\Gamma=\\varnothing\\) 时，上述推论成为： {{% dtpc title=“☯推论 3.5” %}} 如果 \\(\\psi\\) 与 \\(\\chi\\) 重言等值，那么 \\(\\varphi\\) 与它的所有 \\(\\chi / \\psi\\)-置换结果都重言等值。 {{% /dtpc %}} 推论 3.5 常被称为等值置换的语义版本 (或形式)。我们来看一个例子: 令 \\(\\varphi=\\neg p \\vee \\neg q \\rightarrow r \\wedge(\\neg p \\vee \\neg q), \\psi=\\neg p \\vee \\neg q\\) 并且 \\(\\chi=\\neg(p \\wedge q).\\) 用 \\(\\chi\\) 置换 \\(\\varphi\\) 中 \\(\\psi\\) 的结果可以是下面的任何一个： \\[\\begin{align} \\varphi_{0}^{\\prime}&amp;=\\neg(p \\wedge q) \\rightarrow r \\wedge(\\neg p \\vee \\neg q) \\nonumber \\\\ \\varphi_{1}^{\\prime}&amp;=\\neg p \\vee \\neg q \\rightarrow r \\wedge \\neg(p \\wedge q) \\label{eq:dairu-tuilun-3.5}\\\\ \\varphi_{2}^{\\prime}&amp;=\\neg(p \\wedge q) \\rightarrow r \\wedge \\neg(p \\wedge q) \\nonumber \\end{align}\\] 因 \\(\\chi\\) 与 \\(\\psi\\) 重言等值 (见习题 3.5), 所以根据推论 3.5，\\(\\varphi_{0}^{\\prime}, \\varphi_{1}^{\\prime}\\)，\\(\\varphi_{2}^{\\prime}\\) 都与 \\(\\varphi\\) 重言等值。 代入和置换有很大不同：从上面的例子可以看出， 对一个公式做代入，替换的只能是它的原子子公式（命题变号）；而对一个公式做置换，替换的可以是它的任何子公式。 对一个公式做代入时，如果替换其中的某命题变号，则必须替换这一命题变号在该公式中的所有出现；但在对一公式做置换时，可以只替换该子公式的某些出现，而不替换它的另一些出现。 代入和置换又有紧密的联系。比如，我们说过推论 3.4 等价于推论 3.3，那就是说，一个使用「置换」来表达的命题（如推论 3.4），等价于一个使用「代入」而不使用「置换」来表达的命题（如推论 3.3）。我们再用上面的例子加以说明： 仍令 \\(\\varphi=\\neg p \\vee \\neg q \\rightarrow r \\wedge(\\neg p \\vee \\neg q), \\psi=\\neg p \\vee \\neg q\\) 并且 \\(\\chi=\\neg(p \\wedge q).\\) 令 \\(p^{*}\\) 为任意一个与 \\(p, q, r\\) 都不同的命题变号，并且令 \\[\\begin{align*} \\varphi_{0}&amp;=p^{*} \\rightarrow r \\wedge(\\neg p \\vee \\neg q) \\\\ \\varphi_{1}&amp;=\\neg p \\vee \\neg q \\rightarrow r \\wedge p^{*} \\\\ \\varphi_{2}&amp;=p^{*} \\rightarrow r \\wedge p^{*} \\end{align*}\\] 易见下列等式成立，其中 \\(\\varphi_{0}^{\\prime}, \\varphi_{1}^{\\prime}\\) 和 \\(\\varphi_{2}^{\\prime}\\) 来自式 () \\[\\begin{align} \\varphi_{0}(\\psi / p^{*})=\\varphi_{1}(\\psi / p^{*})=\\varphi_{2}(\\psi / p^{*})=\\varphi \\nonumber\\\\ \\varphi_{0}(\\chi / p^{*})=\\neg(p \\wedge q) \\rightarrow r \\wedge(\\neg p \\vee \\neg q)=\\varphi_{0}^{\\prime} \\nonumber \\\\ \\varphi_{1}(\\chi / p^{*})=\\neg p \\vee \\neg q \\rightarrow r \\wedge \\neg(p \\wedge q)=\\varphi_{1}^{\\prime} \\label{eq:dairu-tuilun-3.7}\\\\ \\varphi_{2}(\\chi / p^{*})=\\neg(p \\wedge q) \\rightarrow r \\wedge \\neg(p \\wedge q)=\\varphi_{2}^{\\prime} \\nonumber \\end{align}\\] 因为 \\(\\psi\\) 与 \\(\\chi\\) 重言等值，所以，根据推论 3.3（视 \\(\\Gamma\\) 为空集），\\(\\varphi_{0}(\\psi / p^{*}), \\varphi_{1}(\\psi / p^{*})\\) 和 \\(\\varphi_{2}(\\psi / p^{*})\\) 分别与 \\(\\varphi_{0}(\\chi / p^{*}), \\varphi_{1}(\\chi / p^{*})\\) 和 \\(\\varphi_{2}(\\chi / p^{*})\\) 重言等值。我们由式 ()知道，这就是在说 \\(\\varphi\\) 与 \\(\\varphi_{0}^{\\prime}, \\varphi_{1}^{\\prime}\\) 和 \\(\\varphi_{2}^{\\prime}\\) 都重言等值，与前面由推论 3.5 得出的结论完全一样。 注意，推论 3.5 是「等值置换」语义形式的常见说法，而推论 3.3-3.4 在应用方面比推论 3.5 更方便。 4.4 真值指派与真值表 我们对重言蕴涵和重言式等概念曾给出两个不同的说明：一个是§2.5（P.85） 中的真值表刻画，另一个是在§3.1（P.101）中用真值指派给出的定义。为避免混淆，我们用这些概念的「严格定义」来指§3.1（P.101）中的定义，用这些概念的「真值表刻画」指§2.5（P.85）中的说明。这一节我们讨论的主要内容是这些概念的严格定义和真值表刻画的等价性。 从这一节起，我们将较多地使用真值函数这个概念。 4.4.1 真值函数 前面说过，真值函数是从真值集到真值集的函数，而且真值函数联结词就是以真值函数为其解释的联结词。第一点很容易理解，但第二点也许不太明显，我们先对它做一点说明。 显然，下列函数都是真值函数（其中 \\(x, y \\in \\lbrace 1,0\\rbrace\\)）： {{% freebox title=“真值函数联结词” %}} \\[\\begin{align} f_{\\neg}(x) &amp;=\\left\\lbrace \\begin{array}{ll} 1 &amp; \\text { 如果 }~ x=0 \\\\ 0 &amp; \\text { 否则 } \\end{array}\\right.\\\\ f_{\\lor}(x, y) &amp;=\\left\\lbrace \\begin{array}{ll} 1 &amp; \\text { 如果 }~ x=1 \\text { 或 } y=1 \\\\ 0 &amp; \\text { 否则 } \\end{array}\\right.\\\\ f_{\\land}(x, y) &amp;=\\left\\lbrace \\begin{array}{ll} 1 &amp; \\text { 如果 }~ x=y=1 \\\\ 0 &amp; \\text { 否则 } \\end{array}\\right.\\\\ f_{\\rightarrow}(x, y) &amp;=\\left\\lbrace \\begin{array}{ll} 1 &amp; \\text { 如果 }~ x=0 \\text { 或 }~ y=1 \\\\ 0 &amp; \\text { 否则 } \\end{array}\\right.\\\\ f_{\\leftrightarrow}(x, y) &amp;=\\left\\lbrace \\begin{array}{ll} 1 &amp; \\text { 如果 }~ x=y \\\\ 0 &amp; \\text { 否则 } \\end{array}\\right. \\end{align}\\] 若用真值表来表示这些函数，它们与基本真值表 2.1 完全对应： \\[ \\begin{array}{cc|c|c|c|c|c} x &amp; y &amp; f_{\\land}(x, y) &amp; f_{\\lor}(x, y) &amp; f_{\\rightarrow}(x, y) &amp; f_{\\leftrightarrow}(x, y) &amp; f_{\\neg}(x) \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \\\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; \\end{array} \\] {{% /freebox %}} 事实上，用真值指派 \\(\\sigma\\) 对所有公式 \\(\\varphi\\) 定义其真值 \\(\\varphi^\\sigma\\) 时（见定义 3.1），我们完全可以把定义写成下述形式： \\[ \\begin{align*} p_{n}^{\\sigma} &amp;=\\sigma(p_{n}) \\quad(n \\geqslant 0) \\nonumber \\\\ (\\neg \\psi)^{\\sigma} &amp;=f_{\\neg}(\\psi^{\\sigma}) \\\\ (\\psi \\odot \\chi)^{\\sigma} &amp;=f_{\\odot}(\\psi^{\\sigma}, \\chi^{\\sigma}) \\quad(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace)\\nonumber \\end{align*} \\] 现在应该容易看出，这些真值函数正是 \\(\\neg, \\wedge, \\vee, \\rightarrow, \\leftrightarrow\\) 这几个真值联结词的语义解释。比如，对于公式 \\(p \\lor q\\) 来说，\\(p\\) 和 \\(q\\) 各自都既可以解释为 1 也可以解释为 0，但 \\(\\lor\\) 却不可以随便解释——它的解释是固定的真值函数 \\(f_\\lor.\\) 类似地，\\(\\neg, \\land, \\rightarrow, \\leftrightarrow\\) 的解释分别是固定的真值函数 \\(f_{\\neg}, f_{\\land}, f_{\\rightarrow}\\) 和 \\(f_{\\leftrightarrow}.\\) 对每个 \\(n &gt; 0\\)，\\(n\\) 元真值函数共有 \\(2^{2^n}\\) 个。比如， 例 3.18 一元的真值函数有 4 个，见下表（易见 \\(f_{\\neg} = g_3\\)）： \\[ \\begin{array}{c|cccc} x &amp; g_{1}(x) &amp; g_{2}(x) &amp; g_{3}(x) &amp; g_{4}(x) \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\end{array} \\] 例 3.19 二元的真值函数有 16 个，见下表（\\(f_k\\) 表示 \\(f_{k}(x,y), k =1,\\cdots,16\\) ）： \\[ \\begin{array}{cc|cccccccccccccccc} x &amp; y &amp; f_{1} &amp; f_{2} &amp; f_{3} &amp; f_{4} &amp; f_{5} &amp; f_{6} &amp; f_{7} &amp; f_{8} &amp; f_{9} &amp; f_{10} &amp; f_{11} &amp; f_{12} &amp; f_{13} &amp; f_{14} &amp; f_{15} &amp; f_{16} \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\end{array} \\] 易见 \\(f_{\\lor}=f_2, f_{\\rightarrow}=f_5, f_{\\leftrightarrow}=f_7, f_{\\land}=f_8.\\) 三元和四元的真值函数等依此类推。三元真值函数有 \\(2^{2^3}=256\\) 个，而四元真值函数有 \\(2^{2^4}=65536\\) 个，这里自然画不下它们的真值表。 4.4.2 对部分命题变号的赋值 为了便于讨论，我们引入另一种赋值概念。这种赋值很像是真值指派，不过它只对给定的部分命题变号指派了真值，而对其他命题变号（如果有的话）没做任何指派。 对每个命题变号的非空集合 \\(A\\) 我们定义「\\(A\\)-公式」和「\\(A\\)-赋值」如下。（「\\(A\\)-公式」和「\\(A\\)-赋值」等都不是流行的术语。） {{% dtpc title=“☯定义 3.12 \\(A\\)-公式” %}} 设 \\(\\varnothing \\ne A \\subseteq \\mathbf{Pr}.\\) \\(A\\)-公式是其中只出现属于 \\(A\\) 的命题变号的 \\(\\mathscr{L}_0\\)-公式，其严格定义如下： &gt; 1. \\(A\\) 中的毎个命题变号都是 \\(A\\)-公式； &gt; 1. 如果 \\(\\varphi\\) 和 \\(\\psi\\) 是 \\(A\\)-公式，那么 \\(\\neg \\varphi\\) 和 \\((\\varphi \\odot \\psi)\\) 都是 \\(A\\)-公式，其中 \\(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace;\\) &gt; 1. 只有这些是 \\(A\\)-公式。 {{% /dtpc %}} {{% dtpc title=“☯定义 3.13 \\(A\\)-赋值” %}} 设\\(\\varnothing \\ne A \\subseteq \\mathbf{Pr}.\\) 一个 \\(A\\)-赋值是从 \\(A\\) 到 \\(\\lbrace 1,0\\rbrace\\) 的一个函数。 {{% /dtpc %}} 这里对命题变号集 \\(A\\) 的限制只是「非空」，从而 \\(A\\) 可以是有穷集也可以是无穷集，甚至可以就是 \\(\\mathbf{Pr}\\)（由此可知，真值指派都是 \\(\\mathbf{Pr}\\)-赋值）。但是，如果 \\(A \\ne \\mathbf{Pr}\\)，我们把赋值称作对部分命题变号的赋值。下面是关于这个概念的一个有用事实：如果 \\(A\\) 是出现在某个真值表中的所有命题变号的集合，那么该表中命题变号的每一个可能取值组合就是一个 \\(A\\)-赋值。（参见§2.4.2（P.84）关于命题变号的可能取值组合的讨论。） {{% dtpc title=“☯定义 3.14 \\(A\\)-赋值的递归定义” %}} 设 \\(\\varnothing \\ne A \\subseteq \\mathbf{Pr}\\)，并设 \\(\\tau\\) 为任意 \\(A\\)-赋值。对所有的 \\(A\\)-公式 \\(\\varphi\\)，我们用 \\(\\varphi^\\tau\\) 表示「\\(\\varphi\\) 在 \\(\\tau\\) 下的值」。\\(\\varphi^\\tau\\) 递归地定义如下： \\[\\begin{align*} p^{\\tau} &amp;=\\tau(p) \\quad(p \\in A) \\\\ (\\neg \\varphi)^{\\tau} &amp;=f_{\\neg}\\left(\\varphi^{\\tau}\\right) \\\\ (\\varphi \\odot \\psi)^{\\tau} &amp;=f_{\\odot}\\left(\\varphi^{\\tau}, \\psi^{\\tau}\\right) \\quad(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace) \\end{align*}\\] {{% /dtpc %}} 对比定义 3.14 和式 3.13 后很容易看出，\\(A\\)-赋值只给出 \\(A\\)-公式的真值，而真值指派给出所有 \\(\\mathscr{L}_0\\)-公式的真值，但仅就 \\(A\\)-公式来说，这两个定义确定公式真值的方法是完全一样的。 4.4.3 两种描述方式的等价性 重言蕴涵等概念的严格定义和它们的真值表刻画有明显的区别。比如说重言式，按照它的严格定义，一公式是否重言式的问题涉及无穷多真值指派，每个真值指派又涉及无穷多命题变号的真值；而按照它的真值表刻画，一公式是否重言式的问题，却只涉及某个有穷的命题变号集合 \\(A\\) 和有穷多个 \\(A\\)-赋值。尽管如此，「严格定义」和「真值表刻画」在下述意义上是等价的：满足「严格定义」的一定满足「真值表刻画」，而满足「真值表刻画」的也一定满足「严格定义」。下面我们提供这种等价性的证明。 借助直观，人们会有以下猜测： 一个公式 \\(\\varphi\\) 在一真值指派 \\(\\sigma\\) 下的值，应只与 \\(\\sigma\\) 指派给 \\(\\varphi\\) 中出现的命题变号的值有关，或者说，与 \\(\\sigma\\) 指派给其他命题变号的值无关。 运用 \\(A\\)-赋值的概念，我们可以将上述猜测表述为下述命题。 {{% dtpc title=“☯命题 3.11” %}} 设 \\(\\varnothing \\ne A \\subseteq \\mathbf{Pr}\\)，设 \\(\\sigma\\) 为任意真值指派，并设 \\(\\tau\\) 为任意 \\(A\\)-赋值，满足对每个 \\(p \\in A, \\tau(p) = \\sigma(p).\\) 那么，对所有的 \\(A\\)-公式 \\(\\varphi\\)，\\(\\varphi^\\sigma = \\varphi^\\tau.\\) {{% /dtpc %}} 证明：施归纳于公式的复杂度，我们证明对每个 \\(A\\)-公式 \\(\\varphi, \\varphi^{\\sigma}=\\varphi^{\\tau}.\\) 归纳基始：\\(\\varphi=p \\in A.\\) 由题设知 \\(\\sigma(p)=\\tau(p)\\)，即 \\(\\varphi^{\\sigma}=\\varphi^{\\tau}.\\) 归纳步骤：设 \\(\\varphi=\\neg \\psi.\\) 由归纳假设知 \\(\\psi^{\\sigma}=\\psi^{\\tau}\\)，于是根据 式 3.13 和定义 3.14 得到 \\[(\\neg \\psi)^{\\sigma}=f_{\\neg}\\left(\\psi^{\\sigma}\\right)=f_{\\neg}\\left(\\psi^{\\tau}\\right)=(\\neg \\psi)^{\\tau}\\] 设 \\(\\varphi=\\psi \\odot \\chi(\\odot \\in\\lbrace \\vee, \\wedge, \\rightarrow, \\leftrightarrow\\rbrace).\\) 由归纳假设知 \\(\\psi^{\\sigma}=\\psi^{\\tau}\\) 且 \\(\\chi^{\\sigma}=\\chi^{\\tau}\\)，再根据式 3.13 和定义 3.14，我们有 \\[(\\psi \\odot \\chi)^{\\sigma}=f_{\\odot}\\left(\\psi^{\\sigma}, \\chi^{\\sigma}\\right)=f_{\\odot}\\left(\\psi^{\\tau}, \\chi^{\\tau}\\right)=(\\psi \\odot \\chi)^{\\tau}\\] 由此我们证明了，对每个 \\(A\\)-公式 \\(\\varphi\\) 都有 \\(\\varphi^{\\sigma}=\\varphi^{\\tau}.\\) ▗ 命题 3.11 是对前述猜测的一种表述，其中使用了 \\(A\\)-赋值这一概念。如果不用这个概念，我们可以将前述猜测表述为下述命题。 {{% dtpc title=“☯命题 3.12” %}} 设 \\(\\varnothing \\neq A \\subseteq \\mathbf{Pr}\\)，并设 \\(\\sigma\\) 和 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足对每个 \\(p \\in A, \\sigma(p)=\\sigma^{\\prime}(p).\\) 那么，对所有的 \\(A\\)-公式 \\(\\varphi\\)，\\(\\varphi^{\\sigma} = \\varphi^{\\sigma^{\\prime}}.\\) {{% /dtpc %}} 证明：令 \\(\\tau\\) 为 \\(\\sigma\\) 限制到 \\(A\\) 的结果。（设 \\(f\\) 为从 \\(X\\) 到 \\(Y\\) 的任意函数，并设 \\(Z \\subseteq X.\\) 将 \\(f\\) 限制到 \\(Z\\) 的结果是从 \\(Z\\) 到 \\(Y\\) 的函数 \\(g\\)，满足对每一个 \\(x \\in Z\\) 都有 \\(g(x) = f(x).\\)）对每个 \\(A\\)-公式 \\(\\varphi\\)，由题设和命题 3.11 知 \\(\\varphi^{\\sigma}=\\varphi^{\\tau}\\)，再次运用题设和命题 3.11 即有 \\(\\varphi^{\\tau}=\\varphi^{\\sigma^{\\prime}}\\)，所以 \\(\\varphi^{\\sigma}=\\varphi^{\\sigma^{\\prime}}.\\) ▗ 为了证明命题 3.12（尤其是在没引入 \\(A\\)-赋值概念的情况下），可以像证明命题 3.11 那样，施归纳于公式的复杂度，完成归纳基始和一个个归纳步骤。但是，直接应用命题 3.11 显然使命题 3.12 的证明更简单。在基本概念清楚之后，注意已证明的命题或定理，避免事事「从头做起」。 设 \\(\\tau\\) 为任意 \\(A\\)-赋值，\\(\\Gamma\\) 为任意 \\(A\\)-公式集。\\(\\tau \\vDash \\Gamma\\) 当且仅当对每个 \\(\\varphi \\in \\Gamma\\) 都有 \\(\\varphi^\\tau = 1.\\) 类似地，我们用 \\(\\tau \\vDash \\varphi\\) 表示 \\(\\tau \\vDash \\lbrace \\varphi\\rbrace\\)，并用丁 \\(\\tau \\nvDash \\Gamma\\) 和 \\(\\tau \\nvDash \\varphi\\) 分别表示 \\(\\tau \\vDash \\Gamma\\) 和 \\(\\tau \\vDash \\varphi\\) 不成立。 运用命题 3.11，可以轻松地证明下述命题，其中的「重言蕴涵」和「重言式」等，都是在「严格定义」的意义上使用的。 {{% dtpc title=“☯命题 3.13” %}} 设 \\(\\varnothing \\ne A \\subseteq \\mathbf{Pr}\\)，设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意的 \\(A\\)-公式，并设 \\(\\Gamma\\) 为任意的\\(A\\)-公式集。我们有： \\(\\Gamma \\vDash_{0} \\varphi\\) 当且仅当对所有的 \\(A\\)-赋值 \\(\\tau\\)，如果 \\(\\tau \\vDash \\Gamma\\) 则 \\(\\tau \\vDash \\varphi;\\) \\(\\varphi\\) 与 \\(\\psi\\) 重言等值当且仅当对每个 \\(A\\)-赋值 \\(\\tau, \\varphi^{\\tau}=\\psi^{\\tau};\\) \\(\\Gamma\\) 是可满足的当且仅当存在 \\(A\\)-赋值 \\(\\tau\\) 使得 \\(\\tau \\vDash \\Gamma;\\) \\(\\varphi\\) 是重言式当且仅当对每个 \\(A\\)-赋值 \\(\\tau\\) 都有 \\(\\varphi^{\\tau}=1;\\) \\(\\varphi\\) 是矛盾式当且仅当对每个 \\(A\\)-赋值 \\(\\tau\\) 都有 \\(\\varphi^{\\tau}=0;\\) \\(\\varphi\\) 是或然式当且仅当存在 \\(A\\)-赋值 \\(\\tau\\) 和 \\(\\tau^{\\prime}\\) 使得 \\(\\varphi^{\\tau}=1\\) 且 \\(\\varphi^{\\tau^{\\prime}}=0.\\) {{% /dtpc %}} 证明：我们证明：\\(\\Gamma \\nvDash_{0} \\varphi\\) 当且仅当存在一个 \\(A\\)-赋值 \\(\\tau\\) 使得 \\(\\tau \\vDash \\Gamma\\) 且 $ .$ 设 \\(\\Gamma \\nvDash_{0} \\varphi.\\) 根据定义 3.3，存在一个真值指派 \\(\\sigma\\) 使得 \\(\\sigma \\vDash \\Gamma\\) 且 \\(\\sigma \\nvDash \\varphi.\\) 令 \\(\\tau\\) 为 \\(\\sigma\\) 限制到 \\(A\\) 的结果。显然 \\(\\tau\\) 是个 \\(A\\)-赋值，而根据命题 3.11，\\(\\tau \\vDash \\Gamma\\) 且 \\(\\tau \\nvDash \\varphi.\\) 反之，设存在 \\(A\\) -赋值 \\(\\tau\\)，满足 \\(\\tau \\vDash \\Gamma\\) 且 \\(\\tau \\nvDash \\varphi.\\) 令 \\(\\sigma\\) 为这样一个真值指派：对每个 \\(p \\in A\\)，\\(\\sigma(p)=\\tau(p)\\)，并且对每个命题变号 \\(q \\notin A, \\sigma(q)=0.\\) 根据命题 3.11，\\(\\sigma \\vDash \\Gamma\\) 且 \\(\\sigma \\nvDash \\varphi\\)，所以由定义 3.3 \\(\\Gamma \\nvDash_{0} \\varphi.\\) ▗ 命题 3.13 其他条目的证明都与上述证明类似，都留作练习（见习题 3.19）。 如果把 \\(\\Gamma\\) 限制为有穷集，并把 \\(A\\) 限制为 \\(\\Gamma\\) 和 \\(\\varphi\\) 中（或 \\(\\varphi\\) 和 \\(\\psi\\) 中）出现的命题变号的集合，那么命题 3.13 说的正是重言蕴涵等语义概念的严格定义等价于它们的真值表刻画。至此我们完成了对这一等价性的证明。不过，因为命题 3.11-3.13 中的 \\(\\Gamma\\) 和 \\(A\\) 都可以是无穷集，所以这些命题比上述等价性更具一般性。 下述命题是命题 3.13 的一个简单应用。（注意对比命题 3.7） {{% dtpc title=“☯命题 3.14” %}} 令 \\(\\varphi\\) 和 \\(\\psi\\) 为任意不含相同命题变号的公式。我们有： \\(\\varphi\\lor \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 是重言式或者 \\(\\psi\\) 是重言式。 \\(\\varphi \\rightarrow \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 是矛盾式或者 \\(\\psi\\) 是重言式。 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是矛盾式或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是重言式。 {{% /dtpc %}} 证明：根据命题 3.7条目一，只需假设 \\(\\varphi\\) 和 \\(\\psi\\) 都不是重言式，而证明 \\(\\varphi\\lor \\psi\\) 不是重言式。根据假设，存在真值指派 \\(\\sigma\\) 和 \\(\\sigma^\\prime\\)，使得 \\(\\sigma \\nvDash \\varphi\\) 并且 \\(\\sigma^\\prime \\nvDash \\varphi\\)。令 \\(\\sigma^*\\) 为满足下述条件的任意真值指派： \\[ \\sigma^{*}(p)=\\left\\lbrace \\begin{array}{ll} \\sigma(p) &amp; \\text{如果~} p \\text{~出现在~} \\varphi \\text{~中} \\\\ \\sigma^{\\prime}(p) &amp; \\text{如果~} p \\text{~出现在~} \\psi \\text{~中} \\end{array}\\right. \\] 由于 \\(\\varphi\\) 和 \\(\\psi\\) 不含相同的命题变号，易见满足上述条件的真值指派是存在的，于是根据命题 3.12，\\(\\sigma^* \\nvDash \\varphi\\) 并且 \\(\\sigma^* \\nvDash \\psi\\)，进而 \\(\\sigma^* \\nvDash \\varphi \\lor \\psi.\\) ▗ 命题 中的另外两条留作练习（见习题 3.20） 4.5 范式 范式是具有某种特殊形式的公式，这种特殊形式帮助我们认识公式的一些性质和关系，而且在机器证明中也有应用。 4.5.1 合取范式 一个公式是合取范式（of conjunctive normal form）如果它形如 \\(\\varphi_0 \\land \\cdots \\land \\varphi_n\\) 并且对每一个 \\(i \\leqslant n\\)，\\(\\varphi_i\\) 形如 \\(\\psi_0 \\lor \\cdots \\lor \\psi_{m_{i}}\\)，其中每个 \\(\\psi_j (j \\leqslant m_{i})\\) 都或是命题变号，或是命题变号的否定。粗略地说，合取范式是个合取式，而其合取支都是命题变号或其否定的析取式。（Wang［1981］中把命题变号或其否定的析取式称作「简单析取」。）对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\psi\\) 是 \\(\\varphi\\) 的合取范式当且仅当下列条件成立： \\(\\psi\\) 是合取范式， \\(\\psi\\) 与 \\(\\varphi\\) 重言等值。 例 3.20 下列公式都是合取范式 &gt; \\(p\\) &gt; \\(\\neg p \\lor q\\) &gt; \\(p \\land \\neg q \\land r \\land \\neg p\\) &gt; \\((p \\lor \\neg q) \\land \\neg p\\) &gt; \\((p \\lor \\neg q) \\land(\\neg p \\lor r \\lor q) \\land(p \\lor \\neg r)\\) 注意：合取范式定义中的 \\(n\\) 和 \\(m_i\\) 等可以是任何自然数，并且它们之间可以没有任何关系。单个命题变号 \\(p\\) 之所以是合取范式，是因为合取范式的定义允许 \\(n = 0\\) 且 \\(m_0 = 0\\) 的情况。\\(\\neg p \\lor q\\) 是 \\(n = 0\\) 且 \\(m_0 = 1\\) 时的情况，而 \\(p \\land \\neg q \\land r \\land \\neg p\\) 是 \\(n = 3\\) 且 \\(m_0,\\cdots,m_3 = 0\\) 时的情况。 例 3.21 下列编号公式是对应无编号公式的合取范式 &gt; - \\(p \\rightarrow q\\) &gt; - \\(\\neg q \\rightarrow \\neg p\\) &gt; - \\(p \\rightarrow q\\) &gt; - \\(p \\wedge q \\rightarrow r\\) &gt; - \\(\\neg(p \\wedge r \\rightarrow \\neg q)\\) &gt; - \\(p \\vee q \\rightarrow \\neg r\\) &gt; 1. \\(\\neg p \\vee q\\) &gt; 1. \\(\\neg p \\vee q\\) &gt; 1. \\(q \\vee \\neg p\\) &gt; 1. \\(\\neg p \\vee \\neg q \\vee r\\) &gt; 1. \\(p \\wedge q \\wedge r\\) &gt; 1. \\((\\neg p \\vee \\neg r) \\wedge(\\neg q \\vee \\neg r)\\) 易见：不同的公式可以有相同的合取范式，而同一个公式也可以有不同的合取范式。 4.5.2 析取范式 —个公式是析取范式（of disjunctive normal form）如果它形如 \\(\\varphi_0 \\lor \\cdots \\lor \\varphi_n\\) 并且对每一个 \\(i \\leqslant n\\)，\\(\\varphi_i\\) 形如 \\(\\psi_0 \\land \\cdots \\land \\psi_{m_{i}}\\)，其中每个 \\(\\psi_j (j \\leqslant m_{i})\\) 都或是命题变号，或是命题变号的否定。粗略地说，析取范式是个析取式，而其析取支都是命题变号或其否定的合取式。对所有公式 \\(\\varphi\\) 和 \\(\\psi\\)，\\(\\psi\\) 是 \\(\\varphi\\) 的析取范式当且仅当下列条件成立： \\(\\psi\\) 是析取范式， \\(\\psi\\) 与 \\(\\varphi\\) 重言等值。 例 3.22 下列公式都是析取范式 &gt; 1. \\(p\\) &gt; 1. \\(\\neg p \\lor q\\) &gt; 1. \\(p \\land \\neg q \\land r \\land \\neg p\\) &gt; 1. \\((p \\lor \\neg q) \\lor \\neg p\\) &gt; 1. \\((p \\land \\neg q) \\lor (\\neg p \\land r \\land q) \\land(p \\land \\neg r)\\) 与前面的说明类似，\\(p\\) 之所以是析取范式，是因为析取范式的定义允许 \\(n = 0\\) 且 \\(m_0 = 0\\) 的情况。\\(\\neg p \\lor q\\) 是 \\(n = 1\\) 且 \\(m_0, m_1 = 0\\) 时的情况，而 \\(p \\land \\neg q \\land r \\land \\neg p\\) 是 \\(n = 0\\) 且 \\(m_0 = 3\\) 时的情况。 例 3.23 下列编号公式是对应无编号公式的析取范式 &gt; - \\(p \\rightarrow q\\) &gt; - \\(\\neg q \\rightarrow \\neg p\\) &gt; - \\(p \\rightarrow q\\) &gt; - \\(p \\wedge q \\rightarrow r\\) &gt; - \\(\\neg(p \\wedge r \\rightarrow \\neg q)\\) &gt; - \\(p \\vee q \\rightarrow \\neg r\\) &gt; 1. \\(\\neg p \\vee q\\) &gt; 1. \\(\\neg p \\vee q\\) &gt; 1. \\(q \\vee \\neg p\\) &gt; 1. \\(\\neg p \\vee \\neg q \\vee r\\) &gt; 1. \\(p \\wedge q \\wedge r\\) &gt; 1. \\((\\neg p \\land \\neg r) \\lor \\neg r\\) 易见：不同的公式可以有相同的析取范式，而同一个公式也可以有不同的析取范式。比较例 3.20 和例 3.22 以及例 3.21 和例 3.23，可知一个公式的析取范式与它的合取范式也可以是同一个公式。读者应对照定义，检查上述例子中的合取范式和析取范式，以求准确把握范式的概念。 4.5.3 范式定理 由于范式在形式方面的特点，很多时候处理范式比处理一般公式要容易。比如，要确定一个合取范式 \\(\\varphi_0 \\land \\cdots \\land \\varphi_n\\) 是否重言式，我们只需看每一个 \\(\\varphi_i(i \\leqslant n)\\) 中是否都有某个命题变号及其否定。满足这一条件的就是重言式，不满足的就不是重言式。类似地，要判断一个析取范式 \\(\\varphi_0 \\lor \\cdots \\lor \\varphi_n\\) 是否矛盾式，我们只需看每一个 \\(\\varphi_i(i \\leqslant n)\\) 中是否都有某个命题变号及其否定。满足这一条件的就是矛盾式，不满足的就不是矛盾式。参见命题 3.7。 如果每个公式都有它的合取范式和析取范式，那么很多关于公式的问题就可以归结为范式的问题，从而降低解决这些问题的难度。事实上，每一个公式都既有它的合取范式也有它的析取范式。我们先来看公式的析取范式的存在问题。 {{% dtpc title=“☯定理 3.2【析取范式存在定理】” %}} 任何公式都有析取范式，亦即对每个公式 \\(\\varphi\\)，存在一个公式 \\(\\varphi^{\\prime}\\) 使得 \\(\\varphi^{\\prime}\\) 是析取范式并与 \\(\\varphi\\) 重言等值。 {{% /dtpc %}} 这个命题有时被称作析取范式存在定理。我们这里不做严格的证明，只给出找到任给公式的析取范式的一个方法。对证明有兴趣的读者可以参照命题117的证明试着给出这个命题的证明。（参见习题 3.22） 考虑任意公式 \\(\\varphi.\\) 设 \\(\\varphi\\) 中出现的命题变号为 \\(q_0,\\cdots,q_{n-1}\\)，并令 \\(A = \\lbrace q_0,\\cdots,q_{n-1}\\rbrace.\\) 我们知道，\\(A\\)-赋值（亦即 \\(q_0,\\cdots,q_{n-1}\\) 的可能取值组合）总共有 \\(2^n\\) 个。如果 \\(\\varphi\\) 是矛盾式，我们令 \\(\\varphi^{\\prime} = q_0 \\land \\neg q_0 \\land q_1 \\land \\cdots \\land q_{n-1}.\\)（\\(\\varphi^{\\prime}\\) 的选择有多种。我们这里选择的是的 \\(q_0,\\cdots,q_{n-1}\\) 都出现的、尽可能简单的和矛盾的析取范式。） 易见 \\(\\varphi^{\\prime}\\) 是析取范式并与 \\(\\varphi\\) 重言等值。假设 \\(\\varphi\\) 不是矛盾式，并设 \\(\\tau_{0}, \\cdots, \\tau_{k} (k&lt;2^{n})\\) 为使得 \\(\\varphi\\) 的值为 1 的全部 \\(A\\)-赋值。对每个 $i k $ 和每个 \\(j &lt; n\\)，定义 \\(\\theta_{j}^{i}\\) 如下： \\[ \\theta_{j}^{i}=\\left\\lbrace \\begin{array}{ll} q_{j} &amp; \\text { 如果 }~ \\tau_{i}\\left(q_{j}\\right)=1 \\\\ \\neg q_{j} &amp; \\text { 如果 }~ \\tau_{i}\\left(q_{j}\\right)=0 \\end{array}\\right. \\] 并且对每个 \\(i \\leqslant k\\)，定义 \\(\\psi_{i}=\\theta_{0}^{i} \\wedge \\cdots \\wedge \\theta_{n-1}^{i}.\\) 最后令 \\(\\varphi^{\\prime}=\\psi_{0} \\vee \\cdots \\vee \\psi_{k}.\\) 易见 \\(\\varphi^{\\prime}\\) 是析取范式，并且可以证明 \\(\\varphi^{\\prime}\\) 与 \\(\\varphi\\) 重言等值。 例 3.24 求公式 \\((p \\rightarrow q) \\rightarrow q \\land \\neg r\\) 的析取范式。 解：令 \\(\\varphi = (p \\rightarrow q) \\rightarrow q \\land \\neg r.\\) \\(\\varphi\\) 的真值表如下： \\[ \\begin{array}{ccc|c|l} p &amp; q &amp; r &amp; (p \\rightarrow q) \\rightarrow q \\wedge \\neg r &amp; \\text{令}\\\\ \\hline 1 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\\\ 1 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\psi_{1}=p \\wedge q \\wedge \\neg r\\\\ 1 &amp; 0 &amp; 1 &amp; ~~1 &amp; \\psi_{2}=p \\wedge \\neg q \\wedge r\\\\ 1 &amp; 0 &amp; 0 &amp; ~~1 &amp; \\psi_{3}=p \\wedge \\neg q \\wedge \\neg r\\\\ 0 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\\\ 0 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\psi_{4}=\\neg p \\wedge q \\wedge \\neg r\\\\ 0 &amp; 0 &amp; 1 &amp; ~~0 &amp; \\\\ 0 &amp; 0 &amp; 0 &amp; ~~0 &amp; \\end{array} \\] 最后令 \\(\\varphi^{\\prime}=\\psi_{1} \\vee \\psi_{2} \\vee \\psi_{3} \\vee \\psi_{4}\\)，亦即 \\[\\varphi^{\\prime}=(p \\wedge q \\wedge \\neg r) \\vee(p \\wedge \\neg q \\wedge r) \\vee(p \\wedge \\neg q \\wedge \\neg r) \\vee(\\neg p \\wedge q \\wedge \\neg r).\\] 可以证明，\\(\\varphi^{\\prime}\\) 是 \\(\\varphi\\) 的一个析取范式。 下面我们来看公式的合取范式的存在问题。 {{% dtpc title=“☯定理 3.3【合取范式存在定理】” %}} 任何公式都有合取范式，亦即对每个公式 \\(\\varphi\\)，存在一个公式 \\(\\varphi^{\\prime}\\) 使得 \\(\\varphi^{\\prime}\\) 是合取范式并与 \\(\\varphi\\) 重言等值。 {{% /dtpc %}} 这个命题有时被称作合取范式存在定理。与上述类似，我们这里不做严格的证明，只给出找到任给公式的合取范式的一个方法。（参见习题 3.22） 考虑任意公式 \\(\\varphi.\\) 设 \\(\\varphi\\) 中出现的命题变号为 \\(q_0,\\cdots,q_{n-1}\\)，并令 \\(A = \\lbrace q_0,\\cdots,q_{n-1}\\rbrace.\\) 如果 \\(\\varphi\\) 是重言式，我们令 \\(\\varphi^{\\prime} = q_0 \\lor \\neg q_0 \\lor q_1 \\lor \\cdots \\lor q_{n-1}.\\)（\\(\\varphi^{\\prime}\\) 的选择有多种。我们这里选择的是的 \\(q_0,\\cdots,q_{n-1}\\) 都出现的、尽可能简单的和重言的合取范式。）易见 \\(\\varphi^{\\prime}\\) 是合取范式并与 \\(\\varphi\\) 重言等值。假设 \\(\\varphi\\) 不是重言式，并设 \\(\\tau_{0}, \\cdots, \\tau_{k} (k&lt;2^{n})\\) 为使得 \\(\\varphi\\) 的值为 0 的全部 \\(A\\)-赋值。对每个 \\(i \\leqslant k\\) 和每个 \\(j &lt; n\\)，定义 \\(\\theta_{j}^{i}\\) 如下： \\[ \\theta_{j}^{i}=\\left\\lbrace \\begin{array}{ll} q_{j} &amp; \\text { 如果 }~ \\tau_{i}\\left(q_{j}\\right)=0 \\\\ \\neg q_{j} &amp; \\text { 如果 }~ \\tau_{i}\\left(q_{j}\\right)=1 \\end{array}\\right. \\] 并且对每个 \\(i \\leqslant k\\)，定义 \\(\\psi_{i}=\\theta_{0}^{i} \\lor \\cdots \\lor \\theta_{n-1}^{i}.\\) 最后令 \\(\\varphi^{\\prime}=\\psi_{0} \\land \\cdots \\land \\psi_{k}.\\) 易见 \\(\\varphi^{\\prime}\\) 是合取范式，并且可以证明 \\(\\varphi^{\\prime}\\) 与 \\(\\varphi\\) 重言等值。 例 3.25 求公式 \\((p \\rightarrow q) \\rightarrow q \\land \\neg r\\) 的析取范式。 解：令 \\(\\varphi = (p \\rightarrow q) \\rightarrow q \\land \\neg r.\\) \\(\\varphi\\) 的真值表如下： \\[ \\begin{array}{ccc|c|l} p &amp; q &amp; r &amp; (p \\rightarrow q) \\rightarrow q \\wedge \\neg r &amp; \\text{令}\\\\ \\hline 1 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\psi_{1}=\\neg p \\lor \\neg q \\lor \\neg r\\\\ 1 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\\\ 1 &amp; 0 &amp; 1 &amp; ~~1 &amp; \\\\ 1 &amp; 0 &amp; 0 &amp; ~~1 &amp; \\\\ 0 &amp; 1 &amp; 1 &amp; ~~0 &amp; \\psi_{2}=p \\lor \\neg q \\lor \\neg r\\\\ 0 &amp; 1 &amp; 0 &amp; ~~1 &amp; \\\\ 0 &amp; 0 &amp; 1 &amp; ~~0 &amp; \\psi_{3}=p \\lor q \\lor \\neg r\\\\ 0 &amp; 0 &amp; 0 &amp; ~~0 &amp; \\psi_{4}=p \\lor q \\lor r \\end{array} \\] 最后令 \\(\\varphi^{\\prime}=\\psi_{1} \\land \\psi_{2} \\land \\psi_{3} \\land \\psi_{4}\\)，亦即 \\[\\varphi^{\\prime}=(\\neg p \\lor \\neg q \\lor \\neg r) \\land (p \\lor \\neg q \\lor \\neg r) \\land (p \\lor q \\lor \\neg r) \\land (p \\lor q \\lor r).\\] 可以证明，\\(\\varphi^{\\prime}\\) 是 \\(\\varphi\\) 的一个析取范式。 在上面讲解公式的范式存在问题时，我们使用了真值表方法，即语义的方法。假如我们求公式的范式仅仅是要判断给定公式是否重言式（或矛盾式），那么用上述方法求范式无疑是事倍功半。这是因为，在写出给定公式的范式之前，我们先构造了该公式的真值表，而从这个真值表我们已经知道该公式是否重言式（或矛盾式）。不过，上面的讲解只是说明任何公式都存在合取范式和析取范式，而且只是用我们已经学会的真值表方法。事实上，求范式的方法不仅是语义的方法，而范式的存在问题也并不就是判断重言式或矛盾式的问题。 4.6 函数完全性 4.6.1 真值函数在形式语言中的表达 显然，真值函数可以有无穷多。在如此多的函数中，有些明显可以用其他真值函数来合成或复合（compose）。比如示例 3.19 中的 \\(f_{16}\\) 显然可以用 \\(f_1\\) 和 \\(f_\\neg\\) 来合成，亦即 \\(f_{16}(x,y)=f_{\\neg}(f_{1}(x,y))\\)。那么，有没有一集真值函数（最好不要太多）可以合成所有的真值函数？如果有，哪些真值函数集可以合成所有的真值函数？简单地说，这就是「函数完全性」问题。 这样的问题当然是数学问题。我们寻找数学问题的解，部分地是因为它们往往有解。但我们关心函数完全性问题决不仅仅是因为它有解或很可能有解。函数完全性问题和形式语言的「表达力」有直接关系。\\(\\mathscr{L}_0\\)-公式能表达什么？让我们来看两个例子。 先看公式 \\(p \\lor q.\\) 当考虑公式的值时，命题变号 \\(p\\) 和 \\(q\\) 是取值于 \\(\\lbrace 0, 1\\rbrace\\) 的变元，而一旦它们的取值确定了，\\(p \\lor q\\) 的值（真值）也就经 \\(f_\\lor\\) 唯一地确定了。在这个意义上，我们说 \\(p \\lor q\\) 表达了真值函数 \\(f_\\lor.\\)（假如我们一开始就把所有的析取式都写成 \\(\\lor (\\varphi, \\psi)\\) 的样子，那么 \\(\\lor (p, q)\\) 和 \\(f_{\\lor}(x,y)\\) 即使在形式上也非常接近。） 再来看公式 \\((p \\lor q) \\land \\neg(p \\land q)\\)，我们可以把它记为 \\(p \\veebar q.\\) \\(p\\) 和 \\(q\\) 的取值（真值）一旦确定，\\(p \\veebar q\\) 的值（真值）也就经 \\(f_{\\lor}, f_{\\land}\\) 和 \\(f_{\\neg}\\) 的某种复合（当然也是一个真值函数）唯一地确定了（参见式子 3.13 中第二和第三行）。在这个意义上，我们说 \\(p \\veebar q\\) 表达了一个真值函数。事实上，\\(\\veebar\\) 可以被当作一个真值函数联结词，即通常被称为「不相容析取」的联结词（the exclusive or，XOR），它的解释是示例 3.19 中的 \\(f_{10}\\)，而这个函数显然可由 \\(f_{\\lor}, f_{\\land}\\) 和 \\(f_{\\neg}\\) 来合成：\\(f_{10}(x, y)=f_{\\land}(f_{\\lor}(x, y), f_{\\neg}(f_{\\land}(x, y))).\\)（参见 §12.2.1（P.198）中对「不相容选言推理」的介绍。） 下面我们来严格地定义 \\(\\mathscr{L}_0\\)-公式对真值函数的表达。在这一节中，凡谈到命题变号 \\(q_0, \\cdots, q_n\\) 时，我们总是假定它们是不同的命题变号，并且对所有 \\(i, j \\leqslant n\\) 如果 \\(i &lt; j\\)，那么 \\(q_i\\) 按命题变号的字典顺序排在 \\(q_j\\) 之前。（参见§3.0.0（P.99）中的说明。） {{% dtpc title=“☯定义 3.15【真值函数的表达】” %}} 设 \\(\\varphi\\) 为含 \\(n\\) 个命题变号 \\(q_0, \\cdots, q_{n-1}\\) 的任意 \\(\\mathscr{L}_0\\)-公式，并且设 \\(f\\) 为任意的 \\(n\\) 元真值函数。\\(\\varphi\\) 表达 \\(f\\) 当且仅当对所有的真值指派 \\(\\sigma\\)，\\(\\varphi^{\\sigma}=f(q_{0}^{\\sigma}, \\cdots, q_{n-1}^{\\sigma}).\\) \\(f\\) 在 \\(\\mathscr{L}_{0}\\) 中可表达当且仅当有某个 \\(\\mathscr{L}_{0}\\)-公式 \\(\\varphi\\) 表达 \\(f.\\) {{% /dtpc %}} 注意：定义3.15 中的 \\(q_0, \\cdots, q_{n-1}\\) 是根据命题变号集 \\(\\mathbf{Pr}\\) 上固定的字典顺序排列的。这个限制的理由很简单：如果没有这条限制，含相同命题变号而又不重言等值的公式也可以「表达」同一个真值函数。 比如，假定我们将定义 3.15 中的这种限制去掉，那么 \\(p \\rightarrow q\\) 可以「表达」\\(f_{\\rightarrow}\\)（因为 \\((p \\rightarrow q)^{\\sigma}= f_{\\rightarrow}(p^{\\sigma}, q^{\\sigma})\\) 对所有 \\(\\sigma\\) 成立），\\(q \\rightarrow p\\) 也可以「表达」（因为 \\((q \\rightarrow p)^{\\sigma}=f_{\\rightarrow}(q^{\\sigma}, p^{\\sigma})\\) 对所有 \\(\\sigma\\) 也成立）。当然，这并不是说，「表达」只能像我们上面那样定义。我们可以放弃对命题变号序列的那些限制，但我们必须同时放弃一类要求或想法，比如「含有相同命题变号的公式表达同一真值函数当且仅当它们重言等值」等等。 「表达」也可以相对于其他命题逻辑语言来定义。这里说的命题逻辑语言都与 \\(\\mathscr{L}_0\\) 相似：它们有共同的命题变号（和括号），但有不同的联结词；公式形成规则相仿，真理定义也相仿（参见式子 3.13 和定义 3.14 ，其中「真值指派」和「对部分命题变号的赋值」意义不变），差别就在联结词及其语义解释。请读者补充这些命题逻辑语言的严格定义，以及关于它们公式真值的真理定义。我们约定： 语言 \\(\\mathscr{L}_{\\odot}\\) 中的真值函数联结词是 \\[\\odot_{1}, \\cdots, \\odot_{k},\\] \\(\\mathscr{L}_{\\odot}\\)-公式是只用命题变号和 \\[\\odot_{1}, \\cdots, \\odot_{k}\\] 构造出来的合式的符号串。 \\(\\mathscr{L}_{\\odot}\\)-公式对真值函数的「表达」和「函数完全性」的定义如下： {{% dtpc title=“☯定义 3.16【表达】” %}} 设 \\(\\varphi\\) 为含 \\(n\\) 个命题变号 \\(q_{0}, \\cdots, q_{n-1}\\) 的任意 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\)-公式，并设 \\(f\\) 为任意的 \\(n\\) 元真值函数。\\(\\varphi\\)（在 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\) 中）表达 \\(f\\) 当且仅当对所有真值指派 \\(\\sigma\\)，\\(\\varphi^{\\sigma}=f(q_{0}^{\\sigma}, \\cdots, q_{n-1}^{\\sigma}).\\) \\(f\\) 在 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\) 中可表达当且仅当有某个 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\)-公式 \\(\\varphi\\) 表达 \\(f.\\) {{% /dtpc %}} {{% dtpc title=“☯定义 3.17【函数完全】” %}} 设 \\(\\mathbb{C}=\\lbrace \\odot_{1}, \\cdots, \\odot_{k}\\rbrace\\) 为真值函数联结词的集合。\\(\\mathbb{C}\\) 是函数完全的当且仅当所有的真值函数都在 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\) 中可表达。 {{% /dtpc %}} 注意：我们并没有像本节一开始谈论的那样，把可以合成所有真值函数的真值函数集定义为函数完全的。定义 3.17 中既没有谈真值函数的集合，也没有谈真值函数的合成——它谈的是真值函数联结词的集合以及真值函数在有这些联结词的语言里的表达。但这两种谈法的结果是一样的，虽然我们不做证明。 {{% dtpc title=“☯定义 3.18【可定义】” %}} 设 \\(\\odot\\) 为任意 \\(n\\) 元真值函数联结词，\\(f_{\\odot}\\) 为其语义解释。\\(\\odot\\) 是 \\(\\lbrace \\odot_{1}, \\cdots, \\odot_{k}\\rbrace\\) 可定义的当且仅当 \\(f_{\\odot}\\) 在 \\(\\mathscr{L}_{\\odot_{1}, \\cdots, \\odot_{k}}\\) 中可表达。 {{% /dtpc %}} 如果一集真值函数联结词 \\(\\mathbb{C}\\) 有函数完全性，那么用 \\(\\mathbb{C}\\) 做初始联结词的命题逻辑语言就有了完善的表达力。在这样的语言中，任何一个真值函数联结词都可以由 \\(\\mathbb{C}\\) 中的联结词来定义，就像任何一个真值函数都可以由解释 \\(\\mathbb{C}\\) 中联结词的真值函数来定义一样。 4.6.2 具有函数完全性的几组真值函数联结词 这一小节里我们讨论具有函数完全性的几个真值函数联结词的集合。 {{% dtpc title=“☯命题 3.15” %}} 所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\) 中可表达。 {{% /dtpc %}} 命题 3.15 之证明：令 \\(f\\) 为任意 \\(n\\) 元真值函数（\\(n &gt; 0\\)）。我们分两种情况讨论。 情况 I: 对所有的 \\(a_{0}, \\cdots, a_{n-1} \\in \\lbrace 0, 1\\rbrace\\) 都有 \\(f(a_{0}, \\cdots, a_{n-1})=0.\\) 令 \\(\\varphi=p_{0} \\wedge \\neg p_{0} \\wedge p_{1} \\wedge \\cdots \\wedge p_{n-1}.\\) 易见对所有真值指派 \\(\\sigma\\) 都有 \\(\\varphi^{\\sigma}=0\\)，所以在情况 I 下，\\(f\\) 在 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\) 中可表达。 情况 II: 存在 \\(a_{0}, \\cdots, a_{n-1} \\in \\lbrace 0, 1\\rbrace\\) 使得 \\(f(a_{0}, \\cdots, a_{n-1})=1.\\) 设 \\[\\begin{equation} b_{0}^{0}, \\cdots, b_{n-1}^{0}; \\quad b_{0}^{1}, \\cdots, b_{n-1}^{1} ; \\quad \\cdots ; \\quad b_{0}^{k}, \\cdots, b_{n-1}^{k} \\end{equation}\\] \\((k&lt;2^{n})\\) 为所有的真值序列 \\(a_{0}, \\cdots, a_{n-1} \\in\\lbrace 0, 1\\rbrace\\) 使得 \\(f(a_{0}, \\cdots, a_{n-1})=1.\\) 对每个 \\(i \\leqslant k\\) 和 \\(j &lt; n\\)，令 \\[ \\theta_{j}^{i}=\\left\\lbrace \\begin{array}{ll} p_{j} &amp; \\text { 如果 }~ b_{j}^{i}=1 \\\\ \\neg p_{j} &amp; \\text { 如果 }~ b_{j}^{i}=0 \\end{array}\\right. \\] 且对每个 \\(i \\leqslant k\\)，令 \\(\\psi_{i}=\\theta_{0}^{i} \\wedge \\cdots \\wedge \\theta_{n-1}^{i}.\\) 最后，令 \\(\\varphi=\\psi_{0} \\vee \\cdots \\vee \\psi_{k}.\\) 以下证明 \\(\\varphi\\) 表达 \\(f.\\) 令 \\(\\sigma\\) 为任意真值指派。 设 \\(f(p_{0}^{\\sigma}, \\cdots, p_{n-1}^{\\sigma})=1.\\) 易见式子 (10) 中某个序列 \\(b_{0}^{i}, \\cdots, b_{n-1}^{i}(i \\leqslant k)\\) 就是 \\(p_{0}^{\\sigma}, \\cdots, p_{n-1}^{\\sigma}.\\) 由 \\(\\theta_{j}^{i}\\) 的定义知，对每个 \\(j&lt;n\\)，如果 \\(p_{j}^{\\sigma}=1\\) 则 \\(\\theta_{j}^{i}=p_{j}\\)，而如果 \\(p_{j}^{\\sigma}=0\\) 则 \\(\\theta_{j}^{i}=\\neg p_{j}.\\) 这就是说，对每个 \\(j&lt;n\\) 都有 \\((\\theta_{j}^{i})^{\\sigma}=1\\)，所以\\(\\psi_{i}^{\\sigma}=1\\)，进而 \\(\\varphi^{\\sigma}=1.\\) 设 \\(\\varphi^{\\sigma}=1.\\) 根据 \\(\\varphi\\) 的定义，存在 \\(i \\leqslant k\\) 使得 \\(\\psi_{i}^{\\sigma}=1\\)，从而对每个 \\(j&lt;n\\) 都有 \\((\\theta_{j}^{i})^{\\sigma}=1.\\) 根据 \\(\\theta_{j}^{i}\\) 的定义，如果 \\(p_{j}^{\\sigma}=1\\) 则 \\(b_{j}^{i}=1\\)，并且如果 \\(p_{j}^{\\sigma}=0\\)，则 \\(b_{j}^{i}=0.\\) 这就是说，真值序列 \\(p_{0}^{\\sigma}, \\cdots, p_{n-1}^{\\sigma}\\) 就是式子 (10) 中的 \\(b_{0}^{i}, \\cdots, b_{n-1}^{i} .\\) 既然 \\(f(b_{0}^{i}, \\cdots, b_{n-1}^{i})=1\\)，我们有 \\(f(p_{0}^{\\sigma}, \\cdots, p_{n-1}^{\\sigma})=1.\\) 综上所述，可知 \\(f\\) 在 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\) 中可表达。▗ {{% dtpc title=“☯定理 3.4【函数完全性定理】” %}} 1. 所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\lor}\\) 中可表达 1. 所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\land}\\) 中可表达 1. 所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\rightarrow}\\) 中可表达 {{% /dtpc %}} 证明：易证对所有 \\(\\mathscr{L}_{0}\\)-公式 \\(\\chi\\) 和 \\(\\chi^{\\prime}\\)，\\(\\chi \\wedge \\chi^{\\prime}\\) 和 \\(\\neg(\\neg \\chi \\vee \\neg \\chi^{\\prime})\\) 重言等值（习题 3.5）。 因而对每个 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\)-公式 \\(\\varphi\\)，运用若干次推论 3.3 可以得到 \\(\\mathscr{L}_{\\neg, \\lor}\\)-公式 \\(\\varphi^{\\prime}\\)， 使得 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 重言等值并且 \\(\\varphi\\) 和 \\(\\varphi^{\\prime}\\) 含相同的命题变号（习题 3.25）。 令 \\(f\\) 为任意 \\(n\\) 元真值函数。由命题 3.15 知有 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\)-公式 \\(\\varphi\\) 表达 \\(f\\)， 因而 \\(\\varphi\\) 含命题变号 \\(q_{0}, \\cdots, q_{n-1}\\)，且对所有真值指派 \\(\\sigma\\)，\\(\\varphi^{\\sigma}=f(q_{0}^{\\sigma}, \\cdots, q_{n-1}^{\\sigma}).\\) 由上述可知，存在 \\(\\mathscr{L}_{\\neg, \\lor}\\)-公式 \\(\\psi\\)，\\(\\psi\\) 含命题变号 \\(q_{0}, \\cdots, q_{n-1}\\) 并且 \\(\\psi^{\\sigma}= f\\left(q_{0}^{\\sigma}, \\cdots, q_{n-1}^{\\sigma}\\right)\\), 所以 \\(f\\) 在 \\(\\mathscr{L}_{\\neg, \\lor}\\) 中可表达。 因为 \\(\\chi \\vee \\chi^{\\prime}\\) 和 \\(\\neg(\\neg \\chi \\wedge \\neg \\chi^{\\prime})\\) 重言等值，所以类似可证所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\land}\\) 中可表达。 因为 \\(\\chi \\vee \\chi^{\\prime}\\) 和 \\(\\neg \\chi \\rightarrow \\chi^{\\prime}\\) 以及 \\(\\chi \\wedge \\chi^{\\prime}\\) 和 \\(\\neg(\\chi \\rightarrow \\neg \\chi^{\\prime})\\) 分别重言等值，所以类似可证所有真值函数都在 \\(\\mathscr{L}_{\\neg, \\rightarrow}\\) 中可表达。▗ {{% dtpc title=“☯定理 3.5【函数完全性定理】” %}} \\(\\lbrace \\neg, \\land\\rbrace, \\lbrace \\neg, \\land\\rbrace, \\lbrace \\neg, \\rightarrow\\rbrace\\) 各自都是函数完全的，并且各自都可定义所有的真值函数联结词。 {{% /dtpc %}} 证明：根据定理 3.5、定义 3.17 和定义 3.18 得证。▗ 函数完全的真值函数联结词的集合，可以只有两个元素，比如 \\(\\lbrace \\neg, \\lor\\rbrace\\)，也可以只有一个元素。英文中有两个一元联结词 “not-both”（NAND） 和 “neither-nor”（NOR），我们用 “\\(\\mid\\)” 和 “\\(\\mid\\mid\\)” 来表示它们。算上 \\(\\veebar\\) 与这两个联结词，基本真值表 2.1（P.82）便成为如下扩展的真值表： {{% freebox title=“扩展的基本真值表” %}} \\[ \\begin{array}{cc|cccccccc} p &amp; q &amp; p \\vee q &amp; p \\wedge q &amp; p \\rightarrow q &amp; p \\leftrightarrow q &amp; p \\veebar q &amp; p \\mid\\mid q &amp; p \\mid q &amp; \\neg p\\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; \\\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; \\end{array} \\] {{% /freebox %}} 可以证明，\\(\\lbrace \\mid\\rbrace, \\lbrace || \\rbrace\\) 也分别都是函数完全的。我们不给详细证明，只陈述证明中用到的最关键事实： \\(\\varphi \\mid \\varphi\\) 可用来表示 \\(\\neg \\varphi\\)，\\((\\varphi \\mid \\varphi) \\mid (\\psi \\mid \\psi)\\) 可用来表示 \\(\\varphi \\vee \\psi\\) 见下表： \\[ \\begin{array}{c|c|c} \\varphi &amp; \\neg \\varphi &amp; \\varphi \\mid \\varphi \\\\ \\hline 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\end{array} \\] \\[ \\begin{array}{cc|c|c} \\varphi &amp; \\psi &amp; \\varphi \\vee \\psi &amp; (\\varphi \\mid \\varphi) \\mid (\\psi \\mid \\psi) \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\] \\(\\varphi \\| \\varphi\\) 可用来表示 \\(\\neg \\varphi\\)，\\((\\varphi \\| \\varphi) \\| (\\psi \\| \\psi)\\) 可用来表示 \\(\\varphi \\wedge \\psi\\) 见下表： \\[ \\begin{array}{c|c|c} \\varphi &amp; \\neg \\varphi &amp; \\varphi \\| \\varphi \\\\ \\hline 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 \\end{array} \\] \\[ \\begin{array}{cc|c|c} \\varphi &amp; \\psi &amp; \\varphi \\wedge \\psi &amp; (\\varphi \\| \\varphi)\\|(\\psi \\| \\psi) \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{array} \\] 4.7 本章习题 练习 4.1 证明：对所有公式集 \\(\\Gamma\\) 和 \\(\\Delta\\)，以及所有公式 \\(\\varphi\\) 与 \\(\\psi\\)： 如果 \\(\\Gamma \\vDash_{0} \\varphi\\)，那么 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\varphi\\); 如果 \\(\\Gamma \\vDash_{0} \\varphi \\vee \\psi\\) 并且 \\(\\Delta \\vDash_{0} \\neg \\varphi\\)，那么 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\psi\\); 如果 \\(\\Gamma \\vDash_{0} \\varphi\\) 且 \\(\\Delta \\vDash_{0} \\varphi \\rightarrow \\psi\\)，那么 \\(\\Gamma \\cup \\Delta \\vDash_{0} \\psi\\). 练习 4.2 设 \\(\\Delta \\vDash_{0} \\varphi\\) 并且 \\(\\varphi \\vDash_{0} \\psi\\). 证明：\\(\\Delta \\vDash_{0} \\psi\\). 练习 4.3 证明对所有公式 \\(\\varphi, \\psi, \\chi\\)，下述命题成立：： \\(\\varphi, \\varphi \\rightarrow \\psi \\vDash_{0} \\psi\\) \\(\\varphi \\vee \\psi, \\neg \\psi \\vDash_{0} \\varphi\\) \\(\\varphi \\vee \\psi, \\neg \\varphi \\vee \\chi \\vDash_{0} \\psi \\vee \\chi\\) \\(\\varphi \\vee \\psi \\vDash_{0} \\chi\\) 当且仅当 \\(\\varphi \\vDash_{0} \\chi\\) 且 \\(\\psi \\vDash_{0} \\chi\\). 练习 4.4 令 \\(\\varphi, \\psi, \\chi\\) 为任意公式。证明下列都是重言式： \\(\\varphi \\rightarrow(\\psi \\rightarrow \\varphi)\\) \\((\\varphi \\rightarrow(\\psi \\rightarrow \\chi)) \\rightarrow((\\varphi \\rightarrow \\psi) \\rightarrow(\\varphi \\rightarrow \\chi))\\) \\(\\varphi \\wedge \\psi \\rightarrow \\varphi\\) \\(\\varphi \\wedge \\psi \\rightarrow \\psi\\) \\(\\varphi \\rightarrow(\\psi \\rightarrow \\varphi \\wedge \\psi)\\) \\(\\varphi \\rightarrow \\varphi \\vee \\psi\\) \\(\\varphi \\rightarrow \\psi \\vee \\varphi\\) \\((\\varphi \\rightarrow \\chi) \\rightarrow((\\psi \\rightarrow \\chi) \\rightarrow(\\varphi \\vee \\psi \\rightarrow \\chi))\\) \\((\\varphi \\rightarrow \\psi) \\rightarrow((\\varphi \\rightarrow \\neg \\psi) \\rightarrow \\neg \\varphi)\\) \\(\\neg \\neg \\varphi \\rightarrow \\varphi\\) \\((\\varphi \\leftrightarrow \\psi) \\rightarrow(\\varphi \\rightarrow \\psi)\\) \\((\\varphi \\leftrightarrow \\psi) \\rightarrow(\\psi \\rightarrow \\varphi)\\) \\((\\varphi \\rightarrow \\psi) \\rightarrow((\\psi \\rightarrow \\varphi) \\rightarrow(\\varphi \\leftrightarrow \\psi))\\) 练习 4.5 令 \\(\\varphi, \\psi, \\chi\\) 为任意公式。证明下列都是重言式： \\((\\neg \\varphi \\rightarrow \\psi) \\rightarrow((\\neg \\varphi \\rightarrow \\neg \\psi) \\rightarrow \\varphi)\\) \\((\\neg \\psi \\rightarrow \\neg \\varphi) \\rightarrow(\\varphi \\rightarrow \\psi)\\) \\(((\\varphi \\rightarrow \\psi) \\rightarrow \\varphi) \\rightarrow \\varphi\\) \\(\\neg \\varphi \\rightarrow(\\varphi \\rightarrow \\psi)\\) \\((\\neg \\varphi \\rightarrow \\varphi) \\rightarrow \\varphi\\) \\((\\varphi \\rightarrow \\neg \\varphi) \\rightarrow \\neg \\varphi\\) \\((\\varphi \\leftrightarrow \\psi) \\leftrightarrow(\\psi \\leftrightarrow \\varphi)\\) \\(((\\varphi \\leftrightarrow \\chi) \\leftrightarrow(\\psi \\leftrightarrow \\varphi)) \\leftrightarrow(\\chi \\leftrightarrow \\psi)\\) \\((\\varphi \\leftrightarrow(\\psi \\leftrightarrow \\chi)) \\leftrightarrow((\\varphi \\leftrightarrow \\psi) \\leftrightarrow \\chi)\\) 练习 4.6 证明对所有公式 \\(\\varphi, \\psi, \\chi\\)，下列各组公式都是重言等值的： \\(\\varphi, \\varphi \\vee \\varphi, \\varphi \\wedge \\varphi\\) \\(\\varphi, \\neg \\neg \\varphi\\) \\(\\varphi \\vee \\psi, \\psi \\vee \\varphi\\) \\(\\varphi \\wedge \\psi, \\psi \\wedge \\varphi\\) \\(\\varphi \\vee(\\psi \\vee \\chi),(\\varphi \\vee \\psi) \\vee \\chi\\) \\(\\varphi \\wedge(\\psi \\wedge \\chi),(\\varphi \\wedge \\psi) \\wedge \\chi\\) \\(\\neg(\\varphi \\vee \\psi), \\neg \\varphi \\wedge \\neg \\psi\\) \\(\\varphi \\vee \\psi, \\neg(\\neg \\varphi \\wedge \\neg \\psi)\\) \\(\\neg(\\varphi \\wedge \\psi), \\neg \\varphi \\vee \\neg \\psi\\) \\(\\varphi \\wedge \\psi, \\neg(\\neg \\varphi \\vee \\neg \\psi)\\) \\(\\varphi \\rightarrow \\psi, \\neg \\psi \\rightarrow \\neg \\varphi\\) \\(\\varphi \\vee(\\psi \\wedge \\chi),(\\varphi \\vee \\psi) \\wedge(\\varphi \\vee \\chi)\\) \\(\\varphi \\wedge(\\psi \\vee \\chi),(\\varphi \\wedge \\psi) \\vee(\\varphi \\wedge \\chi)\\) \\(\\varphi \\rightarrow \\psi, \\neg \\varphi \\vee \\psi\\) \\(\\neg \\varphi \\rightarrow \\psi, \\varphi \\vee \\psi\\) \\(\\varphi \\leftrightarrow \\psi,(\\varphi \\wedge \\psi) \\vee(\\neg \\varphi \\wedge \\neg \\psi)\\) \\(\\varphi \\leftrightarrow \\psi,(\\varphi \\rightarrow \\psi) \\wedge(\\psi \\rightarrow \\varphi)\\) \\(\\neg(\\varphi \\leftrightarrow \\psi), \\varphi \\leftrightarrow \\neg \\psi, \\neg \\varphi \\leftrightarrow \\psi,(\\varphi \\wedge \\neg \\psi) \\vee(\\neg \\varphi \\wedge \\psi)\\) \\(\\varphi \\rightarrow(\\psi \\rightarrow \\chi), \\varphi \\wedge \\psi \\rightarrow \\chi, \\psi \\rightarrow(\\varphi \\rightarrow \\chi)\\) \\(\\varphi \\vee \\psi \\rightarrow \\chi,(\\varphi \\rightarrow \\chi) \\wedge(\\psi \\rightarrow \\chi)\\) 练习 4.7 证明：对所有公式集 \\(\\Gamma\\) 和所有公式 \\(\\varphi\\)： 如果 \\(\\Gamma \\vDash_{0} \\varphi\\) 且 \\(\\varphi\\)不可满足，那么 \\(\\Gamma\\) 不可满足。 如果 \\(\\Gamma\\) 可满足，那么 \\(\\lbrace \\psi: \\Gamma \\vDash_{0} \\psi\\rbrace\\) 也可满足。 练习 4.8 完成命题 3.7（P.105）的证明。 练习 4.9 证明：对所有公式 \\(\\varphi\\)： \\(\\varphi\\) 是重言式当且仅当 \\(\\neg \\varphi\\) 不可满足； \\(\\varphi\\) 是矛盾式当且仅当 \\(\\varphi\\) 不可满足； \\(\\varphi\\) 是或然式当且仅当 \\(\\varphi\\) 和 \\(\\neg \\varphi\\) 都可满足； \\(\\varphi\\) 是重言式当且仅当 \\(\\neg \\varphi\\) 是矛盾式； \\(\\varphi\\) 是矛盾式当且仅当 \\(\\neg \\varphi\\) 是重言式； \\(\\varphi\\) 是或然式当且仅当 \\(\\neg \\varphi\\) 是或然式。 练习 4.10 证明：对所有公式 \\(\\varphi\\)： \\(\\varphi\\) 是重言式当且仅当 \\(p_0 \\lor \\neg p_0\\) 重言蕴涵 \\(\\varphi\\). \\(\\varphi\\) 是矛盾式当且仅当 \\(\\varphi\\) 重言蕴涵 \\(p_0 \\land \\neg p_0\\). 练习 4.11 设 \\(\\mathfrak{s}^{\\prime}\\) 和 \\(\\mathfrak{s}^{\\prime \\prime}\\) 都是有穷代入。证明：\\(\\mathfrak{s}^{\\prime}\\mathfrak{s}^{\\prime \\prime}\\) 也是有穷代入。 练习 4.12 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意公式，并设 \\(p\\) 和 \\(q\\) 为任意命题变号，其中 \\(q\\) 不在 \\(\\varphi\\) 中出现。证明：\\(\\varphi(\\psi / p)=\\varphi(q / p)(\\psi / q)\\). 练习 4.13 证明：对所有公式 \\(\\varphi\\) 及其子公式 \\(\\psi\\)，存在公式 \\(\\chi\\) 和命题变号 \\(p\\) 使得 \\(\\varphi=\\chi(\\psi / p)\\)，并说明即使对同一个这样的 \\(p\\)，\\(\\chi\\) 也不是唯一的。 练习 4.14 设 \\(\\varnothing \\neq A \\subseteq \\mathbf{Pr}\\)，设 \\(\\mathfrak{s}\\) 和 \\(\\mathfrak{s}^{\\prime}\\) 为任意代入，并设 \\(\\sigma\\) 和 \\(\\sigma^{\\prime}\\) 为任意真值指派，满足对每一个 \\(p \\in A,(\\mathfrak{s}(p))^{\\sigma}=\\left(\\mathfrak{s}^{\\prime}(p)\\right)^{\\sigma^{\\prime}}\\). 证明：对所有 \\(A\\)-公式\\(\\varphi\\)，\\((\\varphi(\\mathfrak{s}))^{\\sigma}=(\\varphi(\\mathfrak{s}^{\\prime}))^{\\sigma^{\\prime}}\\). 练习 4.15 试从习题 3.13 直接证明定理 3.0（P.112）。 练习 4.16 试从定理 3.1 直接证明定理 3.0（P.112）。 练习 4.17 证明推论 3.4（P.114）（提示：先将置换结果讲清楚）；然后试用推论 3.4 直接证明推论 3.3。 练习 4.18 设 \\(\\varphi\\) 为重言式，并设 \\(\\mathfrak{s}\\) 为任意代入。证明：\\(\\varphi(\\mathfrak{s})\\) 是重言式。 练习 4.19 运用重言蕴涵等语义概念的「严格定义」，证明习题 2.17（P.97）和习题 2.18（P.98）中的各个命题。 练习 4.20 完成命题 3.13（P.118）的证明。 练习 4.21 证明下列命题。设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意不含相同命题变号的公式。证明： \\(\\varphi \\rightarrow \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 是矛盾式或者 \\(\\psi\\) 是重言式。 \\(\\varphi \\leftrightarrow \\psi\\) 是重言式当且仅当或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是矛盾式或者 \\(\\varphi\\) 和 \\(\\psi\\) 都是重言式。 练习 4.22 求下列公式的析取范式与合取范式： \\(p \\vee q \\rightarrow p \\wedge q\\) \\(p \\wedge q \\rightarrow(\\neg r \\rightarrow p)\\) \\((p \\rightarrow q \\wedge r) \\rightarrow(\\neg p \\rightarrow \\neg q \\wedge \\neg r)\\) \\((p \\rightarrow q \\vee \\neg r) \\leftrightarrow(r \\rightarrow q \\wedge \\neg p)\\) \\(p \\vee q \\rightarrow(p \\rightarrow \\neg q)\\) \\((p \\vee q) \\wedge((r \\rightarrow \\neg p \\wedge \\neg q) \\wedge(\\neg r \\rightarrow r))\\) \\((p \\rightarrow \\neg q \\wedge r) \\leftrightarrow(q \\vee(\\neg r \\wedge p))\\) \\(((p \\rightarrow q) \\rightarrow p) \\rightarrow q) \\rightarrow r\\) 练习 4.23 证明范式存在定理，即定理 3.2（P.120）和定理 3.3（P.121） 练习 4.24 证明：每个含 \\(n\\) 个命题变号 \\(q_0, \\cdots, q_{n-1}\\) 的 \\(\\mathscr{L}_0\\)-公式都表达一个 \\(n\\) 元真值函数。 练习 4.25 设 \\(\\varphi\\) 和 \\(\\psi\\) 为任意 \\(\\mathscr{L}_0\\)-公式，其中出现的命题变号相同。证明：\\(\\varphi\\) 与 \\(\\psi\\) 表达同一个真值函数当且仅当 \\(\\varphi\\) 与 \\(\\psi\\) 重言等值。 练习 4.26 证明：对每个 \\(\\mathscr{L}_{\\neg, \\lor, \\land}\\)-公式 \\(\\varphi\\)， 1. 存在 \\(\\mathscr{L}_{\\neg, \\lor}\\)-公式 \\(\\varphi^{\\prime}\\)，使得 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 重言等值并且 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 含相同的命题变号。 存在 \\(\\mathscr{L}_{\\neg, \\land}\\)-公式 \\(\\varphi^{\\prime}\\)，使得 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 重言等值并且 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 含相同的命题变号。 存在 \\(\\mathscr{L}_{\\neg, \\rightarrow}\\)-公式 \\(\\varphi^{\\prime}\\)，使得 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 重言等值并且 \\(\\varphi\\) 与 \\(\\varphi^{\\prime}\\) 含相同的命题变号。 练习 4.27 证明：用 \\(\\mid\\) 定义 \\(\\rightarrow\\) 和 \\(\\land\\)，用 \\(||\\) 定义 \\(\\lor\\) 和 \\(\\rightarrow\\)，并证明 \\(\\lbrace \\mid\\rbrace\\) 和 \\(\\lbrace \\|\\rbrace\\) 分别都是函数完全的。 练习 4.28 证明：\\(\\lbrace \\neg \\leftrightarrow\\rbrace\\) 不可定义 \\(\\lor\\)，\\(\\lbrace \\neg \\veebar\\rbrace\\) 不可定义 \\(\\land\\)，且 \\(\\lbrace \\lor, \\land, \\rightarrow, \\leftrightarrow\\rbrace\\) 不可定义 \\(\\neg\\). 设 \\(\\mathbb{F}\\) 为任意真值函数集合，并设 \\(f\\) 为任意真值函数。如果 \\(f\\) 可以由 \\(\\mathbb{F}\\) 中的函数复合而成，我们就称 \\(f\\) 是 \\(\\mathbb{F}\\) 可定义的。下述习题的目的，是直接证明「函数版本」的函数完全性（见§3.5.0（P.122）开端处的说明）。这个证明应比 §3.5.1（P.124）中的证明「漂亮」，尽管思路可以差不多。熟悉函数复合的读者可以试做。 对每个自然数 \\(n&gt;0\\)，令 \\(f_{\\lor, n}\\) 为 \\(n\\) 元真值函数，使得对所有 \\(a_{0}, \\cdots, a_{n-1} \\in\\lbrace 0,1\\rbrace\\)，\\(f_{\\lor, n}(a_{0}, \\cdots, a_{n-1})=1\\) 当且仅当 \\(a_{0}, \\cdots, a_{n-1}\\) 中至少有一个是 1；并令 \\(f_{\\wedge, n}\\) 为 \\(n\\) 元真值函数，使得对所有 \\(a_{0}, \\cdots, a_{n-1} \\in \\lbrace 1, 0\\rbrace\\)，\\(f_{\\wedge, n}(a_{0}, \\cdots, a_{n-1})=1\\) 当且仅当 \\(a_{0}, \\cdots, a_{n+1}\\) 都是 1. 练习 4.29 令 \\(\\mathbb{F}=\\lbrace f_{\\neg}\\rbrace \\cup\\lbrace f_{\\vee, n}: n&gt;0\\rbrace \\cup\\lbrace f_{\\wedge, n}: n&gt;0\\rbrace\\). 证明：所有真值函数都是 \\(\\mathbb{F}\\) 可定义的。 练习 4.30 证明： 所有真值函数都是 \\(\\lbrace f_{\\neg}, f_{\\lor}, f_{\\wedge}\\rbrace\\)-可定义的； 所有真值函数都是 \\(\\lbrace f_{\\neg}, f_{\\lor}\\rbrace\\)-可定义的，都是 \\(\\lbrace f_{\\neg}, f_{\\wedge}\\rbrace\\)-可定义的，并且都是 \\(\\lbrace f_{\\neg}, f_{\\rightarrow}\\rbrace\\)-可定义的； 所有真值函数都是 \\(\\lbrace f_{\\mid}\\rbrace\\)-可定义的，并且都是 \\(\\lbrace f_{\\|}\\rbrace\\)-可定义的。 Editorial comments 有屁请在此处放，看看谁的屁更响。 "],["references.html", "References", " References Frege, G. (1879). Begriffsschrift, eine der arithmetischen nachgebildete Formel sprache des reinen Denkens. Verlag von L. Nebert, Halle, 5–82. Gödel, K. (1944). Russell’s mathematical logic. In P. Schilpp (Ed.), The philosophy of bertrand russell (pp. 119–141). The Philosophy of Bertrand Russell. Henkin, L. (1967). Systems, formal, and models of formal systems. In P. Edwards (Ed.), The encyclopedia of philosophy, vol (pp. 61–74). Macmillan, Inc. Hodges, W. (1977). Logic. Penguin Books. Tarski, A. (1941). Introduction to Logic and to the Methodology of the Deductive Sciences. Oxford University Press. "]]
